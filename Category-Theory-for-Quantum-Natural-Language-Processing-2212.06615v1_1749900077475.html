
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Doc2x-Export-Html-Result</title>
        <style>
            * {
              padding: 0;
              margin: 0;
              box-sizing: border-box;
            }
             html {
              line-height: 1.15; /* 1 */
              -webkit-text-size-adjust: 100%; /* 2 */
            }
            body {
              padding: 20px;
              margin: 0;
            }
            main {
              display: block;
            }
            h1 {
              font-size: 2em;
              margin: 0.67em 0;
            }
            hr {
              box-sizing: content-box; /* 1 */
              height: 0; /* 1 */
              overflow: visible; /* 2 */
            }
            pre {
              font-family: monospace, monospace; /* 1 */
              font-size: 1em; /* 2 */
            }
            a {
              background-color: transparent;
            }
            abbr[title] {
              border-bottom: none; /* 1 */
              text-decoration: underline; /* 2 */
              text-decoration: underline dotted; /* 2 */
            }
            b,
            strong {
              font-weight: bolder;
            }
            code,
            kbd,
            samp {
              font-family: monospace, monospace; /* 1 */
              font-size: 1em; /* 2 */
            }
            small {
              font-size: 80%;
            }
            sub,
            sup {
              font-size: 75%;
              line-height: 0;
              position: relative;
              vertical-align: baseline;
            }
            sub {
              bottom: -0.25em;
            }
            sup {
              top: -0.5em;
            }
            img {
              border-style: none;
            }
            button,
            input,
            optgroup,
            select,
            textarea {
              font-family: inherit; /* 1 */
              font-size: 100%; /* 1 */
              line-height: 1.15; /* 1 */
              margin: 0; /* 2 */
            }
            button,
            input { /* 1 */
              overflow: visible;
            }
            button,
            select { /* 1 */
              text-transform: none;
            }
            button,
            [type="button"],
            [type="reset"],
            [type="submit"] {
              -webkit-appearance: button;
            }
            button::-moz-focus-inner,
            [type="button"]::-moz-focus-inner,
            [type="reset"]::-moz-focus-inner,
            [type="submit"]::-moz-focus-inner {
              border-style: none;
              padding: 0;
            }
            button:-moz-focusring,
            [type="button"]:-moz-focusring,
            [type="reset"]:-moz-focusring,
            [type="submit"]:-moz-focusring {
              outline: 1px dotted ButtonText;
            }
            fieldset {
              padding: 0.35em 0.75em 0.625em;
            }
            legend {
              box-sizing: border-box; /* 1 */
              color: inherit; /* 2 */
              display: table; /* 1 */
              max-width: 100%; /* 1 */
              padding: 0; /* 3 */
              white-space: normal; /* 1 */
            }
            progress {
              vertical-align: baseline;
            }
            textarea {
              overflow: auto;
            }
            [type="checkbox"],
            [type="radio"] {
              box-sizing: border-box; /* 1 */
              padding: 0; /* 2 */
            }
            [type="number"]::-webkit-inner-spin-button,
            [type="number"]::-webkit-outer-spin-button {
              height: auto;
            }
            [type="search"] {
              -webkit-appearance: textfield; /* 1 */
              outline-offset: -2px; /* 2 */
            }
            [type="search"]::-webkit-search-decoration {
              -webkit-appearance: none;
            }
            ::-webkit-file-upload-button {
              -webkit-appearance: button; /* 1 */
              font: inherit; /* 2 */
            }
            details {
              display: block;
            }
            summary {
              display: list-item;
            }
            [hidden] {
              display: none;
            }
             table {
                border-collapse: collapse;
                width: 100%;
                margin-top: 20px;
                margin-bottom: 20px;
              }
              table thead {
                background-color: #e5e5e5;
              }
              table td {
                padding: 8px;
                /*background-color: #e5e5e5;*/
                border: 1px solid #ccc; /* 可选，添加边框样式 */
              }
              table th {
                padding: 8px;
                /*background-color: #e5e5e5;*/
                border: 1px solid #ccc; /* 可选，添加边框样式 */
              }
              h1, h2, h3, h4, h5, h6 {
                margin-bottom: 20px;
              }
              p {
                margin-top: 20px;
                text-indent: 2em;
                margin-bottom: 20px;
              }
        </style>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <style>

</style>
      </head>
      <body style="padding: 40px;">
        <h1>Category Theory for Quantum Natural Language Processing</h1>
<!-- Media -->
<!-- figureText: DOMI MINA TIO \( \mathbf{{MEA}} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_0.jpg?x=692&#x26;y=781&#x26;w=344&#x26;h=412&#x26;r=0">
<!-- Media -->
<p>Alexis TOUMI</p>
<p>Wolfson College</p>
<p>University of Oxford</p>
<p>A thesis submitted for the degree of</p>
<p>Doctor of Philosophy</p>
<p>Trinity 2022</p>
<!-- Meanless: ASAUAN FOLEEE TIGES ANSAH--><h2>Abstract</h2>
<p>This thesis introduces quantum natural language processing (QNLP) models based on a simple yet powerful analogy between computational linguistics and quantum mechanics: grammar as entanglement. The grammatical structure of text and sentences connects the meaning of words in the same way that entanglement structure connects the states of quantum systems. Category theory allows to make this language-to-qubit analogy formal: it is a monoidal functor from grammar to vector spaces. We turn this abstract analogy into a concrete algorithm that translates the grammatical structure onto the architecture of parameterised quantum circuits. We then use a hybrid classical-quantum algorithm to train the model so that evaluating the circuits computes the meaning of sentences in data-driven tasks.</p>
<p>The implementation of QNLP models motivated the development of DisCoPy (Distributional Compositional Python), the toolkit for applied category theory of which the first chapter gives a comprehensive overview. String diagrams are the core data structure of DisCoPy, they allow to reason about computation at a high level of abstraction. We show how they can encode both grammatical structures and quantum circuits, but also logical formulae, neural networks or arbitrary Python code. Monoidal functors allow to translate these abstract diagrams into concrete computation, interfacing with optimised task-specific libraries.</p>
<p>The second chapter uses DisCopy to implement QNLP models as parameterised functors from grammar to quantum circuits. It gives a first proof-of-concept for the more general concept of functorial learning: generalising machine learning from functions to functors by learning from diagram-like data. In order to learn optimal functor parameters via gradient descent, we introduce the notion of diagrammatic differentiation: a graphical calculus for computing the gradients of parameterised diagrams.</p><h2>Contents</h2>
<p>Introduction 7</p>
<p>What are quantum computers good for? 7</p>
<p>Why should we make NLP quantum? 11</p>
<p>How can category theory help? 16</p>
<p>Contributions 22</p>
<p>Publications 26</p>
<p>Outreach 28</p>
<p>1 DisCoPy: Python for the applied category theorist 31</p>
<p>1.1 Categories in Python 33</p>
<p>1.1.1 Free categories 40</p>
<p>1.1.2 Quotient categories 46</p>
<p>1.1.3 Daggers, sums and bubbles 48</p>
<p>1.2 Diagrams in Python 56</p>
<p>1.2.1 Foo monoidal categories 60</p>
<p>1.2.2 Free monoidal categories 63</p>
<p>1.2.3 Quotient monoidal categories 71</p>
<p>1.2.4 Daggers, sums and bubbles 73</p>
<p>1.2.5 From tacit to explicit programming 77</p>
<p>1.3 Drawing &#x26; reading 79</p>
<p>1.3.1 Labeled generic progressive plane graphs 79</p>
<p>1.3.2 From diagrams to graphs and back 80</p>
<p>1.3.3 A natural isomorphism 87</p>
<p>1.3.4 Daggers, sums and bubbles 89</p>
<p>1.3.5 Automatic diagram recognition 91</p>
<p>1.4 Adding extra structure 96</p>
<p>1.4.1 Rigid categories &#x26; wire bending 96</p>
<p>1.4.2 Braided categories &#x26; wire crossing 106</p>
<p>1.4.3 Hypergraph categories &#x26; wire splitting 114</p>
<!-- Meanless: 5--><!-- Meanless: 6 Contents-->
<p>1.4.4 Products &#x26; coproducts 124</p>
<p>1.4.5 Biproducts 132</p>
<p>1.4.6 Closed categories 135</p>
<p>1.4.7 Traced categories 143</p>
<p>1.5 A premonoidal approach 146</p>
<p>1.5.1 Premonoidal categories &#x26; state constructions 147</p>
<p>1.5.2 Hypergraph versus premonoidal diagrams 151</p>
<p>1.5.3 Towards higher-dimensional diagrams 157</p>
<p>1.6 Summary &#x26; future work 163</p>
<p>2 Quantum natural language processing 169</p>
<p>2.1 Formal grammars and quantum complexity 169</p>
<p>2.1.1 Formal grammars, parsing and ambiguity 170</p>
<p>2.1.2 From the Lambek calculus to DisCoCat models 176</p>
<p>2.1.3 Anaphora and the quantum complexity of language 183</p>
<p>2.2 DisCoCat models on quantum hardware 186</p>
<p>2.2.1 Quantum channels and mixed quantum circuits 189</p>
<p>2.2.2 Simplifying QNLP models with snake removal 199</p>
<p>2.2.3 DisCoCat models via knowledge graph embedding 205</p>
<p>2.2.4 Variational quantum question answering 210</p>
<p>2.3 Diagrammatic differentiation 211</p>
<p>2.3.1 Dual diagrams 213</p>
<p>2.3.2 Differentiating the ZX-calculus 217</p>
<p>2.3.3 Differentiating quantum circuits 221</p>
<p>2.3.4 Bubbles and the chain rule 223</p>
<p>2.4 Conclusion 224</p>
<p>Acknowledgements 227</p>
<p>References 229</p><h2>Introduction</h2>
<h2>What are quantum computers good for?</h2>
<p>Nature isn't classical, dammit, and if you want to make a simulation of nature, you'd better make it quantum mechanical, and by golly it's a wonderful problem, because it doesn't look so easy.</p>
<p>Simulating Physics with Computers, Feynman</p>
<p>(1981)</p>
<p>Quantum computers harness the principles of quantum theory such as superposition and entanglement to solve information-processing tasks. In the last 42 years, quantum computing has gone from theoretical speculations to the implementation of machines that can solve problems beyond what is possible with classical means. This section will sketch a brief and biased history of the field and of its future challenges.</p>
<p>In 1980, Benioff [Ben80] takes the abstract definition of a computer and makes it physical: he designs a quantum mechanical system whose time evolution encodes the computation steps of a given Turing machine. In retrospect, this may be taken as the first proof that quantum mechanics can simulate classical computers. The same year, Manin [Man80] looks at the opposite direction: he argues that it should take exponential time for a classical computer to simulate a generic quantum system. Feynman [Fey82; Fey85] comes to the same conclusion and suggests a way to simulate quantum mechanics much more efficiently: building a quantum computer!</p>
<p>So what are quantum computers good for? Feynman's intuition gives us a first, trivial answer: at least quantum computers could simulate quantum mechanics efficiently. Deutsch [Deu85] makes the question formal by defining quantum Turing machines and the circuit model. Deutsch and Jozsa [DJ92] design the first quantum algorithm and prove that it solves some problem exponentially faster than any classical deterministic algorithm. \({}^{1}\) Simon [Sim94] improves on their result by designing a problem that a quantum computer can solve exponentially faster than any classical algorithm. Deutsch-Jozsa and Simon relied on oracles \({}^{1}\) and promises \({}^{2}\) and their problems have little practical use. However,they inspired Shor’s algorithm [Sho94] for prime factorisation and discrete logarithm. These two problems are believed to require exponential time for a classical computer and their hardness is at the basis of the public-key cryptography schemes currently used on the internet.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A classical randomised algorithm solves the problem in constant time with high probability.</p>
<!-- Footnote -->
<hr>
<!-- Meanless: 7--><!-- Meanless: 8 Introduction-->
<p>In 1997, Grover provides another application for quantum computers: "searching for a needle in a haystack" [Gro97]. Formally,given a function \(f : X \rightarrow  \{ 0,1\}\) and the promise that there is a unique \(x \in  X\) with \(f\left( x\right)  = 1\) ,Grover’s algorithm finds \(x\) in \(O\left( \sqrt{\left| X\right| }\right)\) steps,quadratically faster than the optimal \(O\left( \left| X\right| \right)\) classical algorithm. Grover's algorithm may be used to brute-force symmetric cryptographic keys twice bigger than what is possible classically [BBD09]. It can also be used to obtain quadratic speedups for the exhaustive search involved in the solution of NP-hard problems such as constraint satisfaction [Amb04]. Independently, Bennett et al. [Ben+97] prove that Grover's algorithm is in fact optimal, adding evidence to the conjecture that quantum computers cannot solve these NP-hard problems in polynomial time. Chuang et al. [CGK98] give the first experimental demonstration of a quantum algorithm, running Grover's algorithm on two qubits.</p>
<p>Shor's and Grover's discovery of the first real-world applications sparked a considerable interest in quantum computing. The core of these two algorithms has then been abstracted away in terms of two subroutines: phase estimation [Kit95] and amplitude amplification \(\left\lbrack  {\mathrm{{Bra}} + {02}}\right\rbrack\) ,respectively. Making use of both these subroutines,the \({\mathrm{{HHL}}}^{3}\) algorithm [HHL09] tackles one of the most ubiquitous problems in scientific computing: solving systems of linear equations. Given a matrix \(A \in  {\mathbb{R}}^{n \times  n}\) and a vector \(b \in  {\mathbb{R}}^{n}\) ,we want to find a vector \(x\) such that \({Ax} = b\) . Under some assumptions on the sparsity and the condition number of \(A\) , HHL finds (an approximation of) \(x\) in time logarithmic in \(n\) when a classical algorithm would take quadratic time simply to read the entries of \(A\) . This initiated a new wave of enthusiasm for quantum computing with the promise of exponential speedups for machine learning tasks such as regression [WBL12], clustering [LMR13], classification [RML14], dimensionality reduction [LMR14] and recommendation [KP16]. The narrative is appealing: machine learning is about finding patterns in large amounts of data represented as high-dimensional vectors and tensors, which is precisely what quantum computers are good at. The argument can be formalised in terms of complexity theory: HHL is BQP-complete \({}^{1}\) hence if there is an exponential advantage for quantum algorithms at all there must be one for HHL.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) An oracle is a black box that allows a Turing machine to solve a certain problem in one step.</p>
<p>\({}^{2}\) The input is promised to satisfy a certain property,which may be hard to check.</p>
<p>\({}^{3}\) Named after its discoverers Harrow,Hassidim and Lloyd.</p>
<!-- Footnote -->
<hr><!-- Meanless: Introduction 9-->
<p>However, the exponential speedup of HHL comes with some caveats, thoroughly analysed by Aaronson [Aar15]. Two of these challenges are common to many quantum algorithms: 1) the efficient encoding of classical data into quantum states and 2) the efficient extraction of classical data via quantum measurements. Indeed, what HHL really takes as input is not a vector \(b\) but a quantum state \(\left| {b\rangle  = \mathop{\sum }\limits_{{i = 1}}^{n}{b}_{i}}\right| i\rangle\) called its amplitude encoding. Either the input vector \(b\) has enough structure that we can describe it with a simple, explicit formula. This is the case for example in the calculation of electromagnetic scattering cross-sections [CJS13]. Or we assume that our classical data has been loaded onto a quantum random-access memory (qRAM) that can prepare the state in logarithmic time [GLM08]. Not only is qRAM a daunting challenge from an engineering point of view, in some cases it also requires too much error correction for the state preparation to be efficient [Aru+15]. Symmetrically,the output of HHL is not the solution vector \(x\) itself but a quantum state \(|x\rangle\) from which we can measure some observable \(\langle x\left| M\right| x\rangle\) . If preparing the state \(|b\rangle\) requires a number of gates exponential in the number of qubits,or if we need exponentially many measurements of \(|x\rangle\) to compute our classical output, then the quantum speedup disappears.</p>
<p>Shor, Grover and HHL all assume fault-tolerant quantum computers [Sho96]. Indeed, any machine we can build will be subject to noise when performing quantum operations, errors are inevitable: we need an error correcting code that can correct these errors faster than they appear. This is the content of the quantum threshold theorem [AB08] which proves the possibility of fault-tolerant quantum computing given physical error rates below a certain threshold. One noteworthy example of such a quantum error correction scheme is Kitaev's toric code [Kit03] and the general idea of topological quantum computation \(\left\lbrack  {\mathrm{{Fre}} + {03}}\right\rbrack\) which offers the long-term hope for a quantum computer that is fault-tolerant "by its physical nature". However this hope relies on the existence of quasi-particles called Majorana zero-modes, which as of 2021 has yet to be experimentally demonstrated [Bal].</p>
<p>The road to large-scale fault-tolerant quantum computing will most likely be a long one. So in the meantime, what can we do with the noisy intermediate-scale quantum machines we have available today, in the so-called NISQ era [Pre18]? Most answers involve a hybrid classical-quantum approach where a classical algorithm is used to optimise the preparation of quantum states \(\left\lbrack  {\mathrm{{McC}} + {16}}\right\rbrack\) . Prominent examples include the quantum approximate optimisation algorithm (QAOA [FGG14]) for combinatorial problems such as maximum cut and the variational quantum eigen-solver (VQE [Per+14]) for approximating the ground state of chemical systems. These variational algorithms depend on the choice of a parameterised quantum circuit called the ansatz, based on the structure of the problem and the resources available. Some families of ansätze such as instantaneous quantum polynomial-time (IQP) circuits are believed to be hard to simulate classically even at constant depth [SB09], opening the door to potentially near-term NISQ speedups.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A BQP-complete problem is one that is polynomial-time equivalent to the circuit model,the hardest problem that a quantum computer can solve with bounded error in polynomial time.</p>
<!-- Footnote -->
<hr><!-- Meanless: 10 Introduction-->
<p>Although the hybrid approach first appeared in the context of machine learning \(\left\lbrack  {\mathrm{{Ban}} + {08}}\right\rbrack\) ,the idea of using parameterised quantum circuits as machine learning models went mostly unnoticed for a decade [BLS19]. It was rediscovered under the name of quantum neural networks [FN18] then implemented on two-qubits [Hav+19], generating a new wave of attention for quantum machine learning. The idea is straightforward: 1) encode the input vector \(x \in  {\mathbb{R}}^{n}\) as a quantum state \(\left| {\phi }_{x}\right\rangle\) via the ansatz of our choice,2) initialise a random vector of parameters \(\theta  \in  {\mathbb{R}}^{d}\) and encode it as a measurement \({M}_{\theta }\) ,again via some choice of ansatz 3 ) take the probability \(y = \left\langle  {\phi \left( x\right) \left| {M}_{\theta }\right| \phi \left( x\right) }\right\rangle\) as the prediction of the model. A classical algorithm then uses this quantum prediction as a subroutine to find the optimal parameters \(\theta\) in some data-driven task such as classification.</p>
<p>One of the many challenges on the way to solving real-world problems with parameterised quantum circuits is the existence of barren plateaus [McC+18]: with random circuits as ansatz, the probability of non-zero gradients is exponentially small in the number of qubits and our classical optimisation gets lost in a flat landscape. One cannot help but notice the striking similarity with the vanishing gradient problem for classical neural networks, formulated twenty years earlier [Hoc98]. Barren plateaus do not appear in circuits with enough structure such as quantum convolutional networks \(\left\lbrack  {\mathrm{{Pes}} + {21}}\right\rbrack\) ,they can also be mitigated by structured initialisation strategies [Gra+19]. Another direction is to avoid gradients altogether and use kernel methods [SK19]: instead of learning a measurement \({M}_{\theta }\) ,we use our NISQ device to estimate the distance \({\left| \left\langle  {\phi }_{{x}^{\prime }} \mid  {\phi }_{x}\right\rangle  \right| }^{2}\) between pairs of input vectors \(x,{x}^{\prime } \in  {\mathbb{R}}^{n}\) embedded in the high-dimensional Hilbert space of our ansatz. We then use a classical support vector machine to find the optimal hyperplane that separates our data, with theoretical guarantees to learn quantum models at least as good as the variational approach [Sch21].</p>
<p>Random quantum circuits may be unsuitable for machine learning, but they play a crucial role in the quest for quantum advantage, the experimental demonstration of a quantum computer solving a task that cannot be solved by classical means in any reasonable time. We are back to Feynman's original intuition: sampling from a random quantum circuit is the perfect candidate for such a task. The end of 2019 saw the first claim of such an advantage with a 53-qubit computer [Aru+19]. The claim was almost immediately contested by a classical simulation of 54 qubits in two and a half days [Ped+19] then in five minutes [Yon+21]. Zhong et al. [Zho+20] made a new claim with a 76-photon linear optical quantum computer followed by another with a 66-qubit computer \(\left\lbrack  {\mathrm{{Wu}} + {21};\mathrm{{Zhu}} + {21}}\right\rbrack\) . They estimate that a classical simulation of the sampling task they completed in a couple of hours would take at least ten thousand years.</p><!-- Meanless: Introduction 11-->
<p>Now that quantum computers are being demonstrated to compute something beyond classical, the question remains: can they compute something useful?</p>
<h2>Why should we make NLP quantum?</h2>
<p>A girl operator typed out on a keyboard the following Russian text in English characters: "Mi pyeryedayem mislyi posryedstvom ryechi". The machine printed a translation almost simultaneously: "We transmit thoughts by means of speech." The operator did not know Russian.</p>
<p>New York Times (8th January 1954)</p>
<p>The previous section hinted at the fact that quantum computing cannot simply solve any problem faster. There needs to be some structure that a quantum computer can exploit: its own structure in the case of physics simulation or the group-theoretic structure of cryptographic protocols in Shor's algorithm.</p>
<p>So why should we expect quantum computers to be any good at natural language processing (NLP)? This section will argue that natural language shares a common structure with quantum theory, in the form of two linguistic principles: compositionality and distributionality.</p>
<p>We start our history of artificial intelligence (AI) in 1950 with a philosophical question from Turing [Tur50]: "Can machines think?" reformulated in terms of a game, now known as the Turing test, in which a machine tries to convince a human interrogator that it is human too. In order to put human and machine on an equal footing, Turing suggests to let them communicate only via written language: his thought experiment actually defined an NLP task. Only four years later, NLP goes from philosophical speculation to experimental demonstration: the IBM 701 computer successfully translated sentences from Russian to English such as "They produce alcohol out of potatoes." [Hut04]. With only six grammatical rules and a 250-word vocabulary taken from organic chemistry and other general topics, this first experiment generated a great deal of public attention and the overly-optimistic prediction that machine translation would be an accomplished task in "five, perhaps three" years.</p><!-- Meanless: 12 Introduction-->
<p>Two years later, Chomsky [Cho56; Cho57] proposes a hierarchy of models for natural language syntax which hints at why NLP would not be solved so fast. In the most expressive model, which he argues is the most appropriate for studying natural language, the parsing problem is in fact Turing-complete. Let alone machine translation, merely deciding whether a given sequence of words is grammatical can go beyond the power of any physical computer. Chomsky's parsing problem is a linguistic reinterpretation of an older problem from Thue [Thu14], now known as the word problem for monoids \({}^{1}\) and proved undecidable by Post [Pos47] and Markov [Mar47] independently. This reveals a three-way connection between theoretical linguistics, computer science and abstract algebra which will pervade much of this thesis. But if we are interested in solving practical NLP problems, why should we care about such abstract constructions as formal grammars?</p>
<p>Most NLP tasks of interest involve natural language semantics: we want machines to compute the meaning of sentences. Given the grammatical structure of a sentence, we can compute its meaning as a function of the meanings of its words. This is known as the principle of compositionality,usually attributed to Frege. \({}^{2}\) It was already implicit in Boole's laws of thought [Boo54] and then made explicit by Carnap [Car47]. Montague [Mon74; Mon70; Mon73] then formalised this principle as a homomorphism from the algebra of syntax (i.e. grammar) to that of semantics (i.e. logic). He applied compositionality to linguistics for the first time, arguing that there is "no important theoretical difference between natural languages and the artificial languages of logicians". Compositionality became the basis of the symbolic approach to NLP, also known as good old-fashioned AI (GOFAI) [Hau89]. Word meanings are first encoded in a machine-readable format, then the machine can compose them to answer complex questions. This approach culminated in 2011 with IBM Watson defeating a human champion at Jeopardy! [LF11].</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Historically,Thue,Markov and Post were working with semigroups,i.e. unitless monoids.</p>
<p>\({}^{2}\) Compositionality does not appear in any of Frege’s published work [Pel01]. Frege did state what is known as the context principle: "it is enough if the sentence as whole has meaning; thereby also its parts obtain their meanings". This can be taken as a kind of dual to compositionality: the meanings of the words are functions of the meaning of the sentence.</p>
<!-- Footnote -->
<hr><!-- Meanless: Introduction 13-->
<p>The same year, Apple deploy their virtual assistant in the pocket of millions of users, soon followed by internet giants Amazon and Google. While Siri, Alexa and their competitors have made NLP mainstream, none of them make any explicit use of formal grammars. Instead of the complex grammatical analysis and knowledge representation of expert systems like Watson, the AI of these next-generation NLP machines is powered by deep neural networks and machine learning of big data. Although their architecture got increasingly complex, these neural networks implement a simple statistical concept: language models, i.e. probability distributions over sequences of words. Instead of the compositionality of symbolic AI, these statistical methods rely on another linguistic principle, distributionality: words with similar distributions have similar meanings.</p>
<p>This principle may be traced back to Wittgenstein's Philosophical Investigations: "the meaning of a word is its use in the language" [Wit53], usually shortened into the slogan meaning is use. It was then formulated in the context of computational linguistics by Harris [Har54], Weaver [Wea55] and Firth [Fir57], who coined the famous quotation: "You shall know a word by the company it keeps!" Before deep neural networks took over, the standard way to formalise distributionality had been vector space models [SWY75]. We have a set of \(N\) words appearing in a set of \(M\) documents and we simply count how many times each word appears in each document to get a \(M \times  N\) matrix. We normalise it with a weighting scheme like tf-idf (term frequency by inverse document frequency), factorise it (via e.g. singular value decomposition or non-negative matrix factorisation) and we're done! The columns of the matrix encode the meanings of words, taking their inner product yields a measure of word similarity which can then be used in tasks such as classification or clustering. This method has the advantage of simplicity and it works surprisingly well in a wide range of applications from spam detection to movie recommendation [TP10]. Its main limitation is that a sentence is represented not as a sequence but as a bag of words, the word vectors will be the same whether the corpus contained "dog bites man" or "man bites dog". A standard way to fix this is to compute vectors not for words in isolation but for \(n\) -grams,windows of \(n\) consecutive words for some fixed size \(n\) . However the fix has its own limits: if \(n\) is too small we cannot detect any long-range correlations,if it is too big then the matrix is so sparse that we cannot detect anything at all.</p>
<p>In contrast, the recurrent neural networks (RNNs) of Rumelhart, Hinton and Williams [RHW86] are inherently sequential and their internal state can encode arbitrarily long-range correlations. At each step, the network processes the next word in a sequence and updates its internal state. This internal memory can then be used to predict the rest of the sequence, or fed as input to another network e.g. for translation into another language. Once the obstacles to training were overcome (such as the vanishing gradients mentioned above), RNN architectures such as long short-term memory (LSTM) [HS97] set records in a variety of NLP tasks such as language modeling [SMH11], speech recognition [GMH13] and machine translation [SVL14]. The purely sequential approach of RNNs turned out to be limited: when the network is done reading, the information from the first word has to propagate through the entire text before it can be translated. Bidirectional RNNs [SP97] fix this issue by reading both left-to-right and right-to-left. Nonetheless, it is somewhat unsatisfactory from a cognitive perspective (humans manage to understand text without reading backward, why should a machine do that?) and also harder to use in online settings where words need to be processed one at a time.</p><!-- Meanless: 14 Introduction-->
<p>Attention mechanisms provide a much more elegant solution: instead of assuming that the "company" of a word is its immediate left and right neighbourhood, we let the neural network itself learn which words are relevant to which. First introduced as a way to boost the performance of RNNs on translation tasks [BCB15], attention has then become the basis of the transformer model [Vas+17]: a stack of attention mechanisms which process sequences without recurrence altogether. Starting with BERT [Dev+19], transformers have replaced RNNs as the state-of-the-art NLP model, culminating with the GPT-3 language generator authoring its own article in The Guardian [GPT20]: "A robot wrote this entire article. Are you scared yet, human?"</p>
<p>Indeed why should we be scared? Because we are ignorant of how the robot wrote the article and we cannot explain what in its billions of parameters made it write the way it did. Transformers and neural networks in general are black boxes: we can probe the way they map inputs to outputs, but if we look at the terabytes of weights in between, we find no interpretation of the mapping. Moreover without explainability there can be no fairness: if we cannot explain how its decisions are made, we can hardly prevent the network from reproducing the discriminations present both in the datasets and in the assumptions of the data scientist. We argue that explainable AI requires to make the distributional black boxes transparent by endowing them with a compositional structure: we need compositional distributional (DisCo) models that reconcile symbolic GOFAI with deep learning.</p>
<p>DisCo models have their roots in neuropsychology rather than AI. Indeed, they first appeared as models of the brain rather than architectures of learning machines. In their seminal work [MP43], McCullogh and Pitts give the first formal definition of neural networks and show how their "all-or-nothing" behaviour \({}^{1}\) allow them to encode a fragment of propositional logic. Hebb [Heb49] then introduced the first biological mechanism to explain learning and structured perception: "neurons that fire together, wire together". These computational models of the brain became the basis of connectionism [Smo87; Smo88] and the neurosymbolic [Hil97] approach to AI: high-level symbolic reasoning emerges from low-level neural networks. An influential example is Smolensky's tensor product representation [Smo90], where discrete structures such as lists and trees are embedded into the tensor product of two vector spaces,one for variables and one for values. Concretely,a list \({x}_{1},\ldots ,{x}_{n}\) of \(n\) vectors of dimension \(d\) is represented as a tensor \(\mathop{\sum }\limits_{{i \leq  n}}|i\rangle  \otimes  {x}_{i} \in  {\mathbb{R}}^{n} \otimes  {\mathbb{R}}^{d}\) . Smolensky [Smo90] is also the first to make the analogy between the distributional representations of compositional structures in AI and the group representations of quantum physics. He argues that symbolic structures embed in neural networks in the same way that the symmetries of particles embed in their state space: via representation theory, a precursor of category theory which we discuss in the next section.</p><!-- Meanless: Introduction 15-->
<p>Clark and Pulman [CP07b] propose to apply this tensor product representation to NLP, but they note its main weakness: lists of different lengths do not live in the same space, which makes it impossible to compare sentences with different grammatical structures. The categorical compositional distributional (DisCoCat) models of Clark, Coecke and Sadrzadeh [CCS08; CCS10] overcome this issue by taking the analogy with quantum one step further. Word meanings and grammatical structure are to linguistics what quantum states and entanglement structure are to physics. DisCoCat word meanings live in vector spaces and they compose with tensor products: the states of quantum theory do too. Grammar tells you how words are connected and how information flows in a sentence and in the same way, entanglement connects quantum states and tells you how information flows in a complex quantum system. This analogy allows to borrow well-established mathematical tools from quantum theory, and it was implemented on classical hardware with some empirical success on small-scale tasks such as sentence comparison [Gre+11] and word sense disambiguation [GS11; KSP13]. However representing the meaning of sentences as quantum processes comes at a price: they can be exponentially hard to simulate classically.</p>
<p>If DisCoCat models are intractable for classical computers, why not use a quantum computer instead? Zeng and Coecke [ZC16] answered this question with the first quantum natural language processing (QNLP) algorithm \({}^{1}\) and the proof of a quadratic speedup on a sentence classification task. Wieber et al. [Wie+19] later defined a QNLP algorithm based on a generalisation of the tensor product representation and proved it is BQP-complete: if any quantum algorithm has an exponential advantage, then in principle there must be one for QNLP. However promising they may be, both algorithms assume fault-tolerance and they are at least as far away from solving real-world problems as Grover and HHL.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A neuron’s response is either maximal or zero,regardless of the stimulus strength.</p>
<!-- Footnote -->
<hr><!-- Meanless: 16 Introduction-->
<p>This is where the work presented in this thesis comes in: we show it is possible to implement DisCoCat models on the machines available today. The author and collaborators \(\left\lbrack  {\mathrm{{Mei}} + {20}\mathrm{a};\mathrm{{Coe}} + {20}\mathrm{a}}\right\rbrack\) introduced the first NISQ-friendly framework for QNLP by translating DisCoCat models into variational quantum algorithms. We then implemented this framework and demonstrated the first QNLP experiment on a toy question-answering task \(\left\lbrack  {\mathrm{{Mei}} + {20}\mathrm{\;b}}\right\rbrack\) and more recent experiments showed empirical success on a larger-scale classification task [Lor+21]. Our framework was later applied to machine translation [Abb+21; Vic21], word-sense disambiguation [Hof21] and even to generative music [Mir+21]. Future experiments will have to demonstrate that QNLP is more than a mere analogy and that it can achieve quantum advantage on a useful task. But before we can discuss our implementation in detail, we have to make the DisCoCat analogy formal.</p>
<h2>How can category theory help?</h2>
<p>I should still hope to create a kind of universal symbolistic (spécieuse générale) in which all truths of reason would be reduced to a kind of calculus.</p>
<p>Letter to Nicolas Remond, Leibniz (1714)</p>
<p>"Every sufficiently good analogy is yearning to become a functor" [Bae06] and we will see that the analogy behind DisCoCat models is indeed a functor. Coecke et al. [CGS13] make a meta-analogy between their models of natural language and topological quantum field theories (TQFTs). Intuitively, there is an analogy between regions of spacetime and quantum processes: both can be composed either in sequence or in parallel. TQFTs formalise this analogy: they assign a quantum system to each region of space and a quantum process to each region of spacetime, in a way that respects sequential and parallel composition. In the same structure-preserving way, DisCoCat models assign a vector space to each grammatical type and a linear map to each grammatical derivation. Both TQFTs and DisCoCat can be given a one-sentence definition in terms of category theory: they are examples of functors into the category of vector spaces.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) We exclude previous algorithms that are inspired by quantum theory but run on classical computers such as the frameworks of Chen [Che02] and Blacoe et al. [BKL13].</p>
<!-- Footnote -->
<hr><!-- Meanless: Introduction 17-->
<p>How can the same piece of general abstract nonsense (category theory's nickname) apply to both quantum gravity and natural language processing? And how can this nonsense be of any help in the implementation of QNLP algorithms? This section will answer with a history of category theory and its applications to quantum physics and computational linguistics, from an abstract framework for meta-mathematics to a concrete toolbox for NLP on quantum hardware. First, a short philosophical digression on the etymology of the words "functor" and "category" shall bring some light to their divergent meanings in mathematics and linguistics.</p>
<p>The word "functor" first appears in Carnap's Logical syntax of language [Car37] to describe what would be called a function symbol in a modern textbook on first-order logic. He introduces them as a way to reduce the laws of empirical sciences like physics to the pure syntax of his formal logic, taking the example of a temperature functor \(T\) such that \(T\left( 3\right)  = 5\) means "the temperature at position 3 is \(5{}^{\prime \prime }{}^{1}\) . This meaning has then drifted to become synonymous with function words such as "such", "as", "with", etc. These words do not refer to anything in the world but serve as the grammatical glue between the lexical words that describe things and actions. They represent less than one thousandth of our vocabulary but nearly half of the words we speak [CP07a].</p>
<p>Categories (from the ancient Greek \({\kappa a\tau \eta \gamma o\rho i\alpha }\) ,"that which can be said") have a much older philosophical tradition. In his Categories, Aristotle first makes the distinction between the simple forms of speech (the things that are "said without any combination" such as "man" or "arguing") and the composite ones such as "a man argued". He then classifies the simple, atomic things into ten categories: "each signifies either substance or quantity or qualification or a relative or where or when or being-in-a-position or having or doing or being-affected". A common explanation [Ryl37] for how Aristotle arrived at such a list is that it comes from the possible types of questions: the answer to "What is it?" has to be a substance, the answer to "How much?" a quantity, etc. Although he was using language as a tool, his system of categories aims at classifying things in the world, not forms of speech: it was meant as an ontology, not a grammar. In his Critique of Pure Reason [Kan81], Kant revisits Aristotle's system to classify not the world, but the mind: he defines categories of understanding rather than categories of being. The idea that every object (whether in the world or in the mind) is an object of a certain type has then become foundational in mathematical logic and Russell's theory of types [Rus03]. The same idea has also had a great influence in linguistics and especially in the categorial grammar tradition initiated by Ajdukiewicz [Ajd35] and Bar-Hillel [Bar53; Bar54], where categories have now become synonymous with grammatical types. As we shall see in section 2.1.2, the key innovation from Aristotelian categories to categorial grammars is that the grammatical types now come with some structure: we can compose atomic categories together to form complex types, confusingly called functor categories.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) MacLane [Mac38] would later remark that Carnap’s formal language cannot express the coordinate system for positions, nor the scale in which temperature is measured.</p>
<!-- Footnote -->
<hr><!-- Meanless: 18 Introduction-->
<p>Independently of their use in linguistics, a series of papers from Eilenberg and MacLane [EM42a; EM42b; EM45] gave categories and functors their current mathematical definition. Inspired by Aristotle's categories of things and Kant's categories of thoughts, they defined categories as types of mathematical structures: sets, groups, spaces, etc. Their great insight was to focus not on the content of the objects (elements, points, etc.) but on the composition of the arrows between them: functions, homomorphisms, continuous maps, etc. Applying the same insight to categories themselves, what really matters are the arrows between them: functors, maps from one category to another that preserve the form of arrows. \({}^{1}\) A prototypical example is Poincaré's construction of the fundamental group of a topological space [Poi95], which can be defined as a functor from the category of (pointed) topological spaces to that of groups: every continuous map between spaces induces a homomorphism between their fundamental groups, in a way that respects composition and identity. Thus, the abstraction of category theory allowed to formalise the analogies between topology and algebra, proving results about one using methods from the other. It was then used as a tool for the foundation of algebraic geometry by the school of Grothendieck [GD60], which brought the analogy between geometric shapes and algebraic equations to a new level of abstraction and led to the development of topos theory.</p>
<p>The establishment of category theory as an independent discipline and as a foundation for mathematics owes much to the work of Lawvere. His influential Ph.D. thesis [Law63] on functorial semantics set up a framework for model theory where logical theories are categories and their models are functors. He then undertook the axiomatisation of the category of sets [Law64] and the category of categories [Law66]. The resulting notion of elementary topos [Law70a] subsumed Grothendieck's definition and emphasised the foundational concept of adjunction [Law69; Law70b]. "Adjoint functors arise everywhere" became the slogan of MacLane's classic textbook Categories for the working mathematician [Mac71]. Lambek [Lam68; Lam69; Lam72] used the related notion of cartesian closed categories to extend the Curry-Howard correspondance between logic and computation into a trinity with category theory: proofs and programs are arrows, logical formulae and data types are objects. The discovery of this three-fold connection resulted in a wide range of applications of category theory to theoretical computer science, surveyed in Scott [Sco00].</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) We can play the same game again: what matters are not so much the functors themselves but the natural transformations between them, which is what category theory was originally meant to define. To keep playing that game is to fall in the rabbit hole of infinity category theory [RV16].</p>
<!-- Footnote -->
<hr><!-- Meanless: Introduction 19-->
<p>This unification of mathematics, logic and computer science has been followed by a program for the categorical foundations for physics, initiated by Lawvere's topos-theoretic treatment of classical dynamics [Law79] and continuum physics [LS86] with Schanuel. As we mentioned at the start of this section, the work of Atiyah [Ati88], Baez and Dolan [BD95] on TQFTs showed categories and functors to be essential tools in the grand unification project of quantum gravity [Bae06]. This now quaternary analogy between physics, mathematics, logic and computation was popularised by Baez and Stay in their Rosetta Stone [BS10]. On more concrete grounds, this connection between category theory and quantum physics appeared in Selinger's proposal of a quantum programming language [Sel04] and the development of a quantum lambda calculus [Van04; SV06; SV+09]. The same insight blossomed in the school of categorical quantum mechanics (CQM) led by Abramsky and Coecke [AC04], where quantum processes are arrows in compact closed categories. This approach culminated in the \({ZX}\) calculus of Coecke and Duncan [CD08; CD11], a categorical axiomatisation which was proved complete for qubit quantum computing [JPV18; HNW18] with applications including error correction [Cha+18; GF19], circuit optimisation [KvdW20; Dun+20; dBBW20], compilation [CSD20; dGD20] and extraction [Bac+21].</p>
<p>In quantum computing as well, adjunction is fundamental: it underlies the definition of entanglement and the proof of correctness for the teleportation protocol. Back in 2004 when Coecke first presented this result at the McGill category theory seminar, Lambek immediately pointed out the analogy with his pregroup grammars [Lam99b; Lam01] where adjunction is the only grammatical rule \({}^{1}\) . Half a century beforehand, the Lambek calculus [Lam58; Lam59; Lam61] revealed an analogy between the derivations in categorial grammars and proof trees in mathematical logic. He then extended this analogy in Categorial and categorical grammar [Lam88] where he showed that these grammatical derivations are in fact arrows in closed monoidal categories and proposed to cast Montague semantics as a topos-valued functor. Later, he argued not "that categories should play a role in linguistics, but rather that they already do" [Lam99a]. Indeed, Hotz [Hot66] had already proved that Chomsky's generative grammars were free monoidal categories, although his original German article was never translated to English. The idea of using functors as semantics had appeared implicitly in Knuth [Knu68] in the context-free case and was made explicit by Benson [Ben70] for unrestricted grammars. From this categorical formulation of linguistics, Lambek [Lam10] first suggested the analogy between linguistics and physics which is the basis of this thesis: pregroup reductions as quantum processes.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) See [Coe21] for a first-hand account of this story and a praise of Jim Lambek.</p>
<!-- Footnote -->
<hr><!-- Meanless: 20 Introduction-->
<p>It is remarkable that Lambek could foresee QNLP without string diagrams \({}^{1}\) , probably the most powerful tool in the hands of the applied category theorist. They first appeared in another article from Hotz [Hot65] as a formalisation of the diagrams commonly used in electronics. Penrose [Pen71] then used the same notation as an informal shortcut for tedious tensor calculations, and later applied it to relativity theory with Rindler [PR84]. Joyal and Street [JS88; JS91; JS95] gave the first topological definition of string diagrams and characterised them as the arrows of free monoidal categories. A generalisation of string diagrams called proof nets were introduced by Girard [Gir87] as a way to free the proofs of his linear logic from "the bureaucracy of syntax", they were then applied to the Lambek calculus [Roo92] and to its multimodal extensions [MP02].</p>
<p>At first a piece of mathematical folklore that was hand-drawn on blackboards and rarely included in publications, string diagrams were published at a much bigger scale with the advent of typesetting tools like LATEX and TikZ. Selinger’s survey [Sel10], makes the hierarchy of categorical structures (symmetric, compact closed, etc.) correspond to a hierarchy of graphical gadgets (swaps, wire bending, etc.). In Picturing Quantum Processes [CK17], Coecke and Kissinger introduce quantum theory with over a thousand diagrams. And the list of applications keeps growing: electronics [BF15] and chemistry [BP17], control theory [BE14] and concurrency [BSZ14], databases [BSS18] and knowledge representation [Pat17], Bayesian inference [CS12; CJ19] and causality [KU19], cognition [Bol+17] and game theory [Gha+18], functional programming [Ril18] and machine learning [FST17].</p>
<p>If they are a great tool for writing scientific papers, string diagrams can also be a powerful data structure for developing software applications: quantomatic [KZ15] and its successor PyZX [KvdW19] perform automatic rewriting of diagrams in the ZX calculus, globular [BKV18] and its successor homotopy.io [RV19] are proof assistants for higher category theory, cartographer [SWZ19] and catlab [PSV21] implement diagrams in symmetric monoidal categories, which are also implicit in the circuit data structure of the \(\mathrm{t}|\mathrm{{ket}}\rangle\) compiler \(\left\lbrack  {\mathrm{{Siv}} + {20}}\right\rbrack\) . String diagrams are the main data structure of our QNLP algorithms: we translate the diagrams of sentences into diagrams of quantum circuits. As none of the existing category theory software was flexible enough, we had to implement our own: DisCoPy [Fel+20], a Python library for computing with functors and diagrams in monoidal categories. DisCoPy then became the engine underlying lambeq \(\left\lbrack  {\mathrm{{Kar}} + {21}}\right\rbrack\) ,a high-level library for experimental QNLP. Although its development was driven by the implementation of DisCoCat models on quantum computers, DisCoPy was designed as a general-purpose toolkit for applied category theory. It is freely available \({}^{1}\) (as in free beer and in free speech), reliable (with \({100}\%\) code coverage) and extensively documented \({}^{2}\) .</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) String diagrams do not appear in any of Lambek’s published work. Instead,he either uses lines of equations, proof trees or "underlinks" for pregroup adjunctions [Lam08]. He admits "not having had the patience to absorb" the topological definition of Joyal-Street string diagrams [Lam10].</p>
<!-- Footnote -->
<hr><!-- Meanless: Introduction 21-->
<p>In conclusion, category theory can really be a theory of anything: from algebraic geometry and quantum gravity to natural language processing. There is a striking analogy between category theory and string diagrams as a universal graphical language and the characteristica universalis and calculus ratiocinator dreamt by Leibniz three hundred years ago, a formal language and computational framework that would be able to express all of mathematics, science and philosophy. Indeed, not only can categories be tools for the working mathematicians and scientists, they can also be of help to the philosophers. In the footsteps of Grassmann's Ausdehnungslehre [Gra44] and his project of an algebraic formalisation of Hegel, Lawvere [Law89; Law91; Law92; Law96] set out to formulate Hegelian dialectics in terms of adjunctions. This led to the ongoing effort of Schreiber, Corfield and their collaborators on the nLab [SCn21] to translate Wissenschaft Der Logik [Heg12] in terms of category theory. Not only can it accommodate the absolute idealism of Hegel, category theory can also deal with the pragmatism of Peirce [Pei06], who developed first-order logic independently of Frege using what was later recognised as the first string diagrams [BT98; BT00; MZ16; HS20]. String diagrams have also been used to model Wittgenstein's language games as functors from a grammar to a category of games [HL18]. In recent work [FTC20], we applied these functorial language games to question answering, going from philosophy to NLP via category theory.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) <a href="https://github.com/oxford-quantum-group/discopy">https://github.com/oxford-quantum-group/discopy</a></p>
<p>2 <a href="https://discopy.readthedocs.io/">https://discopy.readthedocs.io/</a></p>
<!-- Footnote -->
<hr><!-- Meanless: 22 Introduction-->
<h2>Contributions</h2>
<p>The first chapter is an extended version of the DisCoPy paper [FTC20]. It emerged from a dialectic teacher-student collaboration with Giovanni de Felice: implementing our own category theory library was a way to teach him Python programming. Bob Coecke then added the capital letters to the name of DisCoPy. We list the contributions of each section.</p>
<ol>
<li>\({\mathrm{{We}}}^{1}\) give an introduction to elementary category theory for the Python programmer which is at the same time an introduction to object-oriented programming for the applied category theorist. This includes an implementation of:</li>
</ol>
<ul>
<li>
<p>the category Pyth with Python types as objects and functions as arrows (listing 1.1.11),</p>
</li>
<li>
<p>the category \({\mathbf{{Mat}}}_{\mathbb{S}}\) with natural numbers as objects and matrices with entries in a rig \(\mathbb{S}\) as arrows (listing 1.1.14),</p>
</li>
<li>
<p>free categories (listing 1.1.16) with quantum circuits as example (1.1.17),</p>
</li>
<li>
<p>the category Cat with categories as objects and functors as arrows (listing 1.1.18),</p>
</li>
<li>
<p>quotient categories (section 1.1.2),</p>
</li>
<li>
<p>categories with a dagger structure, i.e. an identity-on-objects contravariant involutive endofunctor, and categories enriched in commutative monoids (section 1.1.3),</p>
</li>
<li>
<p>categories with bubbles, i.e. arbitrary unary operators on homsets, with the example of neural networks (1.1.34) and propositional logic (1.1.35).</p>
</li>
</ul>
<ol start="2">
<li>We give an elementary definition of string diagrams for monoidal categories. Our construction decomposes the free monoidal category construction into three basic steps: 1) a layer endofunctor on the category of monoidal signatures, 2) the free premonoidal category as a free category of layers and 3) the free monoidal category as a quotient by interchangers. To the best of our knowledge, this premonoidal approach had been relegated to mathematical folklore: it was known by those who knew it, yet it never appeared in print. This includes:</li>
</ol>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) The "we" of this section refers to the author of this thesis. Although we believe that science is collaboration and that the notion of personal contribution is obsolete, it is in fact required by university regulations: "Where some part of the thesis is not solely the work of the candidate or has been carried out in collaboration with one or more persons, the candidate shall submit a clear statement of the extent of his or her own contribution."</p>
<!-- Footnote -->
<hr><!-- Meanless: Introduction 23-->
<ul>
<li>
<p>Pyth with lists of types as objects and tupling as tensor (listing 1.2.17),</p>
</li>
<li>
<p>Tensor \({}_{\mathbb{S}} \simeq  {\text{Mat}}_{\mathbb{S}}\) with lists of natural numbers as objects and Kronecker product as tensor (listing 1.2.18),</p>
</li>
<li>
<p>free monoidal categories (listing 1.2.24) with quantum circuits as example (1.2.26),</p>
</li>
<li>
<p>quotient monoidal categories (listing 1.2.3) with quantum circuit optimi-sation as example (1.2.31),</p>
</li>
<li>
<p>monoidal categories with daggers, sums and bubbles (section 1.2.4) with the example of post-processed quantum circuits (1.2.36) and first-order logic à la Peirce (1.2.37).</p>
</li>
</ul>
<p>DisCoPy uses a point-free or tacit programming style where diagrams are described only by composition and tensor. We discuss how to go from tacit to explicit programming, defining diagrams using the standard syntax for Python functions (section 1.2.5).</p>
<ol start="3">
<li>
<p>We prove the equivalence between our elementary definition of diagrams in terms of list of layers and the topological definition in terms of labeled generic progressive plane graphs. One side of this equivalence underlies the drawing algorithm of DisCoPy, the other side is the basis of a prototype for an automatic diagram recognition algorithm. We then discuss how to extend this to non-generic, non-progressive, non-planar, non-graph-like diagrams, which opens the door to the next section.</p>
</li>
<li>
<p>We describe our object-oriented implementation of monoidal categories with extra structure. The hierarchy of categorical structures (monoidal, closed, rigid, etc.) is encoded in a hierarchy of Python classes and an inheritance mechanism implements the free-forgetful adjunctions between them. This includes an implementation of:</p>
</li>
</ol>
<ul>
<li>
<p>free rigid categories, for which we introduce the snake removal algorithm to compute normal forms (section 1.4.1),</p>
</li>
<li>
<p>the syntax for diagrams in free braided, symmetric, tortile and compact-closed categories (section 1.4.2),</p>
</li>
<li>
<p>the syntax for diagrams in free hypergraph categories, i.e. with coherent special commutative Frobenius algebras on each object (section 1.4.3),</p>
</li>
</ul><!-- Meanless: 24 Introduction-->
<ul>
<li>
<p>the syntax for diagrams in free cartesian and cocartesian diagrams (section 1.4.4) with Pyth as an example of a rig category with two monoidal structures (listing 1.4.36),</p>
</li>
<li>
<p>the free biproduct completion as the category of matrices with arrows as entries (section 1.4.5), taking quantum measurements as example (1.4.44),</p>
</li>
<li>
<p>the syntax for diagrams in closed monoidal categories (section 1.4.6) with currying of functions in Pyth as example (1.4.46),</p>
</li>
<li>
<p>an implementation of Pyth as a traced cartesian and cocartesian category (listing 1.4.56) and \({\mathbf{{Mat}}}_{\mathbb{B}} \simeq\) FinRel as a traced biproduct category (listing 1.4.58).</p>
</li>
</ul>
<ol start="5">
<li>We discuss the relationship between our premonoidal approach and the existing graph-based data structures for diagrams in symmetric monoidal categories. This includes:</li>
</ol>
<ul>
<li>
<p>a comparison between our definition of premonoidal diagrams as lists of layers and the free premonoidal category as a state construction over a monoidal category (section 1.5.1),</p>
</li>
<li>
<p>an implementation of hypergraph diagrams, i.e. the arrows of free hypergraph categories, and the subcategories of compact, traced and symmetric diagrams (section 1.5.2),</p>
</li>
<li>
<p>an implementation of free sesquicategories (i.e. 2-categories without interchangers) with coloured diagrams as 2-cells (listing 1.5.9),</p>
</li>
<li>
<p>an implementation of Cat as a sesquicategory with (not-necessarily-natural) transformations as 2-cells (listing 1.5.10),</p>
</li>
<li>
<p>an implementation of free monoidal 2-categories with diagrams as 1-cells and rewrites as 2-cells (listing 1.5.12).</p>
</li>
</ul>
<p>The second chapter deals with QNLP, building on joint work with Bob Coecke, Giovanni de Felice and Konstantinos Meichanetzidis [Mei+20b; Coe+20a; Mei+20a].</p>
<ul>
<li>Section 2.1 gives a short introduction to formal grammars and ambiguity (2.1.1), the Lambek calculus, Montague semantics and DisCocat models (2.1.2). We conclude with a discussion of previous work on anaphora and the quantum complexity of language (2.1.3).</li>
</ul><!-- Meanless: Introduction 25-->
<ul>
<li>
<p>Section 2.2 defines QNLP models as functors from grammar to quantum circuits and show that any DisCoCat model can be implemented in this way. We discuss our implementation of classical-quantum channels and mixed quantum circuits (2.2.1) and the use of our snake removal algorithm to reduce both the number of qubits and the amount of post-selection required for QNLP models (2.2.2).</p>
</li>
<li>
<p>We review previous implementations of DisCoCat models and study their relationship with knowledge graph embeddings (2.2.3) and hybrid classical-quantum algorithm to train QNLP models on a question-answering task (2.2.4). The underlying idea of functorial learning, i.e. learning structure-preserving functors from diagram-like data, provides a theoretical framework for machine learning on structured data.</p>
</li>
</ul>
<p>The last section has been published in joint work with Richie Yeung and Giovanni de Felice [TYF21]. It introduces diagrammatic differentiation, a graphical calculus for computing the gradients of parameterised diagrams which applies to the training of QNLP models but also to functorial learning in general.</p>
<ul>
<li>
<p>In section 2.3.1, we generalise the dual number construction from rings to monoidal categories. Dual diagrams are formal sums of a string diagram (the real part) and its derivative with respect to some parameter (the epsilon part). We use bubbles to encode differentiation of diagrams and express the standard rules of calculus (linearity, product, chain) entirely in terms of diagrams.</p>
</li>
<li>
<p>In section 2.3.2, we study diagrammatic differentiation for the ZX calculus. This allows to compute the gradients of linear maps with respect to phase parameters.</p>
</li>
<li>
<p>In section 2.3.3, we look at the diagrammatic differentiation of mixed quantum circuits, this yields a definition of the parameter-shift rules used in quantum machine learning.</p>
</li>
<li>
<p>In section 2.3.4, we define the gradient of diagrams with bubbles in terms of the chain rule. This allows to differentiate quantum circuits with neural networks as classical post-processing.</p>
</li>
</ul><!-- Meanless: 26 Introduction-->
<h2>Publications</h2>
<p>The material presented in this thesis builds on the following publications.</p>
<!-- Media -->
<p>[FMT19] Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "Functorial Question Answering". In: Proceedings Applied Category Theory 2019, ACT 2019, University of Oxford, UK. Vol. 323. EPTCS. 2019. DOI: 10.4204/EPTCS. 323.6.</p>
<p>[Mei+20a] Konstantinos Meichanetzidis, Stefano Gogioso, Giovanni de Felice, Nicolò Chiappori, Alexis Toumi, and Bob Coecke. "Quantum Natural Language Processing on Near-Term Quantum Computers". In: Proceedings 17th International Conference on Quantum Physics and Logic, QPL 2020, Paris, France, June 2 - 6, 2020. Ed. by Benoît Valiron, Shane Mansfield, Pablo Arrighi, and Prakash Panangaden. Vol. 340. EPTCS. 2020, pp. 213-229. DOI: 10.4204/EPTCS. 340.11. arXiv: 2005.04147.</p>
<p>Giovanni de Felice, Alexis Toumi, and Bob Coecke. "DisCoPy: Monoidal Categories in Python". In: Proceedings of the 3rd Annual International Applied Category Theory Conference, ACT. Vol. 333. EPTCS, 2020. DOI: 10.4204/EPTCS. 333.13.</p>
<p>[Coe+20a] Da] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "Foundations for Near-Term Quantum Natural Language Processing". In: ArXiv e-prints (2020). arXiv: 2012.03755.</p>
<p>Konstantinos Meichanetzidis, Alexis Toumi, Giovanni de Felice, and Bob Coecke. "Grammar-Aware Question-Answering on Quantum Computers". In: ArXiv e-prints (2020). arXiv: 2012.03756.</p>
<p>Dimitri Kartsaklis, Ian Fan, Richie Yeung, Anna Pearson, Robin Lorenz, Alexis Toumi, Giovanni de Felice, Konstantinos Meichanetzidis, Stephen Clark, and Bob Coecke. "Lambeq: An Efficient High-Level Python Library for Quantum NLP". In: CoRR abs/2110.04236 (2021). arXiv: 2110.04236.</p><!-- Meanless: Introduction 27-->
<p>[TYF21] Alexis Toumi, Richie Yeung, and Giovanni de Felice. "Diagrammatic Differentiation for Quantum Machine Learning". In: Proceedings 18th International Conference on Quantum Physics and Logic, QPL 2021, Gdansk, Poland, and Online, 7-11 June 2021. Ed. by Chris Heunen and Miriam Backens. Vol. 343. EPTCS. 2021, pp. 132-144. DOI: 10.4204/EPTCS. 343.7.</p>
<p>[TK21] Alexis Toumi and Alex Koziell-Pipe. "Functorial Language Models". In: CoRR abs/2103.14411 (2021). arXiv: 2103.14411.</p>
<!-- Media -->
<p>During his DPhil, the author has also published the following articles.</p>
<!-- Media -->
<p>[Bor+19] Emanuela Boros, Alexis Toumi, Erwan Rouchet, Bastien Abadie, Dominique Stutzmann, and Christopher Kermorvant. "Automatic Page Classification in a Large Collection of Manuscripts Based on the International Image Interoperability Framework". In: International Conference on Document Analysis and Recognition. 2019. DOI: 10.1109/ICDAR. 2019.00126.</p>
<p>[Fel+20] Giovanni de Felice, Elena Di Lavore, Mario Román, and Alexis Toumi. "Functorial Language Games for Question Answering". In: Proceedings of the 3rd Annual International Applied Category Theory Conference 2020, ACT 2020, Cambridge, USA, 6-10th July 2020. Ed. by David I. Spivak and Jamie Vicary. Vol. 333. EPTCS. 2020, pp. 311-321. DOI: 10.4204/EPTCS. 333.21.</p>
<p>[STS20] Dan Shiebler, Alexis Toumi, and Mehrnoosh Sadrzadeh. "Incremental Monoidal Grammars". In: CoRR abs/2001.02296 (2020). arXiv: 2001.02296.</p>
<p>[Coe+21] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "How to Make Qubits Speak". In: CoRR abs/2107.06776 (2021). arXiv: 2107.06776.</p>
<p>[McP+21] Lachlan McPheat, Gijs Wijnholds, Mehrnoosh Sadrzadeh, Adriana Correia, and Alexis Toumi. "Anaphora and Ellipsis in Lambek Calculus with a Relevant Modality: Syntax and Semantics". In: CoRR abs/2110.10641 (2021). arXiv: 2110.10641.</p>
<!-- Media --><!-- Meanless: 28 Introduction-->
<h2>Outreach</h2>
<p>The content of this thesis has also been the subject of science popularisation aimed at a wide audience.</p>
<ul>
<li>A blog post summarising our first experiment and two podcasts with long</li>
</ul>
<p>discussions on the topic.</p>
<!-- Media -->
<p>be +20 b] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and</p>
<p>Alexis Toumi. Quantum Natural Language Processing. Apr. 7, 2020.</p>
<p>URL:</p>
<p><a href="https://medium.com/cambridge-quantum-computing/quantum-">https://medium.com/cambridge-quantum-computing/quantum-</a></p>
<p>natural-language-processing-748d6f27b31d (visited on</p>
<p>\({02}/{24}/{2022})\) .</p>
<p>[Fut21] Futurati Podcast. Ep. 52: Bob Coecke and Konstantinos</p>
<p>Meichanetzidis on Quantum Natural Language Processing. Sept. 21,</p>
<ol start="2021">
<li>URL: <a href="https://www.youtube.com/watch?v=5YZG96t8SLQ">https://www.youtube.com/watch?v=5YZG96t8SLQ</a></li>
</ol>
<p>(visited on \({02}/{24}/{2022}\) ).</p>
<p>[Mac21] Machine Learning Street Talk. #53 Quantum Natural Language</p>
<p>Processing - Prof Bob Coecke. 2021. URL:</p>
<p><a href="https://www.youtube.com/watch?v=X9uSV1YcOy4">https://www.youtube.com/watch?v=X9uSV1YcOy4</a> (visited on</p>
<p>\({02}/{24}/{2022})\) .</p>
<!-- Media -->
<ul>
<li>Two invited lectures at the Compositional Systems and Methods group in</li>
</ul>
<p>TalTech, Estonia. Lecture notes are available as Jupyter [Klu+16] notebooks.</p>
<p>[TF21a] Alexis Toumi and Giovanni de Felice. Categories for Linguistics.</p>
<p>May 3, 2021. URL:</p>
<p><a href="https://github.com/oxford-quantum-group/discopy/blob/">https://github.com/oxford-quantum-group/discopy/blob/</a></p>
<p>ea5b370d4853d7c0bdd1c3c4719a5f71917b1b6c/docs/slides/21-</p>
<p>05-03-tallcat.ipynb (visited on 04/03/2022).</p>
<p>Alexis Toumi and Giovanni de Felice. Categories for Quantum.</p>
<p>May 5, 2021. URL:</p>
<p><a href="https://github.com/oxford-quantum-group/discopy/blob/">https://github.com/oxford-quantum-group/discopy/blob/</a></p>
<p>ea5b370d4853d7c0bdd1c3c4719a5f71917b1b6c/docs/slides/21-</p>
<p>05-05-tallcat.ipynb (visited on 04/03/2022).</p><!-- Meanless: Introduction 29-->
<ul>
<li>A presentation at an educational event for programmers and data scientists.</li>
</ul>
<p>[Tou20] Alexis Toumi. Language Processing on Quantum Hardware with DisCoPy. PyData Berlin. Sept. 21, 2020. URL:</p>
<p><a href="https://www.youtube.com/watch?v=5jK8qEQvR-o">https://www.youtube.com/watch?v=5jK8qEQvR-o</a> (visited on \({02}/{24}/{2022})\) .</p>
<ul>
<li>A hackathon where students implemented QNLP experiments with DisCoPy.</li>
</ul>
<p>[Mol21] Paula Garcia Molina. QNLP Qiskit Hackathon. Oct. 22, 2021. URL: https:</p>
<p>//github.com/PaulaGarciaMolina/QNLP_Qiskit_Hackathon (visited on \({02}/{24}/{2022}\) ).</p>
<ul>
<li>A press release explaining QNLP in plain English.</li>
</ul>
<p>[Ins20] The Quantum Insider. CQC Researchers Make Major Quantum NLP Advance in Steps Toward 'Meaning Aware' Computers. Dec. 10, 2020. URL: <a href="https://thequantuminsider.com/2020/12/10/meaning-aware-computers-cqc-researchers-make-major-nlp-advance-in-using-quantum-computers-to-understand-language-and-towards-achieving-meaningful-quantum-advantage/">https://thequantuminsider.com/2020/12/10/meaning-aware-computers-cqc-researchers-make-major-nlp-advance-in-using-quantum-computers-to-understand-language-and-towards-achieving-meaningful-quantum-advantage/</a> (visited on \({02}/{24}/{2022}\) ).</p>
<ul>
<li>Press releases introducing lambeq \(\left\lbrack  {\mathrm{{Kar}} + {21}}\right\rbrack\) to a business audience.</li>
</ul>
<p>[wir21] HPC wire. Cambridge Quantum Releases World's First Quantum Natural Language Processing Toolkit and Library. Oct. 13, 2021. URL: <a href="https://www.hpcwire.com/off-the-wire/cambridge-quantum-releases-worlds-first-quantum-natural-language-processing-toolkit/">https://www.hpcwire.com/off-the-wire/cambridge-quantum-releases-worlds-first-quantum-natural-language-processing-toolkit/</a> (visited on 02/24/2022).</p>
<p>[Smi21] Paul Smith-Goodson. "Cambridge Quantum Makes Quantum Natural Language Processing A Reality". In: Forbes (Oct. 13, 2021). URL: <a href="https://www.forbes.com/sites/moorinsights/2021/10/">https://www.forbes.com/sites/moorinsights/2021/10/</a> 13/cambridge-quantum-makes-quantum-natural-language-processing-a-reality/ (visited on 02/24/2022).</p><h2></h2>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_30.jpg?x=1310&#x26;y=690&#x26;w=135&#x26;h=212&#x26;r=0">
<!-- Media -->
<p>DisCoPy: Python for the applied category theorist</p>
<p>Python has become the programming language of choice for most applications in both natural language processing (e.g. Stanford NLP [Man+14], NLTK [LB02] and SpaCy [HM17]) and quantum computing (with development kits like Qiskit [Cro18] and PennyLane [Ber+20] and interfaces to compilers like pytket [Siv+20]). Thus, it was the obvious choice of language for an implementation of QNLP. However, unlike functional programming languages like Haskell, Python has little support for category theory. Indeed, before the release of DisCoPy, the only existing Python framework for category theory was a module of SymPy [Meu+17] that can draw commutative diagrams in finite categories. Hence, the first step in implementing QNLP was to develop our own framework for applied category theory in Python: DisCoPy. Its main feature are the drawing of string diagrams (e.g. the grammatical structure of sentences) and the application of functors (e.g. to quantum circuits, either executed on quantum hardware or classically simulated).</p>
<p>String diagrams have become the lingua franca of applied category theory. However, the definitions one can find in the literature usually fall into one of two extremes: either definitions by general abstract nonsense or definitions by example and appeal to intuition. On one side of the spectrum, the standard technical reference has become the Geometry of tensor calculus [JS91] where Joyal and Street define string diagrams as equivalence classes of labeled topological graphs embedded in the plane and then characterise them as the arrows of free monoidal categories. On the other, Picturing quantum processes [CK17] contains over a thousand string diagrams but their formal definition as well as any mention of category theory are relegated to mere appendices.</p>
<!-- Meanless: 31--><!-- Meanless: 32 1. DisCoPy: Python for the applied category theorist-->
<p>The aims of this chapter are three-fold: 1) it gives an overview of the DisCoPy package and its design principles, 2) it introduces elementary category theory to the Python programmer and 3) it introduces object-oriented programming to the applied category theorist. The first section introduces categories and functors with no mathematical prerequisites apart from sets and monoids. The second section introduces monoidal categories, defining string diagrams from first principles. The third section defines the drawing and reading algorithms for string diagrams, which arise as the two sides of the equivalence between the premonoidal and the topological definitions. The fourth section introduces monoidal categories with extra structure and the inheritence mechanism which implements this hierarchy of structure. The fifth section gives the category theoretic foundations for our definition of diagrams, which we call the premonoidal approach, it discusses the relationship between this approach and the exisiting graph-based data structures for diagrams in symmetric monoidal categories.</p>
<p>Too long; didn't read. We provide a brief summary for the reader who wishes to skip the category theory of this chapter and go straight to the QNLP of chapter 2 . String diagrams are defined with respect to a monoidal signature \(\sum\) : a set of objects \({\sum }_{0}\) ,a set of boxes \({\sum }_{1}\) and a pair of functions dom,cod : \({\sum }_{1} \rightarrow  {\sum }_{0}^{ \star  }\) assigning input and output types (i.e. lists of objects) to each box. A layer is a triple \(\left( {u,f,v}\right)  \in  L\left( \sum \right)  =\) \({\sum }_{0}^{ \star  } \times  {\sum }_{1} \times  {\sum }_{0}^{ \star  }\) of a box \(f \in  {\sum }_{1}\) with types \(u \in  {\sum }_{0}^{ \star  }\) on the left and \(v \in  {\sum }_{0}^{ \star  }\) on the right, where we define \(\operatorname{dom}\left( {x,f,y}\right)  = x\operatorname{dom}\left( f\right) y\) and \(\operatorname{cod}\left( {x,f,y}\right)  = x\operatorname{cod}\left( f\right) y\) . Finally,a diagram \(d\) is given by a domain \(\operatorname{dom}\left( d\right)  \in  {\sum }_{0}^{ \star  }\) and a list of layers \({d}_{1},\ldots ,{d}_{n} \in  L\left( \sum \right)\) such that \(\operatorname{dom}\left( {d}_{1}\right)  = \operatorname{dom}\left( d\right)\) and \(\operatorname{dom}\left( {d}_{i + 1}\right)  = \operatorname{cod}\left( {d}_{i}\right)\) for \(i \leq  n\) .</p>
<p>Given a type \(x \in  {\sum }_{0}^{ \star  }\) ,we define the identity diagram id(x)with \(\operatorname{dom}\left( {\operatorname{id}\left( x\right) }\right)  = x\) and an empty list of layers. Given two diagrams \(d\) and \({d}^{\prime }\) with \(\operatorname{cod}\left( d\right)  = \operatorname{dom}\left( {d}^{\prime }\right)\) , we define their composition \(d§{d}^{\prime }\) by concatenating of their layers. Given a diagram \(d\) and a type \(x \in  {\sum }_{0}^{ \star  }\) ,we define the left and right whiskering \(x \otimes  d\) and \(d \otimes  x\) by concatenating \(x\) to the left and right of each layer in \(d\) . Every diagram can be written in terms of boxes,identity,composition and whiskering. Given two diagrams \(d\) and \({d}^{\prime }\) ,we can define their tensor as \(d \otimes  {d}^{\prime } = d \otimes  \operatorname{dom}\left( {d}^{\prime }\right)\) ; \(\operatorname{cod}\left( d\right)  \otimes  {d}^{\prime }\) . The interchanger relation induced by \(d \otimes  \operatorname{dom}\left( {d}^{\prime }\right)\) , \(\operatorname{cod}\left( d\right)  \otimes  {d}^{\prime } \sim  \operatorname{dom}\left( d\right)  \otimes  {d}^{\prime }\) , \(d \otimes  \operatorname{cod}\left( {d}^{\prime }\right)\) relates this biased definition of tensor to the one in the opposite direction.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 33-->
<p>A monoidal category \({}^{1}\) is a monoidal signature \(C\) together with an identity function id : \({C}_{0} \rightarrow  {C}_{1}\) ,a (partial) composition function then : \({C}_{1} \times  {C}_{1} \rightarrow  {C}_{1}\) and a tensor function tensor : \({C}_{1} \times  {C}_{1} \rightarrow  {C}_{1}\) subject to some axioms spelled out in section 1.2. Diagrams up to interchanger are the free monoidal category \({C}_{\sum }\) generated by the signature \(\sum\) (see section 1.2.2). In practice,this means that we can define a monoidal functor \(F : {C}_{\sum } \rightarrow  D\) as a signature homorphism \(F : \sum  \rightarrow  D\) , i.e. a pair of functions \({F}_{0} : {\sum }_{0} \rightarrow  {D}_{0}\) and \({F}_{1} : {\sum }_{1} \rightarrow  {D}_{1}\) compatible with dom and cod. Intuitively, once we have specified the interpretation of each object and each box,the interpretation of every diagram is fixed. If we take \(\sum\) to encode the rules of our grammar and \(D\) to be a monoidal category of quantum circuits,we get our definition of QNLP models: they are monoidal functors \(F : {C}_{\sum } \rightarrow  D\) .</p>
<h3>1.1 Categories in Python</h3>
<p>What are categories and how can they be useful to the Python programmer? This section will answer this question by taking the standard mathematical definitions and breaking them into data, which can be translated into Python code, and axioms, which cannot be formally verified in Python, but can be translated into test cases. The data for a category is given by a tuple \(C = \left( {{C}_{0},{C}_{1}}\right.\) ,dom,cod,id,then) where:</p>
<ul>
<li>
<p>\({C}_{0}\) and \({C}_{1}\) are classes of objects and arrows respectively,</p>
</li>
<li>
<p>dom, \(\operatorname{cod} : {C}_{1} \rightarrow  {C}_{0}\) are functions called domain and codomain,</p>
</li>
<li>
<p>id : \({C}_{0} \rightarrow  {C}_{1}\) is a function called identity,</p>
</li>
<li>
<p>then \(: {C}_{1} \times  {C}_{1} \rightarrow  {C}_{1}\) is a partial function called composition,denoted by \(\left( \begin{array}{l} \square \\  \square  \end{array}\right)\) .</p>
</li>
</ul>
<p>Given two objects \(x,y \in  {C}_{0}\) ,the set \({}^{2}C\left( {x,y}\right)  = \left\{  {f \in  {C}_{1} \mid  \operatorname{dom}\left( f\right) ,\operatorname{cod}\left( f\right)  = x,y}\right\}\) is called a homset and we write \(f : x \rightarrow  y\) whenever \(f \in  C\left( {x,y}\right)\) . We denote the composition then(f,g)by \(f。g\) ,translated to \(\mathrm{f} \gg  \mathrm{g}\) or \(\mathrm{g} \ll  \mathrm{f}\) in Python. The axioms for the category \(C\) are the following:</p>
<ul>
<li>
<p>id \(\left( x\right)  : x \rightarrow  x\) for all objects \(x \in  {C}_{0}\) ,</p>
</li>
<li>
<p>for all arrows \(f,g \in  {C}_{1}\) ,the composition \(f。g\) is defined iff \(\operatorname{cod}\left( f\right)  = \operatorname{dom}\left( g\right)\) , moreover we have \(f \circ  g : \operatorname{dom}\left( f\right)  \rightarrow  \operatorname{cod}\left( g\right)\) ,</p>
</li>
</ul>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) What we call a monoidal category technically is a coloured \({PRO}\) ,see remark 1.2.13.</p>
<p>\({}^{2}\) We assume this is a set rather than a proper class,i.e. we work with locally small categories.</p>
<!-- Footnote -->
<hr><!-- Meanless: 34 1.1. Categories in Python-->
<ul>
<li>
<p>id \(\left( {\operatorname{dom}\left( f\right) }\right) 。f = f = f。\mathrm{{id}}\left( {\operatorname{cod}\left( f\right) }\right)\) for all arrows \(f \in  {C}_{1}\) ,</p>
</li>
<li>
<p>\(f\overset{ \circ  }{ \circ  }\left( {g\overset{ \circ  }{ \circ  }h}\right)  = \left( {f\overset{ \circ  }{ \circ  }g}\right) \overset{ \circ  }{ \circ  }h\) whenever either side is defined for \(f,g,h \in  {C}_{1}\) .</p>
</li>
</ul>
<p>Note that we play with the overloaded meaning of the word class: we use it to mean both a mathematical collection that need not be a set, and a Python class with its methods and attributes. Reading it in the latter sense, dom and cod are attributes of the arrow class, then is a method, id is a static method. Thus, the Python implementation of a category is nothing but a pair of classes \(0\mathrm{\;b}\) and Arrow for objects and arrows, together with four methods dom, cod, then and id . The Category class is nothing but a named tuple with two attributes ob and ar for its object and arrow class respectively. The axioms can be implemented as (necessarily non-exhaustive) software tests, however Python has no formal semantics so there is no hope to formally verify them.</p>
<p>The data for a functor \(F : C \rightarrow  D\) between two categories \(C\) and \(D\) is given by a pair of overloaded functions \(F : {C}_{0} \rightarrow  {D}_{0}\) and \(F : {C}_{1} \rightarrow  {D}_{1}\) such that:</p>
<ul>
<li>
<p>\(F\left( {\operatorname{dom}\left( f\right) }\right)  = \operatorname{dom}\left( {F\left( f\right) }\right)\) and \(F\left( {\operatorname{cod}\left( f\right) }\right)  = \operatorname{cod}\left( {F\left( f\right) }\right)\) for all \(f \in  {C}_{1}\) ,</p>
</li>
<li>
<p>\(F\left( {\operatorname{id}\left( x\right) }\right)  = \operatorname{id}\left( {F\left( x\right) }\right)\) and \(F\left( {f,g}\right)  = F\left( f\right) ,F\left( g\right)\) for all \(x \in  {C}_{0}\) and \(f,g \in  {C}_{1}\) .</p>
</li>
</ul>
<p>Thus, implementing a functor in Python amounts to implementing a class with the magic method _____ call_____ of the appropriate type, and then implementing software tests to check that the axioms hold.</p>
<p>The data for a transformation \(\alpha  : F \rightarrow  G\) between two parallel functors \(F,G : C \rightarrow  D\) is given by a function from objects \(x \in  {C}_{0}\) to components \(\alpha \left( x\right)\) : \(F\left( x\right)  \rightarrow  G\left( x\right)\) in \(D\) . A natural transformation is one where \(\alpha \left( x\right) {}_{9}G\left( f\right)  = F\left( f\right) {}_{9}\alpha \left( y\right)\) for all arrows \(f : x \rightarrow  y\) in \(C\) . Again,implementing a transformation amounts to implementing a class with a _____ call _____ method of the appropriate type, checking that a transformation is natural cannot be done formally in Python. The class templates listed below summarise the required data for categories, functors and transformations.</p>
<!-- Media -->
<p>Listing 1.1.1. Class templates for categories, functors and transformations.</p>
<hr>
<pre><code>from _future_ import annotations
from dataclasses import dataclass
</code></pre>
<p>from typing import overload</p>
<hr>
<!-- Media -->
<!-- Meanless: class Ob: ...--><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 35-->
<hr>
<p>class Arrow:
dom: 0b
cod: Ob
@staticmethod
def id(x: 0b) -> Arrow: ...
def then(self, other: Arrow) -> Arrow: ...
@dataclass
class Category:
ob: type = 0b
ar: type = Arrow
class Functor:
dom: Category
cod: Category
@overload
def _ call _ ( self , x : 0b ) -> 0b : ...
@overload
def <em>call</em>_(self, f: Arrow) -> Arrow: ...
class Transformation:
dom: Functor
cod: Functor
def <em>call</em>_(self, x: 0b) -> Arrow: ...</p>
<hr>
<p>Remark 1.1.2. Throughout the thesis we use the postponed evaluation of annotations introduced in Python 3.7 [Lan17]. Python cannot statically check that arrow composition is well-typed as this would require some form of dependent types, the best we can do is raise an AssertionError at runtime.</p>
<p>Example 1.1.3. When the class of objects and arrows are in fact sets, \(C\) is called a small category. For example, the category FinSet has the set of all finite sets as objects and the set of all functions between them as arrows. This time equality of functions between finite sets is decidable, so we can write unit tests that check that the axioms hold on specific examples.</p>
<p>Example 1.1.4. When the class of objects and arrows are finite sets, we can draw the category as a directed multigraph with objects as nodes and arrows as edges, together with the list of equations between paths. A functor \(F : C \rightarrow  D\) from such a finite category \(C\) is called a commutative diagram in \(D\) . One commutative diagram can state a large number of equations, which can be read by diagram chasing.</p><!-- Meanless: 36 1.1. Categories in Python-->
<p>Example 1.1.5. A monoid is the same as a category with one object, i.e. every arrow (element) can be composed with (multiplied by) every other. A preorder, i.e. a set with a reflexive transitive relation, is the same as a category with at most one arrow \(x \leq  y\) between any two objects \(x\) and \(y\) . Functors between monoids are the same as homomorphisms, functors between preorders are monotone functions.</p>
<p>Example 1.1.6. Just about any class of mathematical structures will be the objects of a category with the transformations between them as arrows: the category Set of sets and functions, the category Mon of monoids and homomorphisms, the category Preord of preorders and monotone functions, the category Cat of small categories and functors, etc. There are embedding (i.e. injective on objects and arrows) functors from Mon and Preord to Cat, i.e. preorders and monoids form a subcategory of Cat. There is a functor from Cat to Preord called the preorder collapse which sends a category \(C\) to the preorder given by \(x \leq  y\) iff there is an arrow \(f \in  C\left( {x,y}\right)\) ,i.e. we forget the difference between parallel arrows. There is a faithful (i.e. injective on homsets) functor \(U :\) Mon \(\rightarrow\) Set called the forgetful functor which sends monoids to their underlying set and homomorphisms to functions.</p>
<p>Example 1.1.7. In the same way that there is a set \({Y}^{X}\) of functions \(X \rightarrow  Y\) for any two sets \(X\) and \(Y\) ,for any two categories \(C\) and \(D\) there is a category \({D}^{C}\) with functors \(C \rightarrow  D\) as objects and natural transformations as arrows.</p>
<p>Example 1.1.8. We can define the category Pyth with objects the class of all Python types and arrows the class of all Python functions. Domain and codomain could be extracted from type annotations, but instead we implement a class Function with attributes inside: Callable as well as dom: Ty and cod: Ty. Identity and composition is given by lambda x: x and lambda f, g: lambda x: g(f(x)) ).</p>
<p>As discussed by Milewski [Mil14] in the case of Haskell,endofunctors Pyth \(\rightarrow\) Pyth can be thought of as data containers. For example, we can define a List functor which sends a type \(\mathrm{t}\) to List[t] and a function \(\mathrm{f}\) to lambda *xs: map( \(\mathrm{f}\) ,xs). There is a natural transformation \(\eta  : \mathbf{{Id}} \rightarrow  \mathbf{{List}}\) from the obvious identity functor, implemented by the built-in function id. Its components send objects \(\mathrm{x}\) : \(\mathrm{t}\) of any type \(\mathrm{t}\) to the singleton list \(\left\lbrack  \mathrm{x}\right\rbrack\) : List \(\left\lbrack  \mathrm{t}\right\rbrack\) .</p>
<p>Remark 1.1.9. It's not entirely clear what we mean by equality of Python function and hence we can ask whether Pyth even is a category at all. We can define a notion of contextual equivalence, an instance of Leibniz's identity of indiscernibles: two functions are equal if they are interchangeable in all observable contexts. However, the associativity and unitality axioms may fail in the presence of non-terminating programs. In the same informal way as in "platonic" Hask [con12], we may think of a "platonic" Pyth, a subset of Python functions where we exclude non-termination and where the axioms of categories hold. See Danielsson et al. Fast and loose reasoning is morally correct [Dan+06] for a theoretical justification of such informal reasoning.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 37-->
<p>Listing 1.1.10. Syntactic sugar for composition.</p>
<p>Composable implements the syntactic sugar \(>  >\) and \(&#x3C;  &#x3C;\) for composition in diagrammatic order and its opposite,as well as \(\mathrm{n} *\) self for \(\mathrm{n}\) -fold composition. It is an abstract class, i.e. it is subclassed but never instantiated. The higher-order function inductive takes a binary method and makes it n-ary by using a left fold, we use it as a decorator.</p>
<hr>
<p>class Composable:
<em><strong><strong>rshift</strong></strong></em> = <em>llshift</em> = lambda self, other: self.then(other)
<em><strong><strong>lshift</strong></strong></em> = <em><strong><strong>lrshift</strong></strong></em> = lambda self, other: other.then(self)
def inductive (method) :
def result(self, *others):
if not others: return self
if len(others) == 1: return method(self, others[0])
if len(others) > 1: return result(method(self, others[0]), *others[1:])
return result</p>
<hr>
<p>Listing 1.1.11. Implementation of the category Pyth with type as objects and Function as arrows.</p>
<hr>
<p>from typing import Callable
@dataclass
class Function (Composable) :
inside: Callable
dom: type
cod: type
@staticmethod
def id(dom: type) -> Function:
return Function (lambda x: x, dom, dom)</p><!-- Meanless: 38 1.1. Categories in Python-->
<p>@inductive
def then(self, other: Function) -> Function:
assert self.cod == other.dom
return Function (lambda xs: other (self(xs)), self.dom, other.cod)
def <strong>call</strong>(self, x) :
return self.inside(x)</p>
<hr>
<p>Example 1.1.12. The following commutative diagram denotes a functor \(3 \rightarrow\) Pyth from the finite category 3 with three objects \(\{ 0,1,2\}\) and three non-identity arrows \(f : 0 \rightarrow  1,g : 1 \rightarrow  2\) and \(h : 0 \rightarrow  2\) ,with the only non-trivial composition \(f。g = h\) .</p>
<!-- Media -->
<!-- figureText: int lambda n: n * (n - 1) // 2 int sum Iterable range -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_37.jpg?x=387&#x26;y=825&#x26;w=795&#x26;h=173&#x26;r=0">
<!-- Media -->
<p>It is read as the equation \(\operatorname{sum}\left( {\operatorname{range}\left( \mathrm{n}\right) }\right)  = \mathrm{n} * \left( {\mathrm{n} - 1}\right) //2\) .</p>
<p>Example 1.1.13. The category \({\mathbf{{Mat}}}_{\mathbb{S}}\) has natural numbers as objects and \(n \times  m\) matrices with values in \(\mathbb{S}\) as arrows \(n \rightarrow  m\) . The identity and composition are given by the identity matrix and matrix multiplication respectively. In order for matrix multiplication to be well-defined and for \({\mathbf{{Mat}}}_{\mathbb{S}}\) to be a category,the scalars \(\mathbb{S}\) should have at least the structure of a rig (a riNg without Negatives, also called a semiring): a pair of monoids \(\left( {\mathbb{S},+,0}\right)\) and \(\left( {\mathbb{S},\times ,1}\right)\) with the first one commutative and the second a homomorphism for the first,i.e. \(a \times  0 = 0 = 0 \times  a\) and \(\left( {a + b}\right)  \times  \left( {c + d}\right)  =\) \({ac} + {ad} + {bc} + {bd}\) .</p>
<p>The category \({\mathbf{{Mat}}}_{\mathbb{C}}\) is equivalent to the category of finite dimensional vector spaces and linear maps. When the scalars are Booleans with disjunction and conjunction as addition and multiplication,the category \({\mathbf{{Mat}}}_{\mathbb{B}}\) is equivalent to the category of finite sets and relations. There is a faithful functor \(\mathbf{{FinSet}} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{B}}\) which sends finite sets to their cardinality and functions to their graph.</p>
<p>Listing 1.1.14. Implementation of \({\mathbf{{Mat}}}_{\mathbb{S}}\) with int as objects and Matrix [dtype] as arrows.</p>
<hr>
<p>from typing import Number
class Matrix ( Composable ) :
dtype = int
dom: int</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 39-->
<pre><code>cod: int
inside: list [list [dtype]]
def __class_getitem__(cls, dtype: type):
	class C(cls): pass
	C. dtype = dtype
	C. _____name_____ = C._____qualname_____ = "\{\}[\{\}]".format(   )
		cls.__name__, dtype.__name__)
	return C
def _____init_____(self, inside: list[list[Number]], dom: int, cod: int):
	assert len (inside) == dom and all (len(row) == cod for row in inside)
	self.inside, self.dom, self.cod =\\
		[list(map(self.dtype, row)) for row in inside], dom, cod
def _____eq_____ (self, other):
	if not isinstance(other, Matrix):
		return self.dom == self.cod == 1 and self.inside[0][0] == other
	return ( self.dtype, self.inside, self.dom, self.cod )\\\\
		\( =  = \) (other.dtype,other.inside,other.com,other.cod)
@classmethod
def id(cls, x: int) -> Matrix:
	return cls ([[i == j for i in range(x)] for j in range(x)], x, x)
@inductive
def then(self, other: Matrix) -> Matrix:
	assert self.dtype == other.dtype and self.cod == other.dom
	inside = [[sum(   )
		self.inside[i][j] * other.inside[j][k] for j in range(other.dom))
		for k in range(other.cod)] for i in range(self.dom)]
	return type ( self ) ( inside, self.dom, other.cod )
def __getitem_(self, key: int | tuple[int, ...]) -> Matrix:
	key = key if isinstance(key, tuple) else (key, )
	inside = [[self.inside[i][j] for i in key for j in range(self.cod)]]\\
		if len(key) == 1 else [[self.inside[i][j] for i, j in [key]]]
	dom, cod = 1, self.cod if len (key) == 1 else 1
	return type ( self ) ( inside, dom, cod )
</code></pre>
<p>for converter in (bool, int, float, complex):
def method(self): # Downcasting a 1 by 1 Matrix to a scalar.
assert self.dom == self.cod == 1
return converter(self.inside[0][0])</p><!-- Meanless: 40 1.1. Categories in Python-->
<p>setattr(Matrix, "<em><strong><strong>{}</strong></strong></em>".format(converter.<em>name</em>_), method)</p>
<hr>
<p>Subscriptable types such as list [list[int]] implemented by the magic method ____<em>class_getitem</em> are a new feature of Python 3.10 [Lev17]. By default, we fix Matrix = Matrix[int]. We can get Boolean, real and complex matrices with Matrix[bool], Matrix[float] and Matrix[complex] respectively. Note that this implementation is not meant to be efficient, rather it helps in making the thesis self-contained. As we will mention in section 1.5.2, DisCoPy interfaces with NumPy [vdWCV11] for efficient matrix multiplication.</p>
<p>Example 1.1.15. The category Circ has natural numbers as objects and n-qubit quantum circuits as arrows \(n \rightarrow  n\) . There is a functor eval : \(\mathbf{{Circ}} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) which sends \(n\) qubits to \({2}^{n}\) dimensions and evaluates each circuit to its unitary matrix.</p>
<h4>1.1.1 Free categories</h4>
<p>The main principles behind the implementation of DisCoPy follow from the concept of a free object. Let’s start from a simple example. Given a set \(X\) ,we can construct a monoid \({X}^{ \star  }\) with underlying set \(\mathop{\coprod }\limits_{{n \in  \mathbb{N}}}{X}^{n}\) the set of all finite lists with elements in \(X\) . The associative multiplication is given by list concatenation \({X}^{m} \times  {X}^{n} \rightarrow  {X}^{m + n}\) and the unit is given by the empty list denoted \(1 \in  {X}^{0}\) . Given a function \(f : X \rightarrow  Y\) ,we can construct a homomorphism \({f}^{ \star  } : {X}^{ \star  } \rightarrow  {Y}^{ \star  }\) defined by element-wise application of \(f\) (this is what the built-in map does in Python). We can easily check that \({\left( f{}_{\vartheta }g\right) }^{ \star  } = {f}^{ \star  }{}_{\vartheta }{g}^{ \star  }\) and \({\left( {\operatorname{id}}_{X}\right) }^{ \star  } = {\operatorname{id}}_{{X}^{ \star  }}\) . Thus,we have defined a functor \(F :\) Set \(\rightarrow\) Mon.</p>
<p>Why is this functor so special? Because it is the left adjoint to the forgetful functor \(U :\) Mon \(\rightarrow\) Set. An adjunction \(F \dashv  U\) between two functors \(F : C \rightarrow  D\) and \(U : D \rightarrow  C\) is a pair of natural transformations \(\eta  : {\operatorname{id}}_{C} \rightarrow  F。U\) and \(\epsilon  : U{}_{9}F \rightarrow  {\operatorname{id}}_{D}\) called the unit and counit respectively. In the case of lists,we already mentioned the unit in example 1.1.8: it is the function that sends every object to a singleton list. For a monoid \(M\) ,the counit \(\epsilon \left( M\right)  : F\left( {U\left( M\right) }\right)  \rightarrow  M\) is the monoid homomorphism that takes lists of elements in \(M\) and multiplies them. We can easily check that these two transformations are indeed natural, thus we get that lists are free monoids. This may be taken as a mathematical explanation for why lists are so ubiquitous in programming. Another equivalent definition of adjunction is in terms of an isomorphism \(C\left( {x,U\left( y\right) }\right)  \simeq  D\left( {F\left( x\right) ,y}\right)\) which is natural \({}^{1}\) in \(x \in  {C}_{0}\) and \(y \in  {D}_{0}\) . In the adjunction for lists,functions \(X \rightarrow  U\left( M\right)\) from a set \(X\) to the underlying set of a monoid \(M\) are in a natural one-to-one correspondence with monoid homomorphisms \({X}^{ \star  } \rightarrow  M\) . To define a homomorphism from a free monoid, it is sufficient to define the image of each generating element.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) The isomorphism \(C\left( {x,U\left( y\right) }\right)  \simeq  D\left( {F\left( x\right) ,y}\right)\) is natural in \(x\) if it is a natural transformation between the two functors \(C\left( {-,U\left( y\right) }\right) ,D\left( {F\left( -\right) ,y}\right)  : C \rightarrow\) Set.</p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 41-->
<p>Now we want to play the same game with categories instead of monoids. We can define a forgetful functor \(U : \mathbf{{Cat}} \rightarrow  \mathbf{{Set}}\) which sends a small category \(C\) to its set of objects \({C}_{0}\) ,and its left adjoint \(F :\) Set \(\rightarrow\) Cat which sends a set to the discrete category with its elements as objects and only identity arrows. However, this is a rather boring construction because forgetting the arrows of a categories is too much: the forgetful functor \(U\) is not faithful. Instead,we need to replace the category of sets with the category of signatures. The data for a signature is given by a tuple \(\sum  = \left( {{\sum }_{0},{\sum }_{1},\text{dom,cod}}\right)\) where:</p>
<ul>
<li>
<p>\({\sum }_{0}\) is a set of generating objects,</p>
</li>
<li>
<p>\({\sum }_{1}\) is a set of generating arrows,which we will also call boxes,</p>
</li>
<li>
<p>dom, \(\operatorname{cod} : {\sum }_{1} \rightarrow  {\sum }_{0}\) are the domain and codomain.</p>
</li>
</ul>
<p>A morphism of signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) is a pair of overloaded functions \(f : {\sum }_{0} \rightarrow  {\sum }_{0}^{\prime }\) and \(f : {\sum }_{1} \rightarrow  {\sum }_{1}^{\prime }\) such that \(f\underset{9}{ \circ  }\operatorname{dom} = {\operatorname{dom}}_{9}^{ \circ  }f\) and \({f}_{9}^{ \circ  }\operatorname{cod} = {\operatorname{cod}}_{9}^{ \circ  }f\) . Thus, signatures and their morphisms form a category Sig and there is a faithful functor \(U : \mathbf{{Cat}} \rightarrow\) Sig which sends a category to its underlying signature: it forgets the identity and composition. Signatures may be thought of as directed multigraphs with an attitude [nLa]. Given a signature \(\sum\) ,we can define a category \(F\left( \sum \right)\) with nodes as objects and paths as arrows. More precisely,an arrow \(f : x \rightarrow  y\) is given by a length \(n \in  \mathbb{N}\) and a list \({f}_{1},\ldots ,{f}_{n} \in  {\sum }_{1}\) with \(\operatorname{dom}\left( {f}_{1}\right)  = x,\operatorname{cod}\left( {f}_{n}\right)  = y\) and \(\operatorname{cod}\left( {f}_{i}\right)  = \operatorname{dom}\left( {f}_{i + 1}\right)\) for all \(i &#x3C; n\) . Given a morphism of signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) ,we get a functor \(F\left( f\right)  : F\left( \sum \right)  \rightarrow  F\left( {\sum }^{\prime }\right)\) relabeling boxes in \(\sum\) by boxes in \({\sum }^{\prime }\) . Thus, we have defined a functor \(F :\) Sig \(\rightarrow\) Cat,it remains to show that it indeed forms an adjunction \(F \dashv  U\) . This is very similar to the monoid case: the unit sends a box in a signature to the path of just itself, the counit sends a path of arrows in a category to their composition. Equivalently, we have a natural isomorphism \(\operatorname{Cat}\left( {F\left( \sum \right) ,C}\right)  \simeq  \operatorname{Sig}\left( {\sum ,U\left( C\right) }\right)\) : to define a functor \(F\left( \sum \right)  \rightarrow  C\) from a free category is the same as to define a morphism of signatures \(\sum  \rightarrow  U\left( C\right)\) .</p>
<p>If lists are such fundamental data structures because they are free monoids, we argue that the arrows of free categories should be just as fundamental: they capture the basic notion of data pipelines. Free categories are implemented in the most basic module of DisCoPy, discopy. cat, which is sketched in listing 1.1.16.</p><!-- Meanless: 42 1.1. Categories in Python-->
<p>Listing 1.1.16. Implementation of the free category \(F\left( \sum \right)\) with \({\sum }_{0} = 0\mathrm{\;b}\) and</p>
<p>\({\sum }_{1} =\) Box.</p>
<hr>
<p>@dataclass
class Ob:
name: str
___<strong>str</strong> = lambda self: self.name
@dataclass
class Arrow (Composable) :
inside: tuple [Box, ...]
dom: 0b
cod: 0b
@classmethod
def cast(cls, old: Arrow) -> Arrow:
return old if isinstance(old, cls) else cls(old.inside, old.dom, old.cod)
@classmethod
def id(cls, x: 0b) -> Arrow:
return cls.cast(Arrow((   ), x, x))
def then(self, *others: Arrow) -> Arrow:
for \(\mathrm{f},\mathrm{g}\) in \(\operatorname{zip}\left( {\text{ (self },\text{ ) } + \text{ others },\text{ others }}\right)\) : assert \(\mathrm{f}.\operatorname{cod} =  = \mathrm{g}\) . dom
dom, cod = self.dom, others[-1].cod if others else self.cod
inside = self.inside + sum([other.inside for other in others], (   ))
return self.cast(Arrow(inside, dom, cod))
___<em><em>len</em> = lambda self: len(self.inside)
<em><strong><strong>str</strong></strong></em> = lambda self: ' >> '.join(map(str, self.inside))\
if self.inside else ' \(\{ \}\) .id({})'.format(type(self).<em>name</em></em>, self.dom)
class Box (Arrow) :
def <strong>init</strong>(self, name: str, dom: 0b, cod: 0b):
self.name = name
super(   ).<strong>init</strong>((self, ), dom, cod)
def <em><strong><strong>eq</strong></strong></em> (self, other):
if isinstance(other, Box):
return ( self.name, self.dom, self.cod ) \\
\(=  =\) (other.name,other.dom,other.cod)
return isinstance(other, Arrow) and other.inside == (self, )
<em><strong><strong>hash</strong></strong></em> = lambda self: hash(repr(self))
___<strong>str</strong> = lambda self: self.name</p>
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 43-->
<p>cast = Arrow.cast</p>
<p>The classes \(\mathrm{{Ob}}\) and Arrow for objects and arrows are implemented in a straightforward way, using the dataclass decorator to avoid the bureaucracy of defining initialisation, equality, etc. We define the method <em>str</em> so that eval(str(f)) == f for all \(f\) : Arrow,provided that the names of all objects and boxes are in scope. The attribute inside holds the list of generating arrows, which we store as an immutable tuple rather than a mutable list. The method Arrow, then accepts any number of arrows others, which will prove useful when defining functors. The Box class requires more attention: a box \(\mathrm{f} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right)\) is an arrow with the list of just itself as boxes,i.e. f.inside \(=  = \left( {f, - }\right)\) . For the axiom \(f \gg  f\) .id \(\left( y\right)  =  = f\) == f.id(x) >> f to hold,we need to make sure that f == Arrow((f, ), x, y), i.e. a box is equal to the arrow with just itself as boxes. The main subtlety in the implementation is the class method cast which takes an old: Arrow as input and returns a new member of a given cls, subclass of Arrow. This allows the composition of arrows in a subclass to remain within the subclass, without having to rewrite the method then. This means we need to make Arrow. id a classmethod as well so that it can call cast and return an arrow of the appropriate subclass. We also need to fix Box. cast = Arrow.cast: when we compose a box then an arrow, we want to return a new arrow object, not a box.</p>
<p>Example 1.1.17. We can define Circuit as a subclass of Arrow and Gate as a subclass of Circuit and Box defined by a name and a number of qubits.</p>
<hr>
<p>class Circuit (Arrow): pass
class Gate (Box, Circuit) :
cast = Circuit.cast
Id = Circuit.id(Ob('1'))
\(X,Y,Z,H = \left\lbrack  {\text{Gate(name,}\mathrm{{Ob}}\left( {{}^{1}{1}^{\prime }}\right) ,\mathrm{{Ob}}\left( {{}^{1}{1}^{\prime }}\right) }\right\rbrack\) for name in "XYZH"]
assert \(\left( {\mathrm{X} >  > \mathrm{Y}}\right)  >  > \mathrm{Z} =  = \mathrm{X} >  > \left( {\mathrm{Y} >  > \mathrm{Z}}\right)\) and \(\mathrm{X} >  > \mathrm{{Id}} =  = \mathrm{X} =  = \mathrm{{Id}} >  > \mathrm{X}\)
assert isinstance(Id, Circuit) and isinstance(X >> Y, Circuit)</p>
<hr>
<p>The Functor class listed in 1.1.18 has two mappings ob and ar as attributes, from objects to objects and from boxes to arrows respectively. The domain of the functor is implicitly defined as the free category generated by the domain of the ob and ar mappings. The optional arguments dom and cod allow to define functors with arbitrary categories as domain and codomain, a Category is nothing but a pair of types for its objects and arrows. For now we only use cod to define the image of identity arrows, otherwise the (co)domain of the functor is defined implicitly as the (co)domain of the ob and ar mappings.</p><!-- Meanless: 44 1.1. Categories in Python-->
<p>We have chosen to implement functors in terms of Python dict rather than functions mainly because the syntax looked better for small examples. However, nothing prevents us from making the most of Python's duck typing: if it quacks like a dict and if it has a _____ getitem_____ method, we can use it to define functors like a dict. Thus, we can define functors with domains that are not finitely generated, such as the identity functor or more concretely the evaluation functor for quantum gates parameterised by a continuous angle. An equivalent solution is to subclass Functor and override its _____ call_____ method directly. The only downside is that we cannot print, save or check equality for such functors, we can only apply them to objects and arrows.</p>
<p>Listing 1.1.18. Implementation of Cat with Category as objects and Functor as arrows.</p>
<!-- Media -->
<p>class DictOrCallable:</p>
<hr>
<pre><code>def __class_getitem__(_, source, target):
	return dict[source, target] | Callable[[source], target]
</code></pre>
<p>@dataclass
class FakeDict:
inside: Callable
<strong>getitem</strong> = lambda self, key: self.inside(key)
class Functor:
ob: dictOrCallable [Ob, Ob]
ar: dictOrCallable [Box, Ar]
dom: Category = Category (Ob, Arrow)
cod: Category = Category (Ob, Arrow)
def ____<em>init</em>(self, ob, ar, dom=None, cod=None):
dom, cod = dom or type(self).dom, cod or type(self).cod
ob = ob if hasattr(ob, "_<em>getitem</em>") else FakeDict(ob)
ar = ar if hasattr(ar, "<em>getitem</em>") else FakeDict(ar)
self.ob, self.ar, self.dom, self.cod = ob, ar, dom, cod
def <em>call</em>(self, other: Ob | Arrow) -> Ob | Arrow:
if isinstance(other, Ob):
return self.ob[other]</p>
<hr>
<!-- Media --><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 45-->
<hr>
<pre><code>if isinstance(other, Box):
	result = self.ar[other]
	if isinstance(result, self.cod.ar): return result
	#This allows some nice syntactic sugar for the ar mapping.
	return self.cod.ar(result, self(other.dom), self(other.cod))
if isinstance(other, Arrow):
	base_case = self.cod.ar.id(self(other.dom))
	return base_case.then(*[self(box) for box in other.inside])
raise TypeError
</code></pre>
<p>@classmethod
def id(cls, x: Category) -> Functor:
return cls(lambda obj: obj, lambda box: box, dom=x, cod=x)
@inductive
def then(self: Functor, other: Functor) -> Functor:
assert self.cod == other.dom
ob, ar = lambda x: other.ob[self.ob[x]], lambda f: other.ar[self.ar[f]]
return type ( self ) ( ob , ar , self.dom, other. cod )</p>
<hr>
<p>Example 1.1.19. A typical DisCoPy script starts by defining objects and boxes:</p>
<hr>
<p>\(\mathrm{x},\mathrm{y},\mathrm{z} = \operatorname{map}\left( {0\mathrm{\;b},\text{"xyz"}}\right)\)
f, g, h = Box ('f', x, y), Box ('g', y, z), Box ('h', z, x)</p>
<hr>
<p>We can define a simple relabeling functor from the free category to itself:</p>
<hr>
<p>F = Functor(   )
ob={x: y, y: z, z: x},
ar={f: g, g: h, h: f})
assert \(\mathrm{F}\left( {\mathrm{f} >  > \mathrm{g} >  > \mathrm{h}}\right)  =  = \mathrm{F}\left( \mathrm{f}\right)  >  > \mathrm{F}\left( \mathrm{g}\right)  >  > \mathrm{F}\left( \mathrm{h}\right)  =  = \mathrm{g} >  > \mathrm{h} >  > \mathrm{f}\)</p>
<hr>
<p>We can interpret our arrows as Python functions:</p>
<hr>
<p>G = Functor(   )
ob={x: int, y: Iterable, z: int},
ar={f: range, g: sum, h: lambda n: n * (n - 1) // 2},
cod=Category (type, Function))
assert \(\mathrm{G}\left( {\mathrm{f} > \mathrm{g}}\right) \left( {42}\right)  =  = \mathrm{G}\left( \mathrm{h}\right) \left( {42}\right)  =  = {861}\)</p>
<hr>
<p>We can interpret our arrows as matrices:</p>
<hr>
<p>H = Functor(   )
ob={x: 1,y: 2,z: 2},
\(\mathrm{{ar}} = \{ \mathrm{f} : \left\lbrack  \left\lbrack  {0,1}\right\rbrack  \right\rbrack  ,\mathrm{g} : \left\lbrack  {\left\lbrack  {0,1}\right\rbrack  ,\left\lbrack  {1,0}\right\rbrack  }\right\rbrack  ,\mathrm{h} : \left\lbrack  {\left\lbrack  1\right\rbrack  ,\left\lbrack  0\right\rbrack  }\right\rbrack  \} ,\)
cod=Category ( int , Matrix ) )
assert \(\mathrm{H}\left( {\mathrm{f} >  > \mathrm{g}}\right)  =  = \mathrm{H}\left( \mathrm{h}\right)\) .transpose(   )</p>
<hr><!-- Meanless: 46 1.1. Categories in Python-->
<!-- Media -->
<p>We can even define functors into \(\mathbf{{Cat}}\) ,i.e. interpret arrows as functors:</p>
<hr>
<p>I = Functor(   )
ob={x: Category(Ob, Arrow), y: Category(Ob, Arrow), z: Category(int, Matrix)},
ar={f: F, g: H},
cod=Category (Category, Functor))
assert \(\mathrm{I}\left( {\mathrm{f} > \mathrm{g}}\right) \left( \mathrm{h}\right)  =  = \mathrm{H}\left( {\mathrm{F}\left( \mathrm{h}\right) }\right)  =  = \mathrm{H}\left( \mathrm{f}\right)\)</p>
<hr>
<!-- Media -->
<h4>1.1.2 Quotient categories</h4>
<p>After free objects, another concept behind DisCoPy is that of a quotient object. Again,let’s start with the example of a monoid \(M\) . Suppose we’re given a binary relation \(R \subseteq  M \times  M\) ,then we can construct a quotient monoid \(M/R\) with underlying set the equivalence classes of the smallest congruence generated by \(R\) . That is, the smallest relation \(\left( { \sim  }_{R}\right)  \subseteq  M \times  M\) such that:</p>
<ul>
<li>
<p>\(x{ \sim  }_{R}y\) for all \(\left( {x,y}\right)  \in  R\) ,</p>
</li>
<li>
<p>\(x{ \sim  }_{R}x\) and if \(x{ \sim  }_{R}y\) and \(y{ \sim  }_{R}z\) then \(x{ \sim  }_{R}z\) ,</p>
</li>
<li>
<p>if \(x{ \sim  }_{R}{x}^{\prime }\) and \(y{ \sim  }_{R}{y}^{\prime }\) then \(x \times  y{ \sim  }_{R}{x}^{\prime } \times  {y}^{\prime }\) .</p>
</li>
</ul>
<p>The first point says that \(R \subseteq  \left( { \sim  }_{R}\right)\) . The second says that \(\left( { \sim  }_{R}\right)\) is an equivalence relation. The third says that \(\left( { \sim  }_{R}\right)\) is closed under products,it is equivalent to the substitution axiom: if \(x{ \sim  }_{R}y\) then \({axb}{ \sim  }_{R}{ayb}\) for all \(a,b \in  M\) . Explicitly,the congruence \(\left( { \sim  }_{R}\right)\) can be constructed in two steps: first,we define the rewriting relation \(\left( { \rightarrow  }_{R}\right)  \subseteq  M \times  M\) where \({axb}{ \rightarrow  }_{R}{ayb}\) for all \(\left( {x,y}\right)  \in  R\) and \(a,b \in  M\) . Second, we define \(\left( { \sim  }_{R}\right)\) as the symmetric,reflexive,transitive closure of the rewriting relation,i.e. two elements \(x,y \in  M\) are equal in \(M/R\) iff they are in the same connected component of the undirected graph induced by \(\left( { \rightarrow  }_{R}\right)  \subseteq  M \times  M\) . Now there is a homomorphism \(q : M \rightarrow  M/R\) which sends monoid elements to their equivalence class with the following property: for any homomorphism \(f : M \rightarrow  N\) with \(x{ \sim  }_{R}y\) implies \(f\left( x\right)  = f\left( y\right)\) ,there is a unique \({f}^{\prime } : M/R \rightarrow  N\) with \(f = q。{f}^{\prime }\) . Intuitively,a homomorphism from a quotient \(M/R\) is nothing but a homomorphism from \(M\) which respects the axioms \(R\) . Up to isomorphism,we can construct any monoid \(M\) as the quotient \({X}^{ \star  }/R\) of a free monoid \({X}^{ \star  }\) : take \(X = U\left( M\right)\) and \(R = \left\{  {\left( {{xy},z}\right)  \in  {X}^{ \star  } \times  {X}^{ \star  } \mid  x \times  y = z \in  M}\right\}  .\)</p>
<p>The pair \(\left( {X,R \subseteq  {X}^{ \star  } \times  {X}^{ \star  }}\right)\) of a set of generating elements \(X\) and a binary relation \(R\) on its free monoid is called a presentation of the monoid \(M \simeq  {X}^{ \star  }/R\) . Arguably, the most fundamental computational problem is the word problem for monoids: given a presentation(X,R)and a pair of lists \(x,y \in  {X}^{ \star  }\) ,decide whether \(x = y\) in \({X}^{ \star  }/R\) . As mentioned in the introduction,it was shown to be equivalent to Turing's halting problem, and thus undecidable, by Post [Pos47] and Markov [Mar47]. The proof is straightforward: we can encode the tape alphabet and the states of a Turing machine in the set \(X\) and its transition table into the relation \(R\) ,then whether the machine halts reduces to deciding \(x = y\) for \(x\) and \(y\) the initial and accepting configurations respectively: a proof of equality corresponds precisely to a run of the Turing machine.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 47-->
<p>The case of quotient categories is similar, only we need to take care of objects now. Given a category \(C\) and a family of binary relations \({\left\{  {R}_{x,y} \subseteq  C\left( x,y\right)  \times  C\left( x,y\right) \right\}  }_{x,y \in  {C}_{0}}\) , we can construct a quotient category \(C/R\) with equivalence classes as arrows. There is a functor \(Q : C \rightarrow  C/R\) sending each arrow to its equivalence class,and for any functor \(F : C \rightarrow  D\) with \(\left( {f,g}\right)  \in  {R}_{x,y}\) implies \(F\left( f\right)  = F\left( g\right)\) ,there is a unique \({F}^{\prime } : C/R \rightarrow  D\) with \(F = Q\mathring{} {F}^{\prime }\) . Intuitively,a functor from a quotient category \(C/R\) is nothing but a functor from \(C\) which respects the axioms \(R\) . Again,any small category \(C\) is isomorphic to the quotient \(F\left( \sum \right) /R\) of a free category \(F\left( \sum \right)\) : take \(\sum  = U\left( C\right)\) and \(R = \left\{  {\left( {f。g,h}\right)  \in  F\left( \sum \right)  \times  F\left( \sum \right)  \mid  f。g = h \in  C}\right\}\) . The pair \(\left( {\sum ,R \subseteq  \mathop{\coprod }\limits_{{x,y \in  {\sum }_{0}}}\sum \left( {x,y}\right)  \times  \sum \left( {x,y}\right) }\right)\) is called a presentation of the category \(C \simeq  F\left( \sum \right) /R\) . Since monoids are just categories with one object,the word problem for categories will be just as undecidable as for monoids.</p>
<p>What does it mean to implement a quotient category in Python? Since presentations of categories are as expressive as Turing machines, we might as well avoid solving the halting problem and just use a Python function to define equality of arrows. Implementing a quotient category is nothing but implementing a free category and an equality function that respects the axioms of a congruence. One straightforward way is to define equality of arrows \(f,g\) in a free category \(F\left( \sum \right)\) to be the equality of their interpretation \(\llbracket f\rrbracket  = \llbracket g\rrbracket\) under a functor \(\llbracket  - \rrbracket  : F\left( \sum \right)  \rightarrow  D\) into a concrete category \(D\) where equality is decidable. Another method is to define a normal form method which takes an arrow and returns the representative of its equivalence class, then identity of arrow is identity of their normal forms.</p>
<p>Example 1.1.20. Take the signature \(\sum\) with one object \({\sum }_{0} = \{ 1\}\) and four arrows \({\sum }_{1} = \{ Z,X,H, - 1\}\) for the \(Z,X\) and Hadamard gate and the global(-1)phase. Let’s define the relation \(R\) induced by:</p>
<ul>
<li>
<p>\({H}_{9}^{ \circ  }X = Z{}_{9}^{ \circ  }H\) and \(Z{}_{9}^{ \circ  }X = \left( {-1}\right) {}_{9}^{ \circ  }X{}_{9}^{ \circ  }Z\) ,</p>
</li>
<li>
<p>\(f\) ’ \(\mathring{g}f = \mathrm{{id}}\left( 1\right)\) and \(f\) ’ \(\left( {-1}\right)  = \left( {-1}\right)\) ’ \(f\) for all \(f \in  {\sum }_{1}\) . The quotient \(F\left( \sum \right) /R\) is a subcategory of the category Circ of quantum circuits,it is isomorphic to the quotient induced by the interpretation \(\llbracket  - \rrbracket  : F\left( \sum \right)  \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) . Suppose we’re given a functor \(\operatorname{cost} : F\left( \sum \right)  \rightarrow  {\mathbb{R}}^{ + }\) ,we can define the normal form of a circuit \(f\) to be the representative of its equivalence class with the lowest cost. Thus, deciding equality of circuits reduces to solving circuit optimisation perfectly.</p>
</li>
</ul><!-- Meanless: 48 1.1. Categories in Python-->
<h4>1.1.3 Daggers, sums and bubbles</h4>
<p>We conclude this section by discussing three extra pieces of implementation beyond the basics of category theory: daggers, sums and bubbles. A dagger for a category \(C\) can be thought of as a kind of time-reversal for arrows. More precisely,a dagger is a contravariant endofunctor \(\dagger   : C \rightarrow  {C}^{op}\) ,i.e. from the category to its opposite with dom and cod swapped, which is the identity on objects and an involution, i.e. \(\left( \dagger \right) §\left( \dagger \right)  = {\mathrm{{id}}}_{\mathbb{C}}\) . A \(\dagger\) -functor is a functor between \(\dagger\) -categories that commutes with the dagger,thus we get a category \(\dagger\) - Cat. The free \(\dagger\) -category is constructed as follows. Define the functor \(\dagger   : \mathbf{{Sig}} \rightarrow  \mathbf{{Sig}}\) which sends a signature \(\sum\) to \(\dagger  \left( \sum \right)\) with \(\dagger  {\left( \sum \right) }_{0} = {\sum }_{0}\) and \(\dagger  {\left( \sum \right) }_{1} = \{  - 1,1\}  \times  {\sum }_{1}\) with \(\operatorname{dom}\left( {b,f}\right)  = \operatorname{cod}\left( f\right)\) if \(b =  - 1\) else \(\operatorname{dom}\left( f\right)\) and symmetrically for cod. Then the free dagger category is the quotient category \(F\left( {\dagger \left( \sum \right) }\right) /R\) for the congruence generated by \(\left( {1,f}\right) \diamond \left( {-1,f}\right) { \rightarrow  }_{R}\operatorname{id}\left( {\operatorname{dom}\left( f\right) }\right)\) and \(\left( {-1,f}\right) {}_{9}^{ \circ  }\left( {1,f}\right) { \rightarrow  }_{R}\) id(f.cod).</p>
<p>Example 1.1.21. The conjugate transpose defines a dagger on the category \({\mathbf{{Mat}}}_{\mathbb{C}}\) , the adjoint defines a dagger on the category Circ and the evaluation Circ \(\rightarrow\) \({\mathbf{{Mat}}}_{\mathbb{C}}\) is a \(\dagger\) -functor. By extension,there is a dagger structure on \({\mathbf{{Mat}}}_{\mathbb{S}}\) for each rig anti-homomorphism \(\dagger   : \mathbb{S} \rightarrow  \mathbb{S}\) ,i.e. a homomorphism for the commutative addition and an anti-homomorphism for the (non-necessarily commutative) product \(\dagger  \left( {a \times  b}\right)  =  \dagger  \left( b\right)  \times   \dagger  \left( a\right)\) . Thus,when \(\mathbb{S}\) is a commutative rig such as the Boolean, \({\text{Mat}}_{\mathbb{S}}\) is automatically a \(\dagger\) -category with the transpose as dagger and the identity as conjugation.</p>
<p>DisCoPy implements free \(\dagger\) -categories by adding an attribute is_dagger: bool to boxes and a method Arrow.dagger, shortened to the postfix operator [::-1], which reverses the order of boxes and negates is_dagger elementwise. The normal form is computable in linear time but it has not been implemented yet. In order to implement the syntactic sugar \(\mathrm{f}\left\lbrack  { :  :  - 1}\right\rbrack   =  = \mathrm{f}\) .dagger \(\left( \right)\) ,we need to override the <em><strong><strong>getitem</strong></strong></em> method. In general, DisCoPy defines indexing f[i] and slicing f[start:stop:step] so that f[key].inside == f.inside[key] for any key: int and any key: slice with key.step in (-1, 1, None). Example 1.1.23. We can show the dagger is indeed a contravariant endofunctor.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 49-->
<!-- Media -->
<hr>
<p>Listing 1.1.22. Implementation of free \(\dagger\) -categories and \(\dagger\) -functors.
class Arrow(cat.Arrow):
def dagger(self):
inside = tuple(box.dagger(   ) for box in self.inside[::-1])
return self.cast(Arrow(inside, self.cod, self.dom))
def <em>getitem</em>(self, key: int | slice) -> Arrow:
if isinstance(key, slice):
if key.step == -1 :
inside = tuple(box.dagger(   ) for box in self.inside[key])
return self.cast(Arrow(inside, self.cod, self.dom))
if (key.step or 1) != 1:
raise IndexError
inside = self.inside[key]
if not inside:
if (key.start or 0) >= len(self):
return self.id(self.cod)
if (key.start or 0 ) &#x3C;=-len(self):
return self.id(self.dom)
return self.id(self.inside[key.start or 0].dom)
return self.cast(Arrow(inside, inside[0].dom, inside[-1].cod))
return self.inside[key]
class Box ( cat. Box , Arrow ) :
cast = Arrow.cast
def <em><strong><strong>init</strong></strong></em>(self, name: str, dom: 0b, cod: 0b, is_dagger=False):
self.is_dagger = is_dagger; cat.Box.<em>init</em>(self, name, dom, cod)
def dagger(self):
return type(self) (self.name, self.cod, self.dom, not self.is_dagger)
class Functor(cat.Functor):
dom = cod = Category (Ob, Arrow)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Box) and other.is_dagger:
return self(other.dagger(   )).dagger(   )
return super(   ).<strong>call</strong>(other)</p>
<hr>
<!-- Media -->
<hr>
<p>\(\mathrm{x},\mathrm{y},\mathrm{z} = \operatorname{map}\left( {0\mathrm{\;b},\text{"xyz"}}\right)\)
\(\mathrm{f},\mathrm{g} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{g}}^{\prime },\mathrm{y},\mathrm{z}}\right)\)</p><!-- Meanless: 50 1.1. Categories in Python-->
<pre><code>assert Arrow.id(x) \( \left\lbrack  { :  - 1}\right\rbrack   =  = \) Arrow.id(x)
</code></pre>
<p>assert (f >> g)[::-1] == g[::-1] >> f[::-1]</p>
<hr>
<p>Listing 1.1.24. Implementation of \({\mathbf{{Mat}}}_{\mathbb{S}}\) as a \(\dagger\) -category.</p>
<hr>
<p>def transpose(self: Matrix) -> Matrix:
inside = [[self[j][i] for j in range(self.dom)] for i in range(self.cod)]
return type ( self ) ( inside, self.cod, self.dom )
def map(self: Matrix, func: Callable [[Number], Number]) -> Matrix:
inside = [list(map(func, row)) for row in self.inside]
return type ( self ) ( inside, self.dom, self.cod )
Matrix.transpose, Matrix.map = transpose, map
Matrix.conjugate = lambda self: self.map(lambda x: x.conjugate(   ))
Matrix.dagger = lambda self: self.conjugate(   ).transpose(   )</p>
<hr>
<p>Example 1.1.25. We can implement a simulator for 1-qubit circuits as a \(\dagger\) -functor.</p>
<hr>
<p>Circuit.eval = lambda self: Functor(   )
ob={Ob('1'): 2},
ar={X: [[0, 1], [1, 0]],
Y: [[0, -1j], [1j, 0]],
Z: [[1, 0], [0, -1]],
H: [[x / sqrt(2) for x in row] for row in [[1, 1], [1, -1]]]},
cod = Category ( int , Matrix[complex] ) ) ( self )</p>
<hr>
<p>We can check that every circuit is unitary, i.e. its dagger is also its inverse.</p>
<hr>
<p>for c in [X, Y, Z, H, X >> Y >> Z >> H]:
assert (c >> c[::-1]).eval(   )\
== Matrix [complex] . id(2)\
== (c[::-1] >> c).eval(   )</p>
<hr>
<p>We can check the equations given in the presentation of example 1.1.20.</p>
<hr>
<p>assert (Z >> H).eval(   ) == (H >> X).eval(   )
assert (Z >> X).eval(   ) == (X >> Z).eval(   ).map(lambda x: -x)
for gate in [H, Z, X]: assert (gate >> gate).eval(   ) == Matrix[complex].id(2)</p>
<hr>
<p>A category \(C\) is commutative-monoid-enriched (CM-enriched) when it comes equipped with a commutative monoid \(\left( {+,0}\right)\) on each homset \(C\left( {x,y}\right)\) such that \(f\mathring{} 0 = 0 = 0\mathring{} f\) and \(\left( {f + {f}^{\prime }}\right) \mathring{} \left( {g + {g}^{\prime }}\right)  = f\mathring{} g + f\mathring{} {g}^{\prime } + {f}^{\prime }\mathring{} g + {f}^{\prime }\mathring{} {g}^{\prime }\) for all arrows \(f,g,{f}^{\prime },{g}^{\prime }\) . A functor \(F : C \rightarrow  D\) between CM-enriched categories is CM-enriched when \(F\left( 0\right)  = 0\) and \(F\left( {f + g}\right)  = F\left( f\right)  + F\left( g\right)\) . For example,the category \({\mathbf{{Mat}}}_{\mathbb{S}}\) is CM-enriched with elementwise addition of matrices. A commutative-monoid-enriched category with one object is precisely a rig. Given a signature \(\sum\) ,we construct the free CM-enriched category \({F}^{ + }\left( \sum \right)\) by taking the free commutative monoid over each homset of \(F\left( \sum \right)\) ,i.e. arrows \(f : x \rightarrow  y\) in \({F}^{ + }\left( \sum \right)\) are bags (also called multisets) of arrows \({f}_{i} : x \rightarrow  y\) in \(F\left( \sum \right)\) .</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 51-->
<p>In DisCoPy, free CM-enriched categories are implemented by Sum, a subclass of Box with an attribute terms: list[Arrow] as well as its own cast method, which turns an arrow into the sum of just itself. It is attached to the arrow with Arrow.sum = Sum,we also override Arrow.then so that we have \(\mathrm{f} \gg  \left( {\mathrm{g} + \mathrm{h}}\right)\) \(=  =\) Sum. cast(f) \(>  > \left( {\mathrm{g} + \mathrm{h}}\right)\) for any arrow \(\mathrm{f}\) ,i.e. . the composition of an arrow with a sum is the sum of the compositions with its terms. We define equality so that \(\mathrm{f} =  =\) Sum. cast(f),equality of bags of terms is implemented as equality of lists sorted by an arbitrary ordering. DisCoPy functors are commutative-monoid-enriched, i.e. a formal sum of arrows can be interpreted as a concrete sum of matrices.</p>
<!-- Media -->
<p>Listing 1.1.26. Implementation of free sum-enriched categories and functors.</p>
<p>class Arrow(cat.Arrow) :</p>
<hr>
<pre><code>def _____eq_____ (self, other):
	return other.terms == (self, ) if isinstance(other, Sum)\\
		else super(   )._____eq_____(other)
def then(self, other: Arrow) -> Arrow:
	return self.sum.cast(self).then(other) if isinstance(other, Sum)\\
		else super(   ).then(other)
@classmethod
def zero(cls, dom: 0b, cod: 0b) -> Arrow: return cls.sum((   ), dom, cod)
__add__ = lambda self, other: self.sum.cast(self) + other
_____lt_____ = lambda self, other: hash(self) &#x3C; hash(other) # An arbitrary order.
</code></pre>
<p>class Sum (cat. Box, Arrow) :
def <strong>init</strong>(self, terms: tuple[Arrow, ...], dom: Ob, cod: Ob):
assert all ( \(\mathrm{f}\) .dom \(=  =\) dom and \(\mathrm{f} \cdot  \mathrm{{cod}} =  = \mathrm{{cod}}\) for \(\mathrm{f}\) in terms)
self.terms, name = terms, "Sum({}, {}, [{}])".format(   )
dom, cod, ", ".join(map(str, terms)))
cat.Box.<em><strong><strong>init</strong></strong></em>(self, name, dom, cod)
def <em><strong><strong>eq</strong></strong></em> (self, other):</p>
<hr>
<!-- Media --><!-- Meanless: 52 1.1. Categories in Python-->
<hr>
<pre><code>	if isinstance(other, Sum):
		return ( self.dom, self.cod, sorted(self.terms))\\\\
			== (other.dom, other.cod, sorted(other.terms))
	return self.terms == (other,)
def __add__(self, other):
	if not isinstance(other, Sum): return self + self.cast(other)
	return Sum ( self.terms + other.terms, self.dom, self.cod)
@classmethod
def cast(cls, old: cat.Arrow) -> Sum:
	return old if isinstance(old, cls) else cls((old, ), old.dom, old.cod)
@inductive
def then(self, other):
	terms = tuple(f.then(g) for \( f \) in self.terms for \( g \) in self.cast(other).terms)
	return type ( self ) ( terms , self.dom, other.cod )
def dagger(self):
	return type(self) (tuple(f.dagger(   ) for f in self.terms), self.cod, self.dom)
id = lambda x : Sum.cast(Arrow.id(x))
</code></pre>
<p>Arrow.sum = Sum
class Functor (cat.Functor) :
dom = cod = Category (Ob, Arrow)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Sum):
unit = self.cod.ar.zero(self(other.dom), self(other.cod))
return sum ( [self(f) for f in other.terms], unit)
return super(   ).<strong>call</strong>(other)</p>
<hr>
<p>Listing 1.1.27. Implementation of \({\mathbf{{Mat}}}_{\mathbb{S}}\) as a CM-enriched category.</p>
<hr>
<p>class Matrix:
...
def <strong>add</strong>(self, other: Matrix) -> Matrix:
inside = [[x + y for x, y in zip(u, v)]
for u, v in zip(self.inside, other.inside)]
return type ( self ) ( inside, self.dom, self.cod )
def <em>radd</em>_(self, other: Number) -> Matrix:</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 53-->
<pre><code>#We can add a scalar matrix and a number.
assert self.dom == self.cod == 1
return self.inside[0] [0] + other
</code></pre>
<p>@classmethod
def zero(cls, dom: int, cod: int) -> Matrix:
return cls ([[0 for _ in range(cod)] for _ in range(dom)], dom, cod)</p>
<hr>
<p>We define a bubble on a category \(C\) as a pair of unary operators \({\beta }_{\text{dom }},{\beta }_{\text{cod }}\) : \({C}_{0} \rightarrow  {C}_{0}\) on objects and a unary operator between homsets \(\beta  : C\left( {x,y}\right)  \rightarrow\) \(C\left( {{\beta }_{\text{dom }}\left( x\right) ,{\beta }_{\text{cod }}\left( y\right) }\right)\) for pairs of objects \(x,y \in  {C}_{0}\) . Given a signature \(\sum\) and a pair \({\beta }_{\text{dom }},{\beta }_{\text{cod }} : {C}_{0} \rightarrow  {C}_{0}\) ,we construct the free category with bubbles \(F\left( {\sum }^{\beta }\right)\) by induction on the maximum level \(n\) of bubble nesting: take the signature \({\sum }^{\beta } = \mathop{\bigcup }\limits_{{n \in  \mathbb{N}}}{\sum }_{n}^{\beta }\) for \({\sum }_{0}^{\beta } = \sum\) and \({\sum }_{n + 1}^{\beta } = \sum  + \left\{  {\beta \left( f\right)  \mid  f \in  F\left( {\sum }_{n}^{\beta }\right) }\right\}\) . That is,box in \({\sum }^{\beta }\) is a box in \({\sum }_{n}^{\beta }\) for some \(n \in  \mathbb{N}\) . A box in \({\sum }_{n}^{\beta }\) is either a box in \(\sum\) or an arrow \(f : x \rightarrow  y\) in \(F\left( {\sum }_{n - 1}^{\beta }\right)\) that we have put inside a bubble \(\beta \left( f\right)  : {\beta }_{\text{dom }}\left( x\right)  \rightarrow  {\beta }_{\text{cod }}\left( y\right)\) .</p>
<p>Remark 1.1.28. Bubbles are called unary operator on homsets (uooh) in [HS20] where they are used to encode the sep lines of Peirce's existential graphs, see example 1.2.37. As we will discuss in section 2.3, they first appeared in Penrose and Rindler [PR84] as an informal notation for the covariant derivative.</p>
<p>Example 1.1.29. The functorial boxes of Melliès [Mel06] can be thought of as well-behaved bubbles, i.e. such that the composition of bubbles is the bubble of the composition. Indeed,a functor \(F : \mathbf{C} \rightarrow  \mathbf{D}\) between two categories \(\mathbf{C}\) and \(\mathbf{D}\) defines a bubble on the subcategory of their coproduct \(\mathbf{C} \coprod  \mathbf{D}\) spanned by \(\mathbf{C}\) .</p>
<p>Example 1.1.30. Any endofunctor \(\beta  : C \rightarrow  C\) also defines a bubble,thus we can define a bubble-preserving functor \(F\left( {U{\left( C\right) }^{\beta }}\right)  \rightarrow  C\) which interprets bubbles as functor application. Any functor between two categories \(C\) and \(D\) defines a bubble on their disjoint union \(C + D\) (i.e. with objects \({C}_{0} + {D}_{0}\) and arrows \({C}_{1} + {D}_{1}\) ). These functor bubbles have also been called functorial boxes [Mel06].</p>
<p>Example 1.1.31. An exponential rig is a one-object CM-enriched category \(\mathbb{S}\) with a bubble \(\exp  : \mathbb{S} \rightarrow  \mathbb{S}\) which is a homomorphism from sum to product,i.e. \(\exp \left( {a + b}\right)  = \exp \left( a\right) \exp \left( b\right)\) and \(\exp \left( 0\right)  = 1\) . Any rig \(\mathbb{S}\) is an exponetial rig by taking \(\exp \left( a\right)  = 1\) for all \(a \in  \mathbb{S}\) . Non-trivial examples include complex numbers as well as the Boolean rig with negation.</p>
<p>Example 1.1.32. Matrix exponential is a bubble on the subcategory of square matrices,with the property that \(\exp \left( {f + g}\right)  = \exp \left( f\right) \mathring{} \exp \left( g\right)\) whenever \(f\mathring{} g = g\mathring{} f\) . Also,any function \(\mathbb{S} \rightarrow  \mathbb{S}\) yields a bubble on \({\mathbf{{Mat}}}_{\mathbb{S}}\) given by element-wise application. For example,we can define a bubble on the category \({\mathbf{{Mat}}}_{\mathbb{B}}\) of Boolean matrices which sends each matrix \(f\) to its entrywise negation \(\bar{f}\) .</p><!-- Meanless: 54 1.1. Categories in Python-->
<p>DisCoPy implements free bubbles with Bubble, a subclass of Box which we attach to the arrow class with Arrow.bubble = Bubble. Bubble has attributes diagram: Arrow as well as optional arguments dom: Ob, cod: Ob and method: str. DisCoPy functors interpret bubbles as the application of method in the codomain category, by default we send bubbles to bubbles. The resulting syntax is strictly more expressive than that of free categories alone. For example, element-wise negation cannot be expressed as a composition: there is no matrix \(N : x \rightarrow  x\) in \({\mathbf{{Mat}}}_{\mathbb{B}}\) such that \(N\) , \(f = \bar{f}\) for all \(f : x \rightarrow  y\) . This is also the case for the element-wise application of any non-linear function such as the rectified linear units (ReLU) used in machine learning. As we will discuss in section 2.3, differentiation of parameterised matrices cannot be expressed as a composition either, but it is a unary operator between homsets, i.e. a bubble.</p>
<!-- Media -->
<p>Listing 1.1.33. Implementation of free categories with bubbles and their functors.</p>
<p>class Bubble(Box):</p>
<hr>
<pre><code>method = "bubble"
def _____init_____(self, diagram: Arrow, dom=None, cod=None, **params):
	self.diagram = diagram
	self.method = params.pop("method", type(self).method)
	name = "Bubble(\{\}, \{\}, \{\})".format(diagram, dom, cod)
	dom, cod = dom or diagram.dom, cod or diagram.cod
	super(   ). _____init_____(name, dom, cod, **params)
def dagger(self):
	return type(self) (   )
		self.diagram, self.dom, self.cod, is_dagger=not self.is_dagger)
@property
def is_id_on_objects(self):
	return self.dom == self.diagram.dom and self.cod == self.diagram.cod
</code></pre>
<p>Arrow.bubble = lambda self, **kwargs: Bubble (self, **kwargs)
class Functor (cat.Functor) :
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Bubble):</p>
<hr>
<!-- Media --><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 55-->
<hr>
<pre><code>method = getattr(self.cod.ar, other.method)
if other.is_id_on_objects:
	return method ( self (other.diagram ) )
return method ( self (other.diagram ) , self (other.dom ) , self (other.cod ) )
</code></pre>
<p>return super(   ). _call (other)</p>
<hr>
<p>Example 1.1.34. We can encode the architecture of a neural network as an arrow with sums and bubbles, encoding vector addition and non-linear activation function respectively. The evaluation of the neural network on some input vector for some parameters is given by the application of a sum-and-bubble-preserving functor into \({\mathbf{{Mat}}}_{\mathbb{R}}\) . The hyper-parameters (i.e. the number of neurons at each layer) are given by the image of the functor on objects.</p>
<!-- Media -->
<hr>
<p>\(\mathrm{x},\mathrm{y},\mathrm{z} = \operatorname{map}\left( {0\mathrm{\;b},\text{"xyz"}}\right)\)
Matrix.ReLU = lambda self: self.map(lambda x: max(x, 0))
class Network ( Arrow ) :
pass
class ReLU (Bubble, Network) :
method = "ReLU"
cast = Network.cast
class Box ( cat. Box , Network ) :
cast = Network.cast
vector, bias = Box ('vector', x, y), Box ('bias', x, x)
ones, weights = Box('ones', x, y), Box('weights', y, z)
network = ReLU((vector + (bias >> ones)) >> weights)
F = Functor(   )
ob={x: 1,y: 4, z: 2},
ar={vector: [[1.2, -2.3, 3.4, -4.5]],
bias: [[-3.14]], ones: [[1, 1, 1, 1]],
weights: \(\left\lbrack  {\lbrack {5.6}, - {6.7}\rbrack ,\left\lbrack  {{7.8}, - {8.9}}\right\rbrack  ,}\right\rbrack\)
\(\left\lbrack  {{9.0}, - {0.1}}\right\rbrack  ,\left\lbrack  {{2.3}, - {3.4}}\right\rbrack  \rbrack \}\) ,
dom \(=\) Category (Ob, Network) ,
cod=Category( int , Matrix[float] ) )
assert F(network) == F(vector).map(lambda x: x + F(bias))\
then(F(weights)).map(lambda x: max(0, x))</p>
<hr>
<!-- Media --><!-- Meanless: 56 1.2. Diagrams in Python-->
<p>Example 1.1.35. We can implement propositional logic with boxes as propositions, composition as conjunction, sum as disjunction and bubble as negation. The evaluation of a formula in a model corresponds to the application of a sum-and-bubble-preserving functor into \({\operatorname{Mat}}_{\mathbb{B}}\left( {1,1}\right)\) .</p>
<!-- Media -->
<hr>
<p>Matrix._not = lambda self: self.map(lambda x: not x)
class Formula(Arrow): pass
class Not (Bubble, Formula) :
method = "_not"
class Proposition (Box, Formula):
def <em>init</em>(self, name):
Box.<em>init</em>(self, name, 0b('x'), 0b('x'))
Not.cast = Proposition.cast = Formula.cast
def model(data: dict[Proposition, bool]):
return Functor(ob={0b('x'): 1}, ar={p: [[data[p]]] for p in data},
dom=Category(Ob, Formula), cod=Category(int, Matrix[bool]))
p, q = map (Proposition, "pq")
p_implies_q = Not(Not(q) >> p)
not_p_or_q = Not(p) + q
for a,b in itertools.product \(\left( {\left\lbrack  {0,1}\right\rbrack  ,\left\lbrack  {0,1}\right\rbrack  }\right)\) :
F = model \(\left( {\{ \mathrm{p} : \mathrm{a},\mathrm{q} : \mathrm{b}\} }\right)\)
assert F(p_implies_q) == (not (not F(q) and F(p)))\
\(=  = F\left( {{not}\_ {p\_ {or}}\_ q}\right)  =  = \left( {{not}F\left( p\right) \text{or}F\left( q\right) }\right)\)</p>
<hr>
<!-- Media -->
<h3>1.2 Diagrams in Python</h3>
<p>In the previous section, we introduced the idea of arrows in free categories as abstract data pipelines and functor application as their evaluation in concrete categories such as Pyth, Mat or Circ where the computation happens. For now, our pipelines are rather basic because they are linear: we cannot express functions of multiple arguments, nor tensors of order higher than 2, nor circuits with multiple qubits in any explicit way.</p>
<p>In this section, we move from the one-dimensional syntax of arrows in free categories to the two-dimensional syntax of string diagrams, the arrows of free monoidal categories. The data for a (strict \({}^{1}\) ) monoidal category \(C\) is that of a category together with: an object \(1 \in  {C}_{0}\) called the unit and a pair of overloaded binary operations called the tensor on objects \(\otimes   : {C}_{0} \times  {C}_{0} \rightarrow  {C}_{0}\) and on arrows \(\otimes   : {C}_{1} \times  {C}_{1} \rightarrow  {C}_{1}\) ,translated to ( \(@\) in Python. The axioms for monoidal categories are the following:</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 57-->
<ul>
<li>
<p>\(\left( {{C}_{0},\otimes ,1}\right)\) and \(\left( {{C}_{1},\otimes ,\operatorname{id}\left( 1\right) }\right)\) are monoids,</p>
</li>
<li>
<p>the tensor defines a functor \(\otimes   : C \times  C \rightarrow  C\) ,i.e. the following interchange law \(\left( {f\mathring{} {f}^{\prime }}\right)  \otimes  \left( {g\mathring{} {g}^{\prime }}\right)  = \left( {f \otimes  g}\right) \mathring{} \left( {{f}^{\prime } \otimes  {g}^{\prime }}\right)\) holds for all arrows \(f,{f}^{\prime },g,{g}^{\prime } \in  {C}_{1}\) .</p>
</li>
</ul>
<p>We will use the following terminology: an object \(x\) is called a system,an arrow \(f\) : \(1 \rightarrow  x\) from the unit is called a state of the system \(x\) ,an arrow \(f : x \rightarrow  1\) into the unit is called an effect of \(x\) and an arrow \(a : 1 \rightarrow  1\) from the unit to itself is called a scalar.</p>
<p>A functor \(F : C \rightarrow  D\) between monoidal categories \(C\) and \(D\) is (strict \({}^{2}\) ) monoidal whenever it is also a monoid homomorphism on objects and arrows. Thus, monoidal categories themselves form a category MonCat with monoidal functors as arrows. A transformation \(\alpha  : F \rightarrow  G\) between two monoidal functors \(F,G : C \rightarrow  D\) is monoidal itself when \(\alpha \left( {x \otimes  y}\right)  = \alpha \left( x\right)  \otimes  \alpha \left( y\right)\) for all objects \(x,y \in  C\) .</p>
<p>Example 1.2.1. Every monoid \(M\) can also be seen as a discrete monoidal category, i.e. with only identity arrows.</p>
<p>Example 1.2.2. A monoidal category with one object is a commutative monoid. Indeed in any monoidal category, the interchange law implies that scalars form a commutative monoid, by the following Eckmann-Hilton argument:</p>
<p></p>\[a{}_{9}^{ \circ  }b = 1 \otimes  a{}_{9}^{ \circ  }b \otimes  1 = \left( {1{}_{9}^{ \circ  }b}\right)  \otimes  \left( {a{}_{9}^{ \circ  }1}\right)  = b \otimes  a\]<p></p>
<p></p>\[= \left( {b \circ  1}\right)  \otimes  \left( {1 \circ  a}\right)  = b \otimes  1 \circ  1 \otimes  a = b \circ  a\]<p></p>
<p>Example 1.2.3. A monoidal category with at most one arrow between any two objects is called a preordered monoid. The functoriality axiom implies that the preorder is in fact a pre-congruence,i.e. \(a \leq  b\) and \(c \leq  d\) implies \(a \times  c \leq  b \times  d\) . Given the presentation of a monoid(X,R)with \(R \subseteq  {X}^{ \star  } \times  {X}^{ \star  }\) ,we can construct a preordered monoid with \(\left( { \leq  }_{R}\right)  = \mathop{\bigcup }\limits_{{n \in  \mathbb{N}}}{R}^{n} \subseteq  {X}^{ \star  } \times  {X}^{ \star  }\) the (non-symmetric) reflexive transitive closure of \(R\) . Thus,the inequality problem (i.e. given two lists \(x,y \in  {X}^{ \star  }\) and a presentation(X,R),decide whether \(x{ \leq  }_{R}y\) ) is a generalisation of the word problem for monoids.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) We will assume that our monoidal categories are strict,i.e. the axioms for monoids are equalities rather than natural isomorphisms subject to coherence conditions.</p>
<p>\({}^{2}\) We will assume that our monoidal functors are strict,i.e. \(F\left( {x \otimes  y}\right)  = F\left( x\right)  \otimes  F\left( y\right)\) and \(F\left( 1\right)  = 1\) are equalities rather than natural transformations.</p>
<!-- Footnote -->
<hr><!-- Meanless: 58 1.2. Diagrams in Python-->
<p>Example 1.2.4. The category FinSet is monoidal with the singleton 1 as unit and Cartesian product as tensor. Again, this is not a strict monoidal category but it is equivalent to one: take the category with natural numbers \(m,n \in  \mathbb{N}\) as objects and functions \(\left\lbrack  m\right\rbrack   \rightarrow  \left\lbrack  n\right\rbrack\) as arrows for \(\left\lbrack  n\right\rbrack   = \{ 0,1,\ldots ,n - 1\}\) . The states can be identified with elements and the only effect is discarding, i.e. the constant function into the singleton. FinSet is also monoidal with the empty set 0 as unit and disjoint union as tensor.</p>
<p>Example 1.2.5. For any category \(C\) ,there is a monoidal category \({C}^{C}\) where the objects are enfodunctors with composition as tensor and the arrows are natural transformations \(\alpha  : F \rightarrow  {F}^{\prime },\beta  : G \rightarrow  {G}^{\prime }\) with vertical composition \(\left( {\alpha  \otimes  \beta }\right) \left( x\right)\) : \(G\left( {F\left( x\right) }\right)  \rightarrow  {G}^{\prime }\left( {{F}^{\prime }\left( x\right) }\right)\) as tensor.</p>
<p>Example 1.2.6. The category Pyth is monoidal with unit (   ) and tuple [t1, t2] as the tensor of types \(\mathrm{t}1\) and \(\mathrm{t}2\) . Given two functions \(\mathrm{f}\) and \(\mathrm{g}\) ,we can define their tensor \(\mathrm{f}@\mathrm{g} = 1\mathrm{{ambda}}\mathrm{x},\mathrm{y} : \mathrm{f}\left( \mathrm{x}\right) ,\mathrm{g}\left( \mathrm{y}\right)\) .</p>
<!-- Media -->
<p>Listing 1.2.7. Implementation of Pyth as a (non-strict pre)monoidal category with tuple as tensor.</p>
<hr>
<p>class Function:
...
def tensor(self, other: Function) -> Function:
dom, cod = tuple[self.dom, other.dom], tuple[self.cod, other.cod]
return Function (lambda x, y: (self(x), other(y)), dom, cod)</p>
<hr>
<!-- Media -->
<p>Remark 1.2.8. As discussed in remark 1.1.9, it's not clear whether Pyth is a category. It's even less clear whether it can be called a monoidal category, for two reasons. First, Pyth is not strict monoidal: \(\left( {\mathrm{x},\left( {\mathrm{y},\mathrm{z}}\right) }\right) ! = \left( {\left( {\mathrm{x},\mathrm{y}}\right) ,\mathrm{z}}\right)\) and \(\left( {\left( \right) ,\mathrm{x}}\right) ! = \mathrm{x}! = \left( {\mathrm{x},\left( \right) }\right)\) are not strictly equal but only naturally isomorphic. These natural isomorphisms are subject to coherence conditions which make sure that all the ways to rebracket \(\left( {\left( {\left( {\mathrm{x},\mathrm{y}}\right) ,\mathrm{z}}\right) ,\mathrm{w}}\right)\) into \(\left( {\mathrm{x},\left( {\mathrm{y},\left( {\mathrm{z},\mathrm{w}}\right) }\right) }\right)\) are the same. In practice, this bureaucracy of parenthesis does not pose any problem: MacLane's coherence theorem [Mac71, p. VII] makes sure that every monoidal category is monoidally equivalent \({}^{1}\) to a strict one.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) An equivalence of categories is an adjunction where the unit and counit are in fact natural isomorphisms. It is a monoidal equivalence when they are also monoidal transformations.</p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 59-->
<p>Second, the interchange law only holds for the subcategory of Pyth with pure functions as arrows. Indeed,if the functions \(\mathrm{f}\) and \(\mathrm{g}\) are impure (e.g. they call random or print) then their tensor \(\mathrm{f}@\mathrm{g}\) will depend on the order in which they are evaluated,i.e. \(\mathrm{f}@\mathrm{{id}} > \mathrm{{id}}@\mathrm{g}! = \mathrm{{id}}@\mathrm{g} >  > \mathrm{f}@\mathrm{{id}}\) . As we will discuss in section 1.5, Pyth is in fact a premonoidal category. The states, i.e. the functions \(\mathrm{f}\) : (   ) \(\rightarrow  \mathrm{t}\) ,can be identified with their value \(\mathrm{f}\) (   ): t. There is only one pure effect,i.e. a unique pure function \(\mathrm{f} : \mathrm{t} \rightarrow\) (   ) called discarding,and thus a unique pure scalar. If we take all impure functions into account, the scalars form a non-commutative monoid of side-effects.</p>
<p>Example 1.2.9. We can also make Pyth monoidal with the tagged union as tensor on objects and typing.NoReturn as unit. Given two types \(\mathrm{t}0\) , \(\mathrm{t}1\) ,their tagged union \(\mathrm{t}0 + \mathrm{t}1\) is the union of the types tuple \(\left\lbrack  {0,\mathrm{t}0}\right\rbrack\) and tuple \({\left\lbrack  1,\mathrm{t}1\right\rbrack  }^{1}\) , i.e. a term (b, x): t0 + t1 is a pair of a Boolean b: bool and a term x: t0 if \(\mathrm{b}\) else a term \(\mathrm{x}\) : t1. Given two functions \(\mathrm{f},\mathrm{g}\) we can define their tensor as lambda b, x:(b, f(x) if b else g(x)).</p>
<p>Example 1.2.10. The category \({\mathbf{{Mat}}}_{\mathbb{S}}\) is monoidal with addition of natural numbers as tensor on objects and the direct sum \(f \oplus  g = \left( \begin{array}{ll} f &#x26; 0 \\  0 &#x26; g \end{array}\right)\) as tensor on arrows. When the rig \(\mathbb{S}\) is commutative, \({\mathbf{{Mat}}}_{\mathbb{S}}\) is also monoidal with multiplication of natural numbers as tensor on objects and the Kronecker product as tensor on arrows. The inclusion functor \({\mathbf{{FinSet}}}_{ \rightarrow  }{\mathbf{{Mat}}}_{\mathbb{B}}\) is monoidal in two ways: it sends disjoint unions to direct sums and Cartesian products to Kronecker products.</p>
<p>Listing 1.2.11. Implementation of \({\mathbf{{Mat}}}_{\mathbb{S}}\) as a monoidal category with direct_sum and Kronecker as tensor.</p>
<hr>
<p>class Matrix:
...
def direct_sum(self, other: Matrix) -> Matrix:
dom, cod = self.dom + other.dom, self.cod + other.cod
left, right = (len (m.inside[0]) if m.inside else 0 for m in (self, other))
inside = [row + right * [0] if i &#x3C; len(self.inside) else left * [0] + row
for i, row in enumerate (self.inside + other.inside)]
return type ( self ) ( inside, dom, cod )
def Kronecker (self, other: Matrix) -> Matrix:
dom, cod = self.dom * other.dom, self.cod * other.cod
inside = [[self.inside[i_dom][i_cod] * other.inside[j_dom][j_cod]
for i_cod in range(self.cod) for j_cod in range(other.cod)]</p>
<hr>
<p>てござるようなとてもうちとすることはもり何しかものかとして、より一つはもりもしていまし</p><!-- Meanless: 60 1.2. Diagrams in Python-->
<hr>
<pre><code>for i_dom in range(self.dom) for j_dom in range(other.dom)]
</code></pre>
<p>return type ( self ) ( inside , dom, cod )</p>
<hr>
<p>Example 1.2.12. The category Circ is monoidal with addition of natural numbers as tensor on objects and parallel composition of circuits as tensor on arrows. The evaluation functor eval : \(\operatorname{Circ} \rightarrow  {\operatorname{Mat}}_{\mathbb{C}}\) is monoidal: it sends the parallel composition of circuits to the Kronecker product of their unitary matrices.</p>
<h4>1.2.1 Foo monoidal categories</h4>
<p>Again, implementing a monoidal category in Python means nothing but defining a pair of classes for objects and arrows with a tensor method that satisfies the axioms. Less trivially, we want to implement the arrows of free monoidal categories which can then be interpreted in arbitrary monoidal categories via the application of monoidal functors: this is the content of the discopy. monoidal module. As in the case of free categories, free monoidal categories will be the image of a functor \(F :\) MonSig \(\rightarrow\) MonCat,the left adjoint to the forgetful functor \(U :\) MonCat \(\rightarrow\) MonSig from monoidal categories to monoidal signatures. A monoidal signature \(\sum\) is a monoidal category without identity,composition or tensor: a pair of sets \({\sum }_{0},{\sum }_{1}\) and a pair of functions \(\operatorname{dom},\operatorname{cod} : {\sum }_{1} \rightarrow  {\sum }_{0}^{ \star  }\) from boxes to lists of objects. A morphism of monoidal signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) is a pair of functions \(f : {\sum }_{0} \rightarrow  {\sum }_{0}^{\prime }\) and \(f : {\sum }_{1} \rightarrow  {\sum }_{1}^{\prime }\) with \(f\mathring{} \operatorname{dom} = \operatorname{dom}\mathring{} {f}^{ \star  }\) and \(f\mathring{} \operatorname{cod} = \operatorname{cod}\mathring{} {f}^{ \star  }\) . Thus,we have defined the category MonSig of monoidal signatures and their morphisms.</p>
<p>In order to define the forgetful functor \(U : \mathbf{{MonCat}} \rightarrow\) MonSig,we will make our lives easier and add an extra assumption: that monoidal categories are free on objects (foo),i.e. that the monoid of objects \(\left( {{C}_{0},\otimes ,1}\right)\) is a free monoid \({C}_{0} = {X}^{ \star  }\) generated by some set of objects \(X\) . This means we can take the data for a monoidal category \(C\) to be the following:</p>
<ul>
<li>
<p>a class \({C}_{0}\) of generating objects and a class \({C}_{1}\) of arrows,</p>
</li>
<li>
<p>domain and codomain functions \(\operatorname{dom},\operatorname{cod} : {C}_{1} \rightarrow  {C}_{0}^{ \star  }\) ,</p>
</li>
<li>
<p>a function id : \({C}_{0}^{ \star  } \rightarrow  {C}_{1}\) and a (partial) operation then : \({C}_{1} \times  {C}_{1} \rightarrow  {C}_{1}\) ,</p>
</li>
<li>
<p>an operation on arrows tensor \(: {C}_{1} \times  {C}_{1} \rightarrow  {C}_{1}\) such that \(\operatorname{dom}\left( {f \otimes  g}\right)  =\) \(\operatorname{dom}\left( f\right) \operatorname{dom}\left( g\right)\) and \(\operatorname{cod}\left( {f \otimes  g}\right)  = \operatorname{cod}\left( f\right) \operatorname{cod}\left( g\right)\) .</p>
</li>
</ul>
<p>The axioms for the objects to be a monoid now come for free, we only need to require that tensor on arrows is a monoid with the interchange law. With this definition of (free-on-objects) monoidal category, we can define the forgetful functor \(U :\) MonCat \(\rightarrow\) MonSig: it forgets the identity,composition and tensor on arrows, but not the tensor on objects which is free.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 61-->
<p>Remark 1.2.13. In the cases of monoidal categories where the objects are the natural numbers with addition as tensor,such as \(\mathbf{{FinSet}}\) with disjoint union, \({\mathbf{{Mat}}}_{\mathbb{S}}\) with direct sum or \(\mathbf{{Circ}}\) ,the monoid of objects is already free: \(\left( {\mathbb{N},+,0}\right)\) is the free monoid generated by the singleton set. These monoidal categories are also called PROs (for PROduct categories). When the objects are generated by a more-than-one-element set they are also called coloured PROs, which is the standard name for foo-monoidal categories. For example, we can take all the Python types as colours and define Pyth as a foo-monoidal category with tuple [type, ...] as objects.</p>
<p>Remark 1.2.14. Given any non-foo monoidal category \(C\) ,we can construct an equivalent foo-monoidal category \({C}^{\prime }\) with objects \({C}_{0}^{ \star  }\) the free monoid over the objects of \(C\) and \({C}^{\prime }\left( {x,y}\right)  = C\left( {{\epsilon }_{{C}_{0}^{ \star  }}\left( x\right) ,{\epsilon }_{{C}_{0}^{ \star  }}\left( y\right) }\right)\) for \({\epsilon }_{{C}_{0}} : {C}_{0}^{ \star  } \rightarrow  {C}_{0}\) the counit of the list adjunction. That is,an arrow \(f : x \rightarrow  y\) between two lists \(x,y \in  {C}_{0}^{ \star  }\) in \({C}^{\prime }\) is an arrow \(f : {\epsilon }_{{C}_{0}}\left( x\right)  \rightarrow  {\epsilon }_{{C}_{0}}\left( y\right)\) between their multiplication in \(C\) . From left to right,the equivalence \(C \simeq  {C}^{\prime }\) sends every object \(x \in  {C}_{0}\) to its singleton list \(x \in  {C}_{0}^{ \star  }\) and every arrow to itself, from right to left it sends every list to its multiplication and every arrow to itself. Note that the functor \(F : C \rightarrow  {C}^{\prime }\) witnessing the equivalence is not strict monoidal,indeed \(F\left( {x \otimes  y}\right)\) is a singleton list whereas the list \(F\left( x\right)  \otimes  F\left( y\right)\) has two elements.</p>
<p>Example 1.2.15. Take a monoid \(M\) seen as a discrete monoidal category,we get an equivalent monoidal category \({M}^{\prime }\) with objects the free monoid \({M}^{ \star  }\) and an isomorphism \({x}_{1}\ldots {x}_{n} \rightarrow  {y}_{1}\ldots {y}_{m}\) whenever \({x}_{1} \times  \cdots  \times  {x}_{n} = {y}_{1} \times  \cdots  \times  {y}_{m}\) in \(M\) .</p>
<!-- Media -->
<p>Listing 1.2.16. Syntactic sugar for whiskering and tensor.</p>
<hr>
<p>class Tensorable:
@classmethod
def whisker(cls, other):
return other if isinstance(other, Tensorable) else cls.id(other)
<em><strong><strong>matmul</strong></strong></em> = lambda self, other: self.tensor(self.whisker(other))
<em><strong><strong>rmatmul</strong></strong></em> = lambda self, other: self.whisker(other).tensor(self)</p>
<hr>
<!-- Media -->
<p>Listing 1.2.17. Pyth as a foo-monoidal category with tuple [type, ...] as objects, Function as arrows and tuple as tensor.</p><!-- Meanless: 62 1.2. Diagrams in Python-->
<!-- Media -->
<hr>
<p>tuplify = lambda stuff: stuff if isinstance(stuff, tuple) else (stuff, )
untuplify = lambda stuff: stuff[0] if len(stuff) == 1 else stuff
class Function (cat.Function, Tensorable) :
inside: Callable
dom: tuple [type, ...]
cod: tuple [type, ...]
@inductive
def tensor(self, other: Function) -> Function:
def inside(*xs):
left, right = xs[:len(self.dom)], xs[len(self.dom):]
return untuplify(tuplify(self(*left)) + tuplify(other(*right)))
return Function (inside, self.dom + other.dom, self.cod + other.cod)</p>
<hr>
<!-- Media -->
<p>In the case of \({\mathbf{{Mat}}}_{\mathbb{S}}\) with Kronecker product as tensor,we can define an equivalent category Tensor \({}_{\mathbb{S}}\) where the objects are lists of natural numbers and the arrows \(f : {x}_{1}\ldots {x}_{n} \rightarrow  {y}_{1}\ldots {y}_{m}\) are \(\left( {{x}_{1} \times  \cdots  \times  {x}_{n}}\right)  \times  \left( {{y}_{1} \times  \cdots  \times  {y}_{m}}\right)\) matrices,i.e. tensors of order \(m + n\) . Note that we could define yet another equivalent category where the objects are lists of prime numbers instead.</p>
<p>Listing 1.2.18. Implementation of the foo-monoidal category Tensor \({}_{\mathrm{S}} \simeq  {\mathbf{{Mat}}}_{\mathrm{S}}\) with tuple [int, ...] as objects and Tensor [dtype] as arrows.</p>
<!-- Media -->
<hr>
<p>def product(x, unit=1): return unit if not x else product(x[1:], x[0] * unit)
class Tensor(Tensorable, Matrix):
inside: list [list [Number]]
dom: tuple [int, ...]
cod: tuple [int, ...]
def downgrade(self) -> Matrix:
return Matrix [self.dtype] (   )
self.inside, product ( self.dom ) , product ( self.cod ) )
@classmethod
def id(cls, x: tuple[int, ...]) -> Tensor:
return cls(Matrix.id(product(x)).inside, x, x)
@inductive
def then(self, other: Tensor) -> Tensor:
inside = Matrix.then(*map(Tensor.downgrade, (self, other))).inside
return type ( self ) ( inside, self.dom, other.cod )</p>
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 63-->
<hr>
<pre><code>@inductive
def tensor(self,other: Tensor) \( \rightarrow \) Tensor:
	inside = Matrix.Kronecker (*map(Tensor.downgrade, (self, other))).inside
	return type (self) (inside, self.dom + other.dom, self.cod + other.cod)
def _getitem_(self, key : int | tuple) -> Tensor:
	if isinstance(key, tuple):
		key = sum (   )
			key[i] * product(self.dom[i + 1:]) for i in range(len(key)))
	inside = Matrix._getitem_(self.downgrade(   ), key).inside
	dom, cod = ((   ), self.cod) if product(self.dom) == 1 else ((   ), (   ))
	return type ( self ) ( inside, dom, cod )
</code></pre>
<p>for attr in ("<em><strong><strong>bool</strong></strong></em>", "<em><strong><strong>int</strong></strong></em>", "<strong>float</strong>___", "_<em>complex</em>"):
setattr(Tensor, attr, lambda self: getattr(self.downgrade(   ), attr)(   ))</p>
<hr>
<!-- Media -->
<h4>1.2.2 Free monoidal categories</h4>
<p>Now how do we go on constructing the left adjoint \(F :\) MonSig \(\rightarrow\) MonCat? In the same way that lists in the free monoid \({X}^{ \star  }\) can be defined as equivalence classes of expressions built from generators in \(X\) ,product and unit,we can construct the arrows of the free monoidal category \(F\left( \sum \right)\) as equivalence classes of expressions built from boxes in \({\sum }_{1}\) ,identity,composition and tensor. In order to find good representatives for these equivalence classes, we will need the following technical lemma.</p>
<p>Definition 1.2.19. Given a monoidal signature \(\sum\) ,we define a signature of layers \(L\left( \sum \right)\) with \({\sum }_{0}^{ \star  }\) as objects and triples \(\left( {x,f,y}\right)  \in  {\sum }_{0}^{ \star  } \times  {\sum }_{1} \times  {\sum }_{0}^{ \star  }\) as boxes with \(\operatorname{dom}\left( {x,f,y}\right)  = x\operatorname{dom}\left( f\right) y\) and \(\operatorname{cod}\left( {x,f,y}\right)  = x\operatorname{cod}\left( f\right) y\) . Given a morphism of monoidal signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) ,we get a morphism between their signatures of layers \(L\left( f\right)  : L\left( \sum \right)  \rightarrow  L\left( {\sum }^{\prime }\right)\) . Thus,we have defined a functor \(L :\) MonSig \(\rightarrow\) Sig.</p>
<p>Lemma 1.2.20. Fix a monoidal signature \(\sum\) . Every well-typed expression built from boxes in \({\sum }_{1}\) ,identity of objects in \({\sum }_{0}^{ \star  }\) ,composition and tensor is equal to:</p>
<p></p>\[\operatorname{id}\left( x\right) \text{for}x \in  {\sum }_{0}^{ \star  }\text{or}\operatorname{id}\left( {x}_{1}\right)  \otimes  {f}_{1} \otimes  \operatorname{id}\left( {y}_{1}\right) \text{,}\ldots \text{,}\;\operatorname{id}\left( {x}_{n}\right)  \otimes  {f}_{n} \otimes  \operatorname{id}\left( {y}_{n}\right)\]<p></p>
<p>for some list of layers \(\left( {{x}_{1},{f}_{1},{y}_{1}}\right) ,\ldots ,\left( {{x}_{n},{f}_{n},{y}_{n}}\right)  \in  L\left( \sum \right)\) .</p>
<p>Proof. By induction on the structure of well-typed expressions. The only non-trivial case is for the tensor \(f \otimes  g\) of two expressions \(f : x \rightarrow  y\) and \(g : z \rightarrow  w\) ,where we need to apply the interchange law to push the tensor through the composition \(f \otimes  g = \left( {f \circ  \operatorname{id}\left( y\right) }\right)  \otimes  \left( {\operatorname{id}\left( z\right)  \circ  g}\right)  = f \otimes  \operatorname{id}\left( z\right)  \circ  \operatorname{id}\left( y\right)  \otimes  g.\)</p><!-- Meanless: 64 1.2. Diagrams in Python-->
<p>We have all the ingredients to define the free monoidal category \(F\left( \sum \right)\) : it is a quotient \(F\left( {L\left( \sum \right) }\right) /R\) of the free category generated by the signature of layers \(L\left( \sum \right)\) . Its objects,which we call types,are lists in the free monoid \({\sum }_{0}^{ \star  }\) . Its arrows,which we call diagrams,are paths with lists in \({\sum }_{0}^{ \star  }\) as nodes and layers \(\left( {x,f : s \rightarrow  t,y}\right)  \in\) \(L\left( \sum \right)\) as edges \({xsy} \rightarrow  {xty}\) . The equality of diagrams is the smallest congruence generated by the right interchanger:</p>
<p></p>\[\left( {{axb},g,c}\right) §\left( {a,f,{bwc}}\right) \;{ \rightarrow  }_{R}\;\left( {a,f,{bzc}}\right) §\left( {{ayb},g,c}\right)\]<p></p>
<p>for all types \(a,b,c \in  {\sum }_{0}^{ \star  }\) and boxes \(f : x \rightarrow  y\) and \(g : z \rightarrow  w\) . That is,we can interchange two consecutive layers whenever the output of the first box is not connected to the input of the second,i.e. there is an identity arrow id(b)separating them. Note that for an effect \(f : x \rightarrow  1\) followed by a state \(g : 1 \rightarrow  y\) ,we have two options: we can apply the right interchanger \(\left( {1,f,1}\right) §\left( {1,g,1}\right) { \rightarrow  }_{R}\left( {1,g,x}\right) §\left( {y,f,1}\right)\) or its opposite \(\left( {1,f,1}\right) §\left( {1,g,1}\right) { \leftarrow  }_{R}\left( {x,g,1}\right) §\left( {1,f,y}\right)\) . For the composition of two scalars \(a : 1 \rightarrow  1\) and \(b : 1 \rightarrow  1\) ,we can apply interchangers indefinitely \({a}_{9}^{ \circ  }b{ \rightarrow  }_{R}{b}_{9}^{ \circ  }a{ \rightarrow  }_{R}{a}_{9}^{ \circ  }b\) : this is the Eckmann-Hilton argument. Delpeuch and Vicary [VD22] give a quadratic solution to the word problem for free monoidal categories, i.e. deciding when two diagrams are equal. It is linear time in the connected case, and quadratic in the general case. The right interchanger is confluent and for connected diagrams, i.e. when the Eckmann-Hilton argument does not apply. It reaches a normal form in a cubic number of steps, the worst-case is given in example 1.3.7.</p>
<p>We have defined the equality of diagrams, there remains to define the tensor operation. First,we define the whiskering \(f \otimes  z\) of a diagram \(f\) by an object \(z \in  {\sum }_{0}^{ \star  }\) on the right: we tensor \(z\) to the right-hand side of each layer \(\left( {{x}_{i},{f}_{i},{y}_{i}}\right)\) , i.e. \(f \otimes  z = \left( {{x}_{1},{f}_{1},{y}_{1}z}\right) {}_{9}^{ \circ  }\cdots {}_{9}^{ \circ  }\left( {{x}_{n},{f}_{n},{y}_{n}z}\right)\) and symmetrically for the whiskering \(z \otimes  f\) on the left. Then,we can define the tensor \(f \otimes  g\) of two diagrams \(f : x \rightarrow  y\) and \(g : z \rightarrow  w\) in terms of whiskering \(f \otimes  g = f \otimes  z\) , \(g \otimes  g\) . Note that we could have chosen to define \(f \otimes  g = x \otimes  g\) ’ \(f \otimes  w\) ,the two definitions are equated by the interchanger.</p>
<p>Given a morphism of monoidal signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) ,we get a monoidal functor \(F\left( f\right)  : F\left( \sum \right)  \rightarrow  F\left( {\sum }^{\prime }\right)\) by relabeling: we have defined a functor \(F\) : MonSig \(\rightarrow\) MonCat. We now have to show that it is indeed the left adjoint of \(U : \mathbf{{MonCat}} \rightarrow\) MonSig. This is very similar to the monoid case. The unit \({\eta }_{\sum } : \sum  \rightarrow  U\left( {F\left( \sum \right) }\right)\) sends objects to themselves and boxes \(f : x \rightarrow  y \in  \sum\) to diagrams \(\left( {1,f,1}\right)  \in  L\left( \sum \right)\) ,i.e. the layer with empty lists on both sides of \(f\) . The counit \({\epsilon }_{C} : F\left( {U\left( C\right) }\right)  \rightarrow  C\) is the functor which sends diagrams with boxes in \(C\) to their evaluation,i.e. the formal composition and tensor of diagrams in \(F\left( {U\left( C\right) }\right)\) is sent to the concrete composition and tensor of arrows in \(C\) . In the next section,we will show that this construction is in fact equivalent to the topological definition of diagrams as labeled graphs embedded in the plane.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 65-->
<!-- Media -->
<p>Listing 1.2.21. Outline of the class monoidal.Ty.</p>
<hr>
<p>class Ty(0b):
def <em><strong><strong>init</strong></strong></em>(self, inside: Optional[tuple[Ob | str, ...]] = (   )):
self.inside = tuple(x if isinstance(x, 0b) else 0b(x) for x in inside)
name = ' @ '.join(map(str,inside)) if inside\ )
else "{}(   )".format(type(self).<em>name</em>_)
super(   ).<strong>init</strong>(name)
def tensor(self, *others: Ty) -> Ty:
if all (isinstance (other, Ty) for other in others):
inside = self.inside + sum([other.inside for other in others], (   ))
return self.cast(inside)
return NotImplemented # This will allow whiskering on the left.
def __getitem _ (self, key) :
if isinstance(key, slice):
return self.cast(self.inside[key])
return self.cast((self.inside[key], ))
<em><strong><strong>matmul</strong></strong></em> = <strong>add</strong> = tensor
___<strong>pow</strong> = lambda self, n: self.cast(n * self.inside)
____<em>len</em> = lambda self: len(self.inside)
cast = classmethod(lambda cls, inside: cls(inside))</p>
<hr>
<!-- Media -->
<p>The implementation of the class Ty for types (i.e. lists of objects) is straightforward, it is sketched in listing 1.2.21. The only subtlety is in the use of the class method cast which allows the tensor of objects in a subclass to stay within the subclass, without having to redefine the tensor method. We also use it to define indexing (which returns a type of length one), slicing and exponentiation by a natural number.</p>
<p>Example 1.2.22. We can define a Qubits subclass and be sure that the tensor of qubits is still an instance of Qubits, not merely Ty.</p><!-- Meanless: 66 1.2. Diagrams in Python-->
<hr>
<p>class Qubits(Ty) :
___<strong>str</strong> = lambda self: "qubit ** {}".format(len(self))
qubit = Qubits ( ' 1 ' )
nstance(qubit ** 0, Qubits) and isinstance(qubit ** 42, Qubits)</p>
<hr>
<p>The implementation of Layer as a subclass of cat. Box is sketched in listing 1.2.23. It has methods _____ matmul_____ and _____ rmatmul_ for whiskering on the right and left respectively, and cast for turning boxes into layers with units on both sides. We use empty slices of the box's domain as units, so that Layer can be used with any subclass of Ty as attributes. Instead of getting the units by calling Ty(   ) directly, we use the domain of the box to slice empty types of the appropriate Ty subclass. This will prove useful in sections 1.4.1, 1.4.6 and 1.5.3 where we will subclass Ty to define the types for free rigid, closed and 2-categories respectively.</p>
<!-- Media -->
<p>Listing 1.2.23. Outline of the class monoidal. Layer.</p>
<hr>
<p>class Layer (cat. Box):
def <strong>init</strong>(self, left: Ty, box: Box, right: Ty):
self.left, self.box, self.right = left, box, right
name = (" \(\{\) } @ ".format(left) if left else "") + box.name\
+ (" @ {}".format(right) if right else "")
dom, cod = left @ box.dom @ right, left @ box.cod @ right
super(   ). <em>init</em>(name, dom, cod)
def <em>matmul</em>(self, other: Ty) -> Layer:
return Layer (self.left, self.box, self.right @ other)
def <em>rmatmul</em>(self, other: Ty) -> Layer:
return Layer (other @ self.left, self.box, self.right)
def ___<strong>iter</strong>(self): yield self.left; yield self.box; yield self.right
@classmethod
def cast(cls, old: Box) -> Layer:
return cls(old.dom[:0], old, old.dom[len(old.dom):])</p>
<hr>
<!-- Media -->
<p>Now we have all the ingredients to define Diagram as a subclass of Arrow with instances of Layer as boxes. The tensor method is defined in terms of left and right whiskering of layers. The interchange method takes an integer</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 67-->
<p>i &#x3C; len (self) and returns the diagram with boxes i and i + 1 interchanged, or raises an AssertionError if they are connected. It also takes an optional argument left: bool which allows to choose between left and right in case we're interchanging an effect then a state. The normal_form method implements applies interchange until it reaches a normal form, or raises NotImplementedError if the diagram is disconnected. The draw method renders the diagram as an image, it implements the drawing algorithm discussed in the next section.</p>
<!-- Media -->
<p>Listing 1.2.24. Outline of the class monoidal. Diagram.</p>
<hr>
<p>class Diagram (cat. Arrow, Tensorable):
inside: tuple [Layer, ...]
dom: Ty
cod: Ty
@inductive
def tensor(self, other: Diagram) -> Diagram:
layers = tuple(layer @ other.dom for layer in self.inside)\
+ tuple(self.cod @ layer for layer in other.inside)
dom, cod = self.dom (c) other.dom, self.cod (c) other.cod
return self.cast(Diagram(layers, dom, cod))
def interchange(self, i: int, left=False) -> Diagram: ...
def normal_form(self, left=False) -> Diagram: ...
def draw(self, **params): ...</p>
<hr>
<!-- Media -->
<p>Again, we have a class method cast which takes an old cat. Arrow and turns it into a new object of type cls, a given subclass of Diagram. This means we do not need to repeat the code for identity or composition which is already implemented by cat. Arrow. In turn, when the user defines a subclass of Diagram, they do not need to repeat the code for identity, composition or tensor. The implementation of monoidal. Box as a subclass of cat. Box and Diagram is relatively straightforward, we only need to make sure that a box is equal to the diagram of just itself. We also want the cast method of Box to be that of Diagram.</p>
<!-- Media -->
<p>Listing 1.2.25. Outline of the class monoidal. Box.</p>
<hr>
<p>class Box (cat. Box, Diagram):
def <em><strong><strong>init</strong></strong></em>(self, name: str, dom: Ty, cod: Ty, **params):
cat.Box. _ init_( self, name, dom, cod, **params )
Diagram. <em><strong><strong>init</strong></strong></em>(self, (Layer.cast(self), ), dom, cod)
def <em><strong><strong>eq</strong></strong></em> (self, other):</p>
<hr>
<!-- Media --><!-- Meanless: 68 1.2. Diagrams in Python-->
<hr>
<pre><code>if isinstance(other, Box):
	return cat. Box. _ eq _ (self, other)
if isinstance(other, Diagram):
	return other.inside == (Layer.cast(self),)
return False
</code></pre>
<p><strong>hash</strong> = cat.Box.<strong>hash</strong>
cast = Diagram.cast</p>
<hr>
<p>Example 1.2.26. We can define Circuit as a subclass of Diagram. Gate, Bra and Ket are subclasses of Box and Circuit. Now we can compose and tensor gates together and the result will be an instance of Circuit.</p>
<!-- Media -->
<p>class Circuit (Diagram): pass</p>
<hr>
<p>class Gate (Box, Circuit): pass
class Bra (Box, Circuit) :
def <strong>init</strong>(self, *bits: bool):
name = "Bra({})".format(', '.join(map(str, bits)))
self.bits, dom, cod = bits, qubit ** len(bits), qubit ** 0
Box. _ init _ ( self, name, dom, cod )
def dagger(self) -> Circuit: return Ket(*self.bits)
class Ket (Box, Circuit) :
def <strong>init</strong>(self, *bits: bool):
name = "Ket \(\left( {\{ \} \text{'}}\right)\) ".format(', '.join(map(str,bits)))
self.bits, dom, cod = bits, qubit ** 0, qubit ** len(bits)
Box. _ init _ ( self , name , dom , cod )
def dagger(self) -> Circuit: return Bra(*self.bits)
Gate.cast = Ket.cast = Circuit.cast
\(X,Y,Z,H = \left\lbrack  \text{Gate (name,qubit,qubit) for name in "XYZH"]}\right\rbrack\)
CX = Gate("CX", qubit ** 2, qubit ** 2)
sqrt2 = Gate ( " $\\sqrt{2} $", qubit ** 0, qubit ** 0 )
assert isinstance(sqrt2 @ Ket \(\left( {0,0}\right)  >  > \mathrm{H}\) @ qubit \(>  > \mathrm{{CX}}\) ,Circuit)</p>
<hr>
<!-- Media -->
<p>The monoidal.Functor class is a subclass of cat.Functor. It overrides the <em><strong><strong>call</strong></strong></em> method to define the image of types and layers, and it delegates to its superclass for the image of boxes and composition. To make the syntax look nicer, we define the domain of the object mapping as types of length one rather than their generating object,e.g. we can define a functor with \(\mathrm{{ob}} = \{ \mathrm{x} : \mathrm{y}\}\) for \(\mathrm{x} = \operatorname{Ty}\left( {{}^{\prime }{\mathrm{x}}^{\prime }}\right)\) and \(\mathrm{y} = \mathrm{{Ty}}\left( {}^{\prime }\right) {\mathrm{y}}^{\prime }\) ) rather than \(\mathrm{{ob}} = \{ \mathrm{x}\) . inside [0] : \(\mathrm{y}\}\) . We also implement some syntactic sugar for the codomain so that we can define e.g. a Tensor-valued functor with \(\mathrm{{ob}} = \{ \mathrm{x} : \mathrm{n}\}\) rather than \(\mathrm{{ob}} = \{ \mathrm{x} : \left\lbrack  \mathrm{n}\right\rbrack  \}\) for \(\mathrm{a}\mathrm{x} = \operatorname{Ty}\left( {}^{\prime }\right) {\mathrm{x}}^{\prime }\) ) and \(\mathrm{n}\) : int. We make use of Python's duck typing so that the codomain can be Ty or tuple indifferently, in both cases computed using the built-in sum with Ty(   ) or (   ) as unit.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 69-->
<!-- Media -->
<p>Listing 1.2.27. Implementation of monoidal functors.</p>
<hr>
<p>class Functor(cat.Functor):
dom = cod = Category(Ty, Diagram)
def <em><strong><strong>call</strong></strong></em> (self, other : Ty | Diagram) -> Ty | Diagram:
if isinstance(other, Ty):
return sum ( [self (obj) for obj in other.inside], self.cod.ob(   ))
if isinstance(other, Ob):
result = self.ob[self.dom.ob((other, ))]
return result if isinstance(result, self.cod.ob)\
else self.cod.ob((result, ))
if isinstance(other, Layer):
return self(other.left) @ self(other.box) @ self(other.right)
return super(   ). <em><strong><strong>call</strong></strong></em>(other)</p>
<hr>
<!-- Media -->
<p>Note that the keys of the dictionary ob are Ty of length 1 .</p>
<p>Example 1.2.28. We can simulate quantum circuits by applying a functor from Circuit to Tensor. We override the _____ call_____ method to define the image of Bra and Ket on the fly.</p>
<!-- Media -->
<hr>
<p>class Eval (Functor):
def <strong>init</strong>(self, ob, ar):
super(   ).<strong>init</strong>(ob, ar,
dom \(=\) Category (Qubits,Circuit) ,
cod=Category(tuple[int, ...], Tensor[complex]))
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Ket):
if not other.bits: return Tensor.id((   ))
head, *tail = other.bits
return Tensor[complex] ([[not head, head]], (   ), (2, ))\
( self(Ket(*tail))
if isinstance(other, Bra):
return self(other.dagger(   )).dagger(   )</p>
<hr>
<!-- Media --><!-- Meanless: 70 1.2. Diagrams in Python-->
<hr>
<pre><code>	return super(   ). _call (other)
</code></pre>
<p>Circuit.eval = lambda self: Eval (   )
ob={qubit: 2},
\({ar} = \left\{  {X : \left\lbrack  {\left\lbrack  {0,1}\right\rbrack  ,\left\lbrack  {1,0}\right\rbrack  }\right\rbrack  ,Y : \left\lbrack  {\left\lbrack  {0, - {1j}}\right\rbrack  ,\left\lbrack  {{1j},0}\right\rbrack  }\right\rbrack  ,Z : \left\lbrack  {\left\lbrack  {1,0}\right\rbrack  ,\left\lbrack  {0, - 1}\right\rbrack  }\right\rbrack  ,}\right.\)
H: [[1 / sqrt(2), 1 / sqrt(2)], [1 / sqrt(2)]],
CX: [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]],
sqrt2: [[sqrt(2)]]})(self)
circuit = sqrt2 @ Ket \(\left( {0,0}\right)  >  > \mathrm{H}\) (   ) qubit \(>  > \mathrm{{CX}}\)
superposition \(= \operatorname{Ket}\left( {0,0}\right)  + \operatorname{Ket}\left( {1,1}\right)\)
assert circuit.eval(   ) == Circuit.eval(superposition)</p>
<hr>
<p>Remark 1.2.29. DisCoPy uses a more compact encoding of diagrams than their list of layers. Indeed, a diagram is uniquely specified by a domain, a list of boxes and a list of offsets, i.e. the length of the type to the left of each box.</p>
<!-- Media -->
<hr>
<p>@dataclass
class Encoding:
dom: Ty
boxes_and_offsets: tuple [tuple [Box, int], ...]
Diagram.boxes = property(lambda self: tuple(box for _, box, _ in self.inside))
Diagram.offsets = property (   )
lambda self: tuple(len(left) for left, _, _ in self.inside))
def encode (diagram: Diagram) -> Encoding:
return Encoding(diagram.dom, tuple(zip(diagram.boxes, diagram.offsets)))
def decode(encoding: Encoding) -> Diagram:
diagram = Diagram.id(encoding.dom)
for box, offset in encoding.boxes_and_offsets:
left, right = diagram.cod[:offset], diagram.cod[offset + len(box.dom):]
diagram >>= left @ box @ right
return diagram
\(\mathrm{x},\mathrm{y},\mathrm{z} = \operatorname{map}\left( {\mathrm{{Ty}},\text{"xyz"}}\right)\)
f, g, h = Box ('f', x, y), Box ('g', y, z), Box ('h', y @ z, x)
encoding = Encoding(dom=x @ y, boxes_and_offsets=((f, 0), (g, 1), (h, 0)))
assert decode (encoding) \(=  = \mathrm{f}@\mathrm{g} >  > \mathrm{h}\) and encode \(\left( {\mathrm{f}@\mathrm{g} >  > \mathrm{h}}\right)  =  =\) encoding</p>
<hr>
<!-- Media --><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 71-->
<h4>1.2.3 Quotient monoidal categories</h4>
<p>Once we have defined freeness,we need to define quotients. The quotient \(C/R\) of a monoidal category \(C\) by a binary relation \(R \subseteq  \mathop{\coprod }\limits_{{x,y \in  {C}_{0}^{ \star  }}}C\left( {x,y}\right)  \times  C\left( {x,y}\right)\) has the same objects \({C}_{0}\) and arrows equivalence classes of arrows in \({C}_{1}\) under the smallest monoidal congruence containing \(R\) . A congruence \(\left( { \sim  }_{R}\right)\) is monoidal when \(f{ \sim  }_{R}{f}^{\prime }\) and \(g{ \sim  }_{R}{g}^{\prime }\) implies \(f \otimes  g \sim  {f}^{\prime } \otimes  {g}^{\prime }\) . Explicitly,we can construct \(C/R\) as the quotient category for the rewriting relation \({ \rightarrow  }_{R}\) where:</p>
<p></p>\[u{}_{\mathfrak{g}}^{ \circ  }b \otimes  f \otimes  c{}_{\mathfrak{g}}^{ \circ  }v{ \rightarrow  }_{R}u{}_{\mathfrak{g}}^{ \circ  }b \otimes  g \otimes  c{}_{\mathfrak{g}}^{ \circ  }v\]<p></p>
<p>for all \(\left( {f,g}\right)  \in  R,u : a \rightarrow  b \otimes  \operatorname{dom}\left( f\right)  \otimes  c\) and \(v : b \otimes  \operatorname{cod}\left( f\right)  \otimes  c \rightarrow  d\) . Intuitively,if we can equate \(f\) and \(g\) then we can equate them in any context,i.e. with any objects \(b\) and \(c\) tensored on the left and right and any arrows \(u\) and \(v\) composed above and below. A proof that two diagrams are equal in the quotient can itself be thought of as a diagram in three dimensions, i.e. the movie of a diagram being rewritten into another. These higher-dimensional diagrams will be mentioned in section 1.6. Again,every monoidal category \(C\) is isomorphic to the quotient of a free monoidal category \(C = F\left( \sum \right) /R\) : take \(\sum  = U\left( C\right)\) and the relation \(R \subseteq  F\left( {U\left( C\right) }\right)  \times  F\left( {U\left( C\right) }\right)\) given by every binary composition and tensor.</p>
<p>The word problem for categories reduces to that of monoidal categories, indeed the signature of a category can be seen as a monoidal signature where boxes all have domain and codomain of length one. Thus, deciding equality of diagrams in arbitrary quotient monoidal categories is just as undecidable. The implementation of a quotient is nothing but a subclass of Diagram with an equality method that respects the axioms of a monoidal congruence. The easy way is to define equality of diagrams to be equality of their evaluation by a monoidal functor into a category where equality is decidable. The hard way is to define a normal_form method which sends every diagram to a chosen representative of its equivalence class. DisCoPy provides some basic tools to define such a normal form: pattern matching and substitution.</p>
<p>Listing 1.2.30. Implementation of diagram pattern matching and substitution.</p>
<hr>
<!-- Footnote -->
<hr>
<p>@dataclass
class Match:
top: Diagram
bottom: Diagram
left: Ty
right: Ty</p>
<hr>
<!-- Footnote -->
<hr><!-- Meanless: 72 1.2. Diagrams in Python-->
<hr>
<pre><code>def subs(self, target):
	return self.top >> self.left @ target @ self.right >> self.bottom
</code></pre>
<p>def match(self, pattern: Diagram) -> Iterator[Match]:
for i in range ( len ( self ) - len ( pattern ) + 1 ) :
for j in range ( len ( self [ i ] . dom ) - len (pattern.dom ) + 1 ) :
match = Match (   )
self[:i], self[i + len(pattern) :],
self[i].dom[:j], self[i].dom[j + len(pattern.dom) :])
well_typed = match.top.cod == match.left @ pattern.dom @ match.right\\
and match.left @ pattern.cod @ match.right == match.bottom.dom
if well_typed and self == match.subs(pattern): yield match</p>
<hr>
<p>Now implementing a quotient reduces to implementing a rewriting strategy, i.e. a function which inputs diagrams and returns either a choice of match or StopIteration, then proving that it is confluent (i.e. the order in which we pick matches does not matter) and terminating (i.e. there are no infinite sequences of rewrites). Our simple pattern matching routine can be extended in several ways. First, it can only find matches on the nose: we could apply interchangers to the diagram until we find a match (with the cubic-time complexity that this implies). Second, it can only find and substitute one match at a time: we could iterate through lists of compatible matches and implement their simultaneous substitution. Third, instead of looking for pattern as a subdiagram of self directly, we could iterate through the functors \(\mathrm{F}\) such that \(\mathrm{F}\) (pattern) is a subdiagram. This would allow to implement infinite families of equations such as those between quantum gates parameterised by continuous phases.</p>
<p>Why should computer scientists care about such diagram rewriting? One reason is that diagrams are free data structures in the same sense that lists are free: they are a two-dimensional generalisation of lists. Another reason is that they allow an elegant definition of a Turing-complete problem: given a finite monoidal signature \(\sum\) and a pair of lists \(x,y \in  {\sum }_{0}^{ \star  }\) ,decide whether there is a diagram \(f : x \rightarrow  y\) in \(F\left( \sum \right)\) . Indeed,the word problem for monoids (which is equivalent to the halting problem for Turing machines) reduces to the existence problem for diagrams: given the presentation of a monoid \({X}^{ \star  }/R\) ,take objects \({\sum }_{0} = X\) and boxes \({\sum }_{1} = R\) with dom,cod : \({\sum }_{1} \hookrightarrow  {X}^{ \star  } \times  {X}^{ \star  } \rightarrow  {X}^{ \star  }\) the left and right hand-side of each related pair. For any pair \(x,y \in  {X}^{ \star  }\) ,we have that \(x{ \leq  }_{R}y\) if and only if there is a diagram \(f : x \rightarrow  y\) in \(F\left( \sum \right)\) : the preordered monoid generated by the relation \(R\) is the preorder collapse of the free monoidal category \(F\left( \sum \right)\) . While monoid presentations define decision problems (i.e. with a Boolean output), free monoidal categories naturally define function problems: given a pair of types, output a diagram.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 73-->
<p>If we compose the two reductions together, we get a free monoidal category where diagrams are the possible runs of a given Turing machine. Moreover, a monoidal functor from the category of one machine to another corresponds to a reduction between the problems they solve, the domain machine being simulated by the codomain. Thus, we could very well take finite monoidal signatures as our definition of machine and diagrams as our definition of computation: algorithmic complexity is given by the size of signatures, time and space complexity are given by the length and width \({}^{1}\) of diagrams. Now if two-dimensional diagrams encode computations on one-dimensional lists, we can think of three-dimensional diagrams either as computations on two-dimensional data, or as higher-order computations. For example, the optimisation steps of a (classical or quantum) compiler can be thought of as a three-dimensional diagram, with (classical or quantum) circuits as domain and codomain.</p>
<p>Example 1.2.31. We can simplify quantum circuits using pattern matching.</p>
<!-- Media -->
<hr>
<p>def simplify(circuit, rules):
for source, target in rules:
for match in circuit.match(source):
return simplify (match.subs(target), rules)
return circuit
rules = [(Ket(b) >> X, Ket(int(not b)))
for b in \(\left\lbrack  {0,1}\right\rbrack  \rbrack  + \lbrack\)
(Ket(b0) @ Ket(b1) >> CX, Ket(b0) @ Ket(int(not b1 if b0 else b1)))
for b0 in \(\left\lbrack  {0,1}\right\rbrack\) for b1 in \(\left\lbrack  {0,1}\right\rbrack\) ]
circuit = Ket(1) @ Ket(0) >> CX >> qubit @ X
assert simplify(circuit, rules) == Ket(1) >> qubit @ Ket(0)</p>
<hr>
<!-- Media -->
<h4>1.2.4 Daggers, sums and bubbles</h4>
<p>As in the previous section, we introduce three extra pieces of implementation: daggers,sums and bubbles. A \(\dagger\) -monoidal category is a monoidal category with a dagger (i.e. an identity-on-objects involutive contravariant endofunctor) that is also a monoidal functor, a †-monoidal functor is both a †-functor and a monoidal functor. They are implemented by adding a dagger method to the Layer class. For example,Tensor \({}_{\mathbb{S}}\) is \(\dagger\) -monoidal with any conjugate transpose as dagger. The category \({\mathbf{{Mat}}}_{\mathbb{S}}\) with direct sum as tensor is also \(\dagger\) -monoidal.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) The width of a diagram is the maximum width of its layers,which is not preserved by interchangers. In the diagrams generated by Turing machines, we cannot apply interchangers anyway: every box is connected to the next by the head of the machine.</p>
<!-- Footnote -->
<hr><!-- Meanless: 74 1.2. Diagrams in Python-->
<!-- Media -->
<p>Listing 1.2.32. Implementation of free \(\dagger\) -monoidal categories.</p>
<hr>
<p>class Layer:
...
def dagger(self) -> Layer:
return Layer ( self.left, self.box.dagger (   ), self.right )</p>
<hr>
<!-- Media -->
<p>A monoidal category is commutative-monoid-enriched when sums distribute over the tensor, i.e.</p>
<p></p>\[\left( {f + {f}^{\prime }}\right)  \otimes  \left( {g + {g}^{\prime }}\right)  = f \otimes  g + f \otimes  {g}^{\prime } + {f}^{\prime } \otimes  g + {f}^{\prime } \otimes  {g}^{\prime }\]<p></p>
<p></p>\[\text{and}f \otimes  0 = 0 = 0 \otimes  f\]<p></p>
<p>They are implemented by a adding method a tensor method to Sum, as well as overriding Diagram.tensor so that \(\mathrm{f}@\left( {\mathrm{g} + \mathrm{h}}\right)  =  =\) Sum.cast \(\left( \mathrm{f}\right) @\left( {\mathrm{g} + \mathrm{h}}\right)\) for all diagrams \(\mathrm{f}\) .</p>
<!-- Media -->
<p>Listing 1.2.33. Implementation of free CM-enriched monoidal categories.</p>
<hr>
<p>class Diagram (monoidal.Diagram) :
@inductive
def tensor(self, other):
return self.sum.cast(self).tensor(other)\
if isinstance(other, Sum) else super(   ).tensor(other)
class Sum (cat. Sum, Box):
@inductive
def tensor(self,other: Sum) -> Sum:
terms = tuple(f @ g for f in self.terms for g in self.cast(other).terms)
return Sum(terms, self.dom @ other.dom, self.cod @ other.cod)
id = lambda x: Sum.cast(Diagram.id(x))
Diagram.sum = Sum</p>
<hr>
<!-- Media -->
<p>Bubbles for monoidal categories are the same as bubbles for categories, their implementation requires no extra work. As we mentioned in the previous section, bubbles do give us a strictly more expressive syntax however: they can encode operations on arrows that cannot be expressed in terms of composition or tensor.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 75-->
<!-- Media -->
<p>Listing 1.2.34. Implementation of free monoidal categories with bubbles.</p>
<hr>
<pre><code>class Bubble (cat. Bubble, Box): pass
</code></pre>
<p>Diagram.bubble = lambda self, **kwargs: Bubble(self, **kwargs)</p>
<hr>
<!-- Media -->
<p>Example 1.2.35. As in example 1.1.30,any monoidal endofunctor \(\beta  : C \rightarrow  C\) also defines a bubble on the monoidal category \(C\) ,we can define a bubble-preserving functor \(F\left( {U{\left( C\right) }^{\beta }}\right)  \rightarrow  C\) which interprets bubbled diagrams as functor application. However,the disjoint union \(C + D\) of two monoidal categories does not yield a well-defined monoidal category: we cannot tensor arrows of \(C\) with those of \(D\) . Thus,the case of monoidal functors \(C \rightarrow  D\) requires diagrams with different colours (for the inside and the outside of the bubble) which we will mention in section 1.4.</p>
<p>Example 1.2.36. We can implement the Born rule as a bubble on Circ interpreted as element-wise squared amplitude. We can also implement any classical postprocessing as a bubble.</p>
<!-- Media -->
<hr>
<p>Born_rule = lambda x: abs(x) ** 2
Circuit.measure = lambda self: self.bubble(method="squared_amplitude")
Tensor.squared_amplitude = lambda self: self.map(Born_rule)
assert Circuit.eval((Ket(0) >> H >> Bra(0)).measure(   ))[0][0] == .5
biased_ReLU = lambda x : max \(\left( {0,2 * \text{x.real - 1}}\right)\)
Circuit.post_process = lambda self: self.bubble(method="non_linearity")
Tensor.non_linearity = lambda self: self.map(biased_ReLU)
circuit = Ket \(\left( {0,0}\right)  >  > \mathrm{H}@\) qubit \(>  > \mathrm{{CX}} >  > \operatorname{Bra}\left( {0,0}\right)\)
post_processed_circuit = circuit.measure(   ).post_process(   )
assert Circuit.eval(post_processed_circuit).inside\\
== biased_ReLU(Born_rule(complex(circuit.eval(   ))))</p>
<hr>
<!-- Media -->
<p>Example 1.2.37. We can implement the formulae of first-order logic using Peirce's existential graphs. They are the first historical examples of string diagrams as well as the first definition of first-order logic [BT98; BT00; MZ16; HS20]. Predicates of arity \(n\) are boxes with a codomain of length \(n\) ,if there are more than one generating objects we get a many-sorted logic. The wires of the diagram correspond to variables, open wires in the domain and codomain are free variables, the others are existentially quantified. Thus,the composition of the diagrams \(f : x \rightarrow  y\) and \(g : y \rightarrow  z\) encodes the formula \(\exists y\left( {x,y}\right)  \land  g\left( {y,z}\right)\) with two free variables \(x,z\) and \(y\) bound. The diagram obtained by composing a predicate \(p\) with the dagger of a predicate \(q\) encodes the formula \(\exists xp\left( x\right)  \land  q\left( x\right)\) . Bubbles,which Peirce calls cuts,encode negation. The evaluation of a formula in a finite model corresponds to the application of a bubble-preserving functor into \({\mathbf{{Mat}}}_{\mathbb{B}}\) .</p><!-- Meanless: 76 1.2. Diagrams in Python-->
<!-- Media -->
<hr>
<p>class Formula(Diagram):
cut = lambda self: Cut(self)
class Cut (Bubble, Formula) :
method = "_not"
cast = Formula.cast
class Predicate (Box, Formula):
cast = Formula.cast
def model(size: dict[Ty, int], data: dict[Predicate, list[bool]]):
return Functor (   )
ob=size, ar={p: [data[p]] for p in data},
dom = Category (Ty, Formula), cod = Category (tuple [ int , ...] , Tensor [ bool] ) )
\(\mathrm{x} = \mathrm{{Ty}}\left( {{}^{\prime }{\mathrm{x}}^{\prime }}\right)\)
dog, god, mortal = [Predicate(name, Ty(   ), x) for name in ("dog", "god", "mortal")]
all_dogs_are_mortal = (dog.cut(   ) >> mortal.dagger(   )).cut(   )
gods_are_not_mortal = (god >> mortal.dagger(   )).cut(   )
there_is_no_god_but_god = god >> (Formula.id(x).cut(   ) >> god.dagger(   )).cut(   )
size = {x: 2}
for dogs, gods, mortals in itertools.product (*3 * [
itertools.product(*size[x] * [[0, 1]])]):
F = model(size, {dog: dogs, god: gods, mortal: mortals})
assert F(all_dogs_are_mortal) == all(   )
not \(F\left( {dog}\right) \left\lbrack  i\right\rbrack\) or \(F\left( \text{mortal}\right) \left\lbrack  i\right\rbrack\) for i in range \(\left( {\operatorname{size}\left\lbrack  x\right\rbrack  }\right)\) )
assert F(gods_are_not_mortal) == all (   )
not \(F\left( {god}\right) \left\lbrack  i\right\rbrack\) or not \(F\left( {mortal}\right) \left\lbrack  i\right\rbrack\) for i in range \(\left( {\operatorname{size}\left\lbrack  x\right\rbrack  }\right)\) )
assert F(there_is_no_god_but_god) == any(F(god)[i] and not any(   )
F(god)[j] and \(j\) !== i for \(j\) in range(size[x])) for i in range(size[x]))</p>
<hr>
<!-- Media -->
<p>Note that for now our syntax is somehow limited: we can only write formulae where each variable appears at most twice, once for the source and target of its wire. In section 1.4.3 we will introduce the diagrammatic syntax for arbitrary formulae, essentially by adding explicit boxes for equality.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 77-->
<h4>1.2.5 From tacit to explicit programming</h4>
<p>We get to the end of this section and the reader may have noticed that we have not drawn a single diagram yet: drawing will be the topic of the next section. This absence of drawing intends to demonstrate that diagrams are not only a great tool for visual reasoning, they can also be thought of as a data structure for abstract pipelines. Monoidal functors then allow to evaluate these abstract pipelines in terms of concrete computation, be it Python functions, tensor operations or quantum circuits. This abstract programming style, defining programs in terms of composition rather than arguments-and-return-value, is called point-free or tacit programming. Because of the difficulty of writing any kind of complex program in that way, it has also been called the pointless style. DisCoPy provides a @diagramize decorator which allows the user to define diagrams using the standard explicit syntax for Python functions instead of the point-free syntax. Given dom: Ty, cod: Ty and signature: tuple [Box, ...] as parameters, it adds to each box a _____ call_____ method which takes the objects of its domain as input and returns the objects of its codomain.</p>
<!-- Media -->
<p>Example 1.2.38. We can define quantum circuits as Python functions on qubits.</p>
<hr>
<p>kets0 = Ket(0,0)
@diagramize(dom = Qubits(2), cod = Qubits(2), signature = (sqrt2, kets0, H, CX))
def circuit(   ):
sqrt2(   ); qubit0, qubit1 = kets0
return CX ( H ( qubit 0 ) , qubit 1 )
assert circuit == sqrt2 @ kets0 >> H @ qubit >> CX</p>
<hr>
<!-- Media -->
<p>The underlying algorithm constructs a graph with nodes for each object of the domain and the codomain of each box, as well as of the whole diagram. There is an edge from a codomain node of a box (or a domain node of the whole diagram) to the domain node of another (or a codomain node of the whole diagram) whenever they are connected. There is also a node for each box and an edge from that box node to its domain and codomain nodes. First, we initialise the graph of the identity diagram and feed the objects of its codomain as input to the decorated function. When a box is applied to a list of nodes, it adds edges going into each object of its domain and returns nodes for each object of its codomain. Finally, the return value of the decorated function is taken as the codomain of the whole diagram.</p>
<p>The graph2diagram algorithm which translates the resulting graph into a diagram will be covered in the next section. It will allow to automatically read pictures of diagrams (i.e. matrices of pixels) and translate them into Diagram objects. Listing 1.2.39 shows the implementation of the inverse translation diagram2graph which outputs only planar graphs as we will show in the next section by constructing their embedding in the plane, i.e. their drawing.</p><!-- Meanless: 78 1.2. Diagrams in Python-->
<p>Listing 1.2.39. Translation from Diagram to Graph.</p>
<p>We use the graph data structure from NetworkX [HSS08].</p>
<!-- Media -->
<p>from networkx import Graph</p>
<hr>
<p>@dataclass
class Node:
kind: str
label: Ty | Box
i: int
j: int
def diagram2graph(diagram: Diagram) -> Graph:
graph = Graph (   )
scan = [Node('dom', x, i, -1) for i, x in enumerate(diagram.dom)]
graph.add_edges_from(zip(scan, scan))
for j, (left, box, _) in enumerate(diagram.inside):
box_node = Node('box', box, -1, j)
dom_nodes = [Node('dom', x, i, j) for i, x in enumerate(box.dom)]
cod_nodes = [Node('cod', x, i, j) for i, x in enumerate(box.cod)]
graph.add_edges_from(zip(scan[len(left): len(left @ box.dom)], dom_nodes))
graph.add_edges_from(zip(dom_nodes, len(box.dom) * [box_node]))
graph.add_edges_from(zip(len(box.cod) * [box_node], cod_nodes))
scan = scan[len(left) :] + cod_nodes + scan[len(left @ box.dom) :]
graph.add_edges_from(zip(scan, [
Node('cod', x, i, len(diagram)) for i, x in enumerate(diagram.cod)))
return graph</p>
<hr>
<!-- Media -->
<p>Note that in order to construct a monoidal. Diagram we need to assume plane graphs as input, i.e. graphs with an embedding in the plane. This means the diagramize method cannot accept functions which swap the order of variables such as lambda \(\mathrm{x},\mathrm{y} : \mathrm{y},\mathrm{x}\) . We also need to assume that every codomain node is connected to exactly one domain node. In terms of Python functions, this means we have to use every variable exactly once. In section 1.4 we will discuss the case of diagrams induced by non-planar graphs, with potentially multiple edges between domain and codomain nodes.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 79-->
<h3>1.3 Drawing &#x26; reading</h3>
<p>The previous section defined diagrams as a data structure based on lists of layers, in this section we define pictures of diagrams. Concretely, such a picture will be encoded in a computer memory as a bitmap, i.e. a matrix of colour values. Abstractly, we will define these pictures in terms of topological subsets of the Cartesian plane. We first recall the topological definition from Joyal's and Street's unpublished manuscript Planar diagrams and tensor algebra [JS88] and then discuss the isomorphism between the two definitions. In one direction, the isomorphism sends a Diagram object to its drawing. In the other direction, it reads the picture of a diagram and translates it into a Diagram object, i.e. its domain, codomain and list of layers.</p>
<h4>1.3.1 Labeled generic progressive plane graphs</h4>
<p>A topological graph,also called 1-dimensional cell complex,is a tuple \(\left( {G,{G}_{0},{G}_{1}}\right)\) of a Hausdorff space \(G\) and a pair of a closed subset \({G}_{0} \subseteq  G\) and a set of open subsets \({G}_{1} \subseteq  P\left( G\right)\) called nodes and wires respectively,such that:</p>
<ul>
<li>
<p>\({G}_{0}\) is discrete and \(G - {G}_{0} =  \cup  {G}_{1}\) ,</p>
</li>
<li>
<p>each wire \(e \in  {G}_{1}\) is homeomorphic to an open interval and its boundary is contained in the nodes \(\partial e \subseteq  {G}_{0}\) .</p>
</li>
</ul>
<p>From a topological graph \(G\) ,one can construct an undirected graph in the usual sense by forgetting the space \(G\) ,taking \({G}_{0}\) as nodes and edges \(\left( {x,y}\right)  \in  {G}_{0} \times  {G}_{0}\) for each \(e \in  {G}_{1}\) with \(\partial e = \{ x,y\}\) . A topological graph is finite (planar) if its undirected graph is finite (planar, i.e. there is some embedding in the plane).</p>
<p>A plane graph between two real numbers \(a &#x3C; b\) is a finite,planar topological graph \(G\) with an embedding in \(\mathbb{R} \times  \left\lbrack  {a,b}\right\rbrack\) . We define the domain \(\operatorname{dom}\left( G\right)  = {G}_{0} \cap  \mathbb{R} \times  \{ a\}\) , the codomain \(\operatorname{cod}\left( G\right)  = {G}_{0} \cap  \mathbb{R} \times  \{ b\}\) as lists of nodes ordered by horizontal coordinates and the set boxes \(\left( G\right)  = {G}_{0} \cap  \mathbb{R} \times  \left( {a,b}\right)\) . We require that:</p>
<ul>
<li>
<p>\(G \cap  \mathbb{R} \times  \{ a\}  = \operatorname{dom}\left( G\right)\) and \(G \cap  \mathbb{R} \times  \{ b\}  = \operatorname{cod}\left( G\right)\) ,i.e. the graph touches the horizontal boundaries only at domain and codomain nodes,</p>
</li>
<li>
<p>every domain and codomain node \(x \in  G \cap  \mathbb{R} \times  \{ a,b\}\) is in the boundary of exactly one wire \(e \in  {G}_{1}\) ,i.e. wires can only meet at box nodes.</p>
</li>
</ul>
<p>A plane graph is generic when the projection on the vertical axis \({p}_{1} : \mathbb{R} \times  \mathbb{R} \rightarrow  \mathbb{R}\) is injective on \({G}_{0} - \mathbb{R} \times  \{ a,b\}\) ,i.e. no two box nodes are at the same height. From a generic plane graph,we can get a list boxes \(\left( G\right)  \in  {G}_{0}^{ \star  }\) ordered by height. A plane graph is progressive (also called recumbent by Joyal and Street) when \({p}_{1}\) is injective on each wire \(e \in  {G}_{1}\) ,i.e. wires go from top to bottom and do not bend backwards.</p><!-- Meanless: 80 1.3. Drawing & reading-->
<p>From a progressive plane graph \(G\) ,one can construct a directed graph by forgetting the space \(G\) ,taking \({G}_{0}\) as nodes and edges \(\left( {x,y}\right)  \in  {G}_{0} \times  {G}_{0}\) for each \(e \in  {G}_{1}\) with \(\partial e = \{ x,y\}\) and \({p}_{1}\left( x\right)  &#x3C; {p}_{1}\left( y\right)\) . We can also define the domain and the codomain of each box node dom, \(\operatorname{cod} :\) boxes \(\left( G\right)  \rightarrow  {G}_{1}^{ \star  }\) with \(\operatorname{dom}\left( x\right)  = \{ e \in\) \({G}_{1} \mid  \partial e = \left\{  {x,y}\right\}  ,{p}_{1}\left( x\right)  &#x3C; {p}_{1}\left( y\right) \}\) the wires coming in from the top and \(\operatorname{cod}\left( x\right)  = \{ e \in\) \({G}_{1}\left| {\partial e = \{ x,y\} ,{p}_{1}\left( x\right)  > {p}_{1}\left( y\right) \} \text{the wires going out to the bottom,these sets are}}\right|\) linearly ordered as follows. Take some \(\epsilon  > 0\) such that the horizontal line at height \({p}_{1}\left( x\right)  - \epsilon\) crosses each of the wires in the domain. Then list \(\operatorname{dom}\left( x\right)  \in  {G}_{1}^{ \star  }\) in order of horizontal coordinates of their intersection points,i.e. \(e &#x3C; {e}^{\prime }\) if \({p}_{0}\left( y\right)  &#x3C; {p}_{0}\left( {y}^{\prime }\right)\) for the projection \({p}_{0} : \mathbb{R} \times  \mathbb{R} \rightarrow  \mathbb{R}\) and \({y}^{\left( \prime \right) } = {e}^{\left( \prime \right) } \cap  \left\{  {{p}_{1}\left( x\right)  - \epsilon }\right\}   \times  \mathbb{R}\) . Symmetrically we define the list of codomain nodes \(\operatorname{cod}\left( x\right)  \in  {G}_{1}^{ \star  }\) with a horizontal line at \({p}_{1} + \epsilon\) .</p>
<p>A labeling of progressive plane graph \(G\) by a monoidal signature \(\sum\) is a pair of functions from wires to objects \(\lambda  : {G}_{1} \rightarrow  {\sum }_{0}\) and from boxes to boxes \(\lambda\) : boxes \(\left( G\right)  \rightarrow  {\sum }_{1}\) which commutes with the domain and codomain. From an lgpp (labeled generic progressive plane) graph, one can construct a Diagram.</p>
<!-- Media -->
<p>Listing 1.3.1. Reading a labeled generic progressive plane graphs as a Diagram.</p>
<hr>
<p>def read( \(G,\lambda  : {G}_{1} \rightarrow\) Ty, \(\lambda  : \operatorname{boxes}\left( G\right)  \rightarrow\) Box ) -> Diagram:
dom \(= \left\lbrack  {\lambda \left( e\right) }\right.\) for \(x \in  \operatorname{dom}\left( G\right)\) for \(\left. {e \in  {G}_{1}\text{if}x \in  \partial e}\right\rbrack\)
boxes \(= \left\lbrack  {\lambda \left( x\right) \text{ for }x \in  \operatorname{boxes}\left( G\right) }\right\rbrack\)
offsets = [len( \({G}_{1} \cap  \left\{  {{p}_{0}\left( x\right) }\right\}   \times  \mathbb{R}\) ) for \(x \in  \operatorname{boxes}\left( G\right)\) ]
return decode(dom, zip(boxes, offsets))</p>
<hr>
<!-- Media -->
<h4>1.3.2 From diagrams to graphs and back</h4>
<p>In the other direction, there are many possible ways to draw a given Diagram as a lgpp graph, i.e. to embed its graph into the plane. Vicary and Delpeuch [VD22] give a linear-time algorithm to compute such an embedding with the following disadvantage: the drawing of a tensor \(f \otimes  g\) does not necessarily look like the horizontal juxtaposition of the drawings for \(f\) and \(g\) . For example,if we tensor an identity with a scalar, the wire representing the identity will wiggle around the node representing the scalar. DisCoPy uses a quadratic-time drawing algorithm with the following design decision: we make every wire a straight line and as vertical as possible. We first initialise the lgpp graph of the identity with a constant spacing between each wire, then for each layer we update the embedding so that there is enough space for the output wires of the box before we add it to the graph. The resulting plane graph is then either plotted on the screen using Matplotlib [Hun07] or translated to TikZ [Tan13] code that can be integrated to a LTEX document. All the diagrams in this thesis were drawn using DisCoPy together with \({\mathrm{{TikZiT}}}^{1}\) for manual editing.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 81-->
<!-- Media -->
<p>Listing 1.3.2. Outline of Diagram.draw from Diagram to PlaneGraph.</p>
<p>Embedding = dict[Node, tuple[float, float]]</p>
<hr>
<p>PlaneGraph = tuple [Graph, Embedding]
def make_space(position: Embedding, scan: list[Node], box: Box, offset: int
) -> tuple [Embedding, float] :
""" Update the graph to make space and return the left of the box. """
def draw(self: Diagram) -> PlaneGraph:
graph = diagram2graph(self)
box_nodes = [Node('box', box, -1, j) for j, box in enumerate(self.boxes)]
dom_nodes = scan = [Node('dom', x, i, -1) for i, x in enumerate(self.dom)]
position = {node: (i,-1) for i, node in enumerate(dom_nodes)}
for j, (left, box, _) in enumerate(self.inside):
box_node = Node('box', box, -1, j)
position, left_of_box = make_space(position, scan, box, len(left))
position [box_node] = (   )
left_of_box + max(len(box.dom), len(box.cod)) / 2, j)
for i, \(x\) in enumerate (box.dom):
cod_node, = filter(lambda node: node.kind != "box",
graph.neighbors(Node('dom', x, i, j)))
position \(\left\lbrack  {\text{Node}\left( {{}^{\prime }{\mathrm{{dom}}}^{\prime },\mathrm{x},\mathrm{i},\mathrm{j}}\right) }\right\rbrack   = \left( {\text{position}\left\lbrack  \text{cod_node}\right\rbrack  \left\lbrack  0\right\rbrack  ,\mathrm{j} - {.1}}\right)\)
for i, \(x\) in enumerate(box.cod):
position[Node('cod', x, i, j)] = (left_of_box + i, j + .1)
box_cod_nodes = [Node('cod', x, i, j) for i, x in enumerate(box.cod)]
scan = scan[:len(left)] + box_cod_nodes + scan[len(left @ box.dom) :]
for i, \(\mathrm{x}\) in enumerate (self.cod):
cod_node = Node('cod', x, i, len(self))
position[cod_node] = (position[scan[i]][0], len(self))
return graph, position</p>
<hr>
<p>Diagram.draw = draw</p>
<!-- Media -->
<hr>
<!-- Footnote -->
<p>1<a href="https://tikzit.github.io">https://tikzit.github.io</a></p>
<!-- Footnote -->
<hr><!-- Meanless: 82 1.3. Drawing & reading-->
<p>Note that when we draw the plane graph for a diagram, we do not usually draw the box nodes as points. Instead, we draw them as boxes, i.e. a box node \(x \in  \operatorname{boxes}\left( G\right)\) is depicted as the rectangle with corners \(\left( {l,{p}_{1}\left( x\right)  \pm  \epsilon }\right)\) and \(\left( {r,{p}_{1}\left( x\right)  \pm  \epsilon }\right)\) for \(l,r \in  \mathbb{R}\) the left- and right-most coordinate of its domain and codomain nodes. In this way, we do not need to draw the in- and out-going wires of the box node: they are hidden by the rectangle. Exceptions include spider boxes where we draw the box node (the head) and its outgoing wires (the legs of the spider) as well as swap, cup and cap boxes where we do not draw the box node at all, only its outgoing wires which are drawn as Bézier curves to look like swaps, cups and caps respectively. These special boxes will be discussed, and drawn, in section 1.4.</p>
<p>Example 1.3.3. Drawing of a box, an identity, a layer, a composition and a tensor.</p>
<hr>
<pre><code>a, b, c, x, y, z, w = map(Ty, "abcxyzw")
</code></pre>
<p>\(\operatorname{Box}\left( {{}^{\prime }{\text{box}}^{\prime },a@b,x@y@z}\right) .\operatorname{draw}\left( \right)\)</p>
<hr>
<!-- Media -->
<!-- figureText: box b -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_81.jpg?x=669&#x26;y=1027&#x26;w=230&#x26;h=115&#x26;r=0">
<!-- Media -->
<p>Diagram.id(x @ y @ z).draw(   )</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_81.jpg?x=674&#x26;y=1252&#x26;w=222&#x26;h=115&#x26;r=0">
<!-- Media -->
<hr>
<p>layer = a @ Box ('f', x, y) @ b
layer.draw(   )</p>
<hr>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_81.jpg?x=673&#x26;y=1525&#x26;w=222&#x26;h=118&#x26;r=0">
<!-- Media -->
<p>top, bottom = Box('top', a @ b, x @ y @ z), Box('bottom', x @ y @ z, c) (top >> bottom).draw(   )</p>
<!-- Media -->
<!-- figureText: top b 乙 X bottom -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_81.jpg?x=669&#x26;y=1796&#x26;w=233&#x26;h=194&#x26;r=0">
<!-- Media -->
<hr>
<p>left, right = Box('left', a @ b, x @ y @ z), Box('right', x @ y @ z, c)
(left @ right).draw(   )</p>
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 83-->
<!-- Media -->
<!-- figureText: a \( X \) y right left X \( y \) Z -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_82.jpg?x=631&#x26;y=287&#x26;w=466&#x26;h=193&#x26;r=0">
<!-- Media -->
<p>Example 1.3.4. Drawing of the interchanger in the general case.</p>
<p>f, \(\mathrm{g} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{g}}^{\prime },\mathrm{z},\mathrm{w}}\right)\)</p>
<p>(a @ f @ b @ g @ c).interchange(0).draw(   ); (a @ f @ b @ g @ c).draw(   )</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_82.jpg?x=400&#x26;y=704&#x26;w=925&#x26;h=195&#x26;r=0">
<!-- Media -->
<p>Example 1.3.5. Drawing of the interchangers for an effect then a state.</p>
<hr>
<p>f, g = Box('f', x, Ty(   )), Box('g', Ty(   ), w)
(f >> g). interchange(0).draw(   )
(f >> g).draw(   )
(f >> g).interchange (0, left=True).draw(   )</p>
<hr>
<!-- Media -->
<!-- figureText: X \( \rightarrow  R \) \( \rightarrow  R \) f -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_82.jpg?x=494&#x26;y=1206&#x26;w=742&#x26;h=189&#x26;r=0">
<!-- Media -->
<p>Example 1.3.6. Drawing of the Eckmann-Hilton argument.</p>
<hr>
<p>f, g = Box('f', Ty(   ), Ty(   )), Box('g', Ty(   ), Ty(   ))
(f @ g).draw(   )
(f @ g).interchange(0).draw(   )
(f @ g).interchange(0).interchange(0).draw(   )</p>
<hr>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_82.jpg?x=475&#x26;y=1714&#x26;w=781&#x26;h=141&#x26;r=0">
<!-- Media -->
<p>Example 1.3.7. The following spiral diagram is the cubic worst-case for interchanger normal form. It is also the quadratic worst-case for drawing, at each layer of the first half we need to update the position of every preceding layer in order to make space for the output wires.</p><!-- Meanless: 84 1.3. Drawing & reading-->
<hr>
<p>\(\mathrm{x} = \mathrm{{Ty}}\left( {1{\mathrm{x}}^{\prime }}\right)\)
f, g = Box ('f', Ty(   ), x @ x), Box ('g', x @ x, Ty(   ))
\(\mathrm{u},\mathrm{v} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{u}}^{\prime },\mathrm{{Ty}}\left( \right) ,\mathrm{x}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{v}}^{\prime },\mathrm{x},\mathrm{{Ty}}\left( \right) }\right)\)
def spiral (length: int) -> Diagram:
diagram, \(\mathrm{n} = \mathrm{u}\) ,length \(//2 - 1\)
for i in range(n):
diagram >>= x ** i @ f @ x ** (i + 1)
diagram >>= x ** n @ v @ x ** n
for i in range(n):
diagram >>= x ** (n - i - 1) @ g @ x ** (n - i - 1)
return diagram
diagram = spiral ( 8 )
for i in \(\left\lbrack  {1,2,3}\right\rbrack\) : diagram \(\left\lbrack  { : i + 1}\right\rbrack\) .draw(   )
diagram.draw(   ); diagram.normal_form(   ).draw(   )
Diagram.to_gif(*diagram.normalize(   ))</p>
<hr>
<!-- Media -->
<!-- figureText: f ✘ X X f X f f f X f X X f f X X g g g -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_83.jpg?x=196&#x26;y=1096&#x26;w=1188&#x26;h=804&#x26;r=0">
<!-- Media -->
<p>The interchangers between these two diagrams can be downloaded as a . gif \({}^{1}\) video.</p>
<p>Next, we define the inverse translation graph2diagram.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) <a href="https://github.com/oxford-quantum-group/discopy/.../imgs/spiral.gif">https://github.com/oxford-quantum-group/discopy/.../imgs/spiral.gif</a></p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 85-->
<!-- Media -->
<p>Listing 1.3.8. Translation from PlaneGraph to Diagram.</p>
<hr>
<p>def graph2diagram(graph: Graph, position: Embedding) -> Diagram:
dom = Ty (*[node.label for node in graph.nodes
if node.kind == 'dom' and node.j == -1])
boxes = [node.label for node in graph.nodes if node.kind == 'box']
scan, offsets = [Node('dom', x, i, -1) for i, x in enumerate(dom)], []
for j, box in enumerate(boxes):
left_of_box = position[Node('dom', box.dom[0], 0, j)][0]\
if box.dom else position[Node ('box', box, -1, j)] [0]
offset = len ( [node for node in scan if position[node] [0] &#x3C; left_of_box] )
box_cod_nodes = [Node('cod', x, i, j) for i, x in enumerate(box.cod)]
scan = scan[:offset] + box_cod_nodes + scan[offset + len(box.dom) :]
offsets.append(offset)
return decode(Encoding(dom, list(zip(boxes, offsets)))</p>
<hr>
<!-- Media -->
<p>Proposition 1.3.9. The equality graph2diagram(self.draw(   )) == self holds for all self: Diagram.</p>
<p>Proof. By induction on \(\mathrm{n} =\) len (self). If \(\mathrm{n} =  = 0\) we get that dom \(=  =\) self.dom and boxes == offsets == []. If the proposition holds for self, then it holds for self >> Layer (left, box, right). Indeed, we have:</p>
<hr>
<ul>
<li>dom == self.dom and boxes == self.boxes + [box]</li>
<li>(x, Node('cod', self.cod[i], i, n)) in graph
for i, \(x\) in enumerate (scan)</li>
</ul>
<hr>
<p>Moreover, the horizontal coordinates of the nodes in scan are strictly increasing, thus we get the desired offsets == self.offsets + [len(left)].</p>
<p>From a labeled generic progressive plane graph, we get a unique diagram up to deformation. A deformation \(h : G \rightarrow  {G}^{\prime }\) between two labeled plane graphs \(G,{G}^{\prime }\) is a continuous map \(h : G \times  \left\lbrack  {0,1}\right\rbrack   \rightarrow  \mathbb{R} \times  \mathbb{R}\) such that:</p>
<ul>
<li>
<p>\(h\left( {G,t}\right)\) is a plane graph for all \(t \in  \left\lbrack  {0,1}\right\rbrack  ,h\left( {G,0}\right)  = G\) and \(h\left( {G,1}\right)  = {G}^{\prime }\) ,</p>
</li>
<li>
<p>\(x \in  \operatorname{boxes}\left( G\right)\) implies \(h\left( {x,t}\right)  \in  \operatorname{boxes}\left( {h\left( {G,t}\right) }\right)\) for all \(t \in  \left\lbrack  {0,1}\right\rbrack\) ,</p>
</li>
<li>
<p>\(h\left( {G,t}\right) \mathring{} \lambda  = \lambda\) for all \(t \in  \left\lbrack  {0,1}\right\rbrack\) ,i.e. the labels are preserved throughout.</p>
</li>
</ul>
<p>A deformation is progressive (generic) when \(h\left( {G,t}\right)\) is progressive (generic) for all \(t \in  \left\lbrack  {0,1}\right\rbrack\) . We write \(G \sim  {G}^{\prime }\) when there exists some deformation \(h : G \rightarrow  {G}^{\prime }\) , this defines an equivalence relation.</p><!-- Meanless: 86 1.3. Drawing & reading-->
<p>Proposition 1.3.10. Diagram.draw(graph2diagram( \(G\) )) \(\sim  G\) for all lgpp graphs \(G\) ,up to generic progressive deformation.</p>
<p>Proof. By induction on the length of boxes(G). If there are no boxes, \(G\) is the graph of the identity and we can deform it so that each wire is vertical with constant spacing. If there is one box, \(G\) is the graph of a layer and we can cut it in three vertical slices with the box node and its outgoing wires in the middle. We can apply the case of the identity to the left and right slices, for the middle slice we make the wires straight with a constant spacing between the domain and codomain. Because \(G\) is generic,we can cut a graph with \(n > 2\) boxes in two horizontal slices between the last and the one-before-last box, then apply the case for layers and the induction hypothesis. To glue the two slices back together while keeping the wires straight, we need to make space for the wires going out of the box.</p>
<p>This deformation is indeed progressive, i.e. we never bend wires, we only make them straight. It is also generic, i.e. we never move a box node past another.</p>
<p>Proposition 1.3.11. There is a progressive deformation \(h : G \rightarrow  {G}^{\prime }\) between two lgpp graphs iff graph2diagram \(\left( G\right)  =  =\) graph2diagram \(\left( {G}^{\prime }\right)\) up to interchanger.</p>
<p>Proof. By induction on the number \(n\) of coincidences,the times at which the deformation \(h\) fails to be generic,i.e. two or more boxes are at the same height. WLOG (i.e. up to continuous deformation of deformations) this happens at a discrete number of time steps \({t}_{1},\ldots ,{t}_{n} \in  \left\lbrack  {0,1}\right\rbrack\) . Again WLOG at each time step there is at most two boxes at the same height, e.g. if there are two boxes moving below a third at the same time, we deform the deformation so that they move one after the other. The list of boxes and offsets is preserved under generic deformation, thus if \(n = 0\) then graph2diagram \(\left( G\right)  =  =\) graph2diagram \(\left( {G}^{\prime }\right)\) on the nose. If \(n = 1\) ,take \(i\) : int the index of the box for which the coincidence happens and left: bool whether it is a left or right interchanger,then graph2diagram ( \(G\) ).interchange(i,left) == graph2diagram( \({G}^{\prime }\) ). Given a deformation with \(n + 1\) coincidences,we can cut it in two time slices with 1 and \(n\) coincidences respectively then apply the cases for \(n = 1\) and the induction hypothesis.</p>
<p>For the converse,a proof of graph2diagram( \(G\) ) == graph2diagram( \({G}^{\prime }\) ), i.e. a sequence of \(n\) interchangers,translates into a deformation with \(n\) coincidences. DisCoPy can output these proofs as videos using Diagram.normalize to iterate through the rewriting steps and Diagram. to_gif to produce a .gif file.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 87-->
<h4>1.3.3 A natural isomorphism</h4>
<p>We have established an isomorphism between the class of lgpp graphs (up to progressive deformation) and the class of Diagram objects (up to interchanger). It remains to define lgpp graphs as the arrows of a monoidal category, i.e. to define identity,composition and tensor. For every monoidal signature \(\sum\) ,there is a monoidal category \(G\left( \sum \right)\) with objects \({\sum }_{0}^{ \star  }\) and arrows the equivalence classes of lgpp graphs with labels in \(\sum\) . The domain and codomain of an arrow is given by the labels of the domain and codomain of the graph. The identity \(\operatorname{id}\left( {{x}_{1}\ldots {x}_{n}}\right)\) is the graph with wires \(\left( {i,a}\right)  \rightarrow  \left( {i,b}\right)\) for \(i \leq  n\) and \(a,b \in  \mathbb{R}\) the horizontal boundaries. The tensor of two graphs \(G\) and \({G}^{\prime }\) is given by horizontal juxtaposition, i.e. take \(w = \max \left( {{p}_{0}\left( G\right) }\right)  + 1\) the right-most point of \(G\) plus a margin and set \(G \otimes  {G}^{\prime } = G \cup  \left\{  {\left( {{p}_{0}\left( x\right)  + w,{p}_{1}\left( x\right) }\right)  \mid  x \in  {G}^{\prime }}\right\}\) . The composition \({G}_{9}{G}^{\prime }\) is given by vertical juxtaposition and connecting the codomain nodes of \(G\) to the domain nodes of \({G}^{\prime }\) . That is, \({G}_{9}^{ \circ  }{G}^{\prime } = {s}^{ + }\left( G\right)  \cup  {s}^{ - }\left( {G}^{\prime }\right)  \cup  E\) for \({s}^{ \pm  }\left( x\right)  = \left( {{p}_{0}\left( x\right) ,\frac{{p}_{1}\left( x\right)  \pm  \left( {b - a}\right) }{2}}\right)\) and wires \({s}^{ + }\left( {\operatorname{cod}{\left( G\right) }_{i}}\right)  \rightarrow  {s}^{ - }\left( {\operatorname{dom}{\left( {G}^{\prime }\right) }_{i}}\right)  \in  E\) for each \(i \leq  1\) en \(\left( {\operatorname{cod}\left( G\right) }\right)  = \operatorname{len}\left( {\operatorname{dom}\left( {G}^{\prime }\right) }\right)\) .</p>
<p>The deformations for the unitality axioms are straightforward: there is a deformation \(G\) , \(\operatorname{id}\left( {\operatorname{cod}\left( G\right) }\right)  \sim  G \sim  \operatorname{id}\left( {\operatorname{dom}\left( G\right) }\right)\) , \(G\) which contracts the wires of the identity graph, the unit of the tensor is the empty diagram so we have an equality \(G \otimes  \operatorname{id}\left( 1\right)  = G = \operatorname{id}\left( 1\right)  \otimes  G\) . The deformations for the associativity axioms are better described by the hand-drawn diagrams of Joyal and Street in figure 1.1.</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_86.jpg?x=590&#x26;y=1350&#x26;w=554&#x26;h=475&#x26;r=0">
<p>Figure 1.1: Deformations for the associativity of tensor and composition.</p>
<!-- Media -->
<p>The interchange law holds on the nose,i.e. \({\left( G \otimes  {G}^{\prime }\right) }_{§}\left( {H \otimes  {H}^{\prime }}\right)  = \left( {{G}_{9}H}\right)  \otimes  \left( {{G}^{\prime }{}_{9}{H}^{\prime }}\right)\) , as witnessed by figure 1.2, the hand-drawn diagram which is the result of both sides.</p><!-- Meanless: 88 1.3. Drawing & reading-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_87.jpg?x=656&#x26;y=300&#x26;w=256&#x26;h=317&#x26;r=0">
<p>Figure 1.2: The graph of the interchange law.</p>
<!-- Media -->
<p>Thus,we have defined a monoidal category \(G\left( \sum \right)\) . Now given a morphism of monoidal signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) ,we can define a functor \(G\left( f\right)  : G\left( \sum \right)  \rightarrow  G\left( {\sum }^{\prime }\right)\) which sends a graph to itself relabeled with \(f。\lambda\) ,its image on arrows is given in listing 1.3.12. Hence,we have defined a functor \({}^{1}G :\) MonSig \(\rightarrow\) MonCat which we claim is naturally isomorphic to the free functor \(F :\) MonSig \(\rightarrow\) MonCat defined in the previous section. An abstract way to prove this is to appeal to the universal property of free monoidal categories: if the topological and the combinatorial definitions are both free monoidal, they are necessarily isomorphic. More concretely, we can implement this natural isomorphism as a commutative diagram in Pyth and think of it as a software test for our drawing and reading algorithms.</p>
<!-- Media -->
<p>Listing 1.3.12. Implementation of the functor \(G :\) MonSig \(\rightarrow\) MonCat.</p>
<hr>
<p>SigMorph = tuple[dict[0b, 0b], dict[Box, Box]]
def \(G\left( {f : \text{ SigMorph }}\right)  \rightarrow\) Callable [[Graph] ,Graph] :
def G_of_f(graph: Graph) -> Graph:
relabel = lambda node: Node ('box', f[1] [node.label], node.i, node.j)\
if node.kind == 'box' \(\smallsetminus\)
else Node ( node.kind, f [0] [node.label], node.i, node.j )
return Graph ( map ( relabel, graph. edges ) )
return G_of_f</p>
<hr>
<!-- Media -->
<p>Proposition 1.3.13. There is a natural isomorphism \(F \simeq  G :\) MonSig \(\rightarrow\) MonCat for \(F\) the combinatorial definition of diagrams in section 1.2.2 and \(G\) the topological definition in terms of labeled generic progressive plane graphs.</p>
<p>Proof. From propositions 1.3.10 and 1.3.11, we have an isomorphism between Diagram and PlaneGraph (up to deformation and interchanger respectively) given</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) For lack of a better notation,we use the same letter \(G\) to refer to an arbitrary graph as well as for the functor \(G :\) MonSig \(\rightarrow\) MonCat.</p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 89-->
<p>by \(\mathrm{d}2\mathrm{\;g} =\) Diagram.draw and \(\mathrm{g}2\mathrm{\;d} =\) graph2diagram. Now define the image of \(F\) on arrows \(\mathrm{F} =\) lambda \(\mathrm{f}\) : Functor \(\left( {\mathrm{{ob}} = \mathrm{f}\left\lbrack  0\right\rbrack  ,\text{ar} = \mathrm{f}\left\lbrack  1\right\rbrack  }\right)\) . Given a morphism of monoidal signatures \(\mathrm{f}\) : SigMorph we have the following two naturality squares.</p>
<hr>
<!-- Media -->
<pre><code>&#x3C;img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_88.jpg?x=313&#x26;y=456&#x26;w=1101&#x26;h=186&#x26;r=0"/>
</code></pre>
<!-- Media -->
<hr>
<h4>1.3.4 Daggers, sums and bubbles</h4>
<p>As in the previous sections, we now discuss the drawing of daggers, sums and bubbles. When we draw a diagram in the free \(\dagger\) -monoidal category,we add some asymmetry to the drawing of each box so that it looks like the vertical reflection of its dagger.</p>
<!-- Media -->
<p>Example 1.3.14. Drawing of the axiom for unitaries.</p>
<hr>
<p>\(\mathrm{f},\mathrm{g} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{g}}^{\prime },\mathrm{z},\mathrm{w}}\right)\)
(f >> f[::-1]).draw(   ); Diagram.id(x).draw(   )
(f[::-1] >> f).draw(   ); Diagram.id(y).draw(   )</p>
<hr>
<!-- figureText: \( \frac{1}{f}y = {\left. \begin{array}{ll} 1 & x \\  1 & x \end{array}\right| }_{x = 1}^{x} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_88.jpg?x=420&#x26;y=1249&#x26;w=281&#x26;h=190&#x26;r=0">
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_88.jpg?x=1028&#x26;y=1245&#x26;w=279&#x26;h=197&#x26;r=0">
<!-- Media -->
<p>Example 1.3.15. Drawing of the axiom for \(\dagger\) -monoidal categories.</p>
<hr>
<p>f, \(\mathrm{g} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{g}}^{\prime },\mathrm{z},\mathrm{w}}\right)\)
(f @ g)[::-1].draw(   ); (f[::-1] @ g[::-1]).draw(   )
assert (f @ g)[::-1].normal_form(   ) == f[::-1] @ g[::-1]</p>
<hr>
<!-- Media -->
<!-- figureText: \( \overset{\overset{\overset{\text{W}}{\text{|}}}{\underset{\text{X}}{\text{|}}}}{\mathop{|}\limits_{\text{I}}}\mathop{|}\limits^{\overset{\text{X}}{\text{|}}}\mathop{|}\limits^{\overset{\text{Y}}{\text{|}}}\mathop{|}\limits^{\overset{\text{W}}{\text{|}}}\mathop{|}\limits^{\text{X}}\mathop{|}\limits^{\overset{\text{X}}{\text{|}}}\mathop{|}\limits^{\text{X}}\mathop{|}\limits^{\overset{\text{X}}{\text{|}}}\mathop{|}\limits^{\text{Z}}\mathop{|}\limits^{\text{X}} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_88.jpg?x=601&#x26;y=1700&#x26;w=516&#x26;h=197&#x26;r=0">
<!-- Media -->
<p>When we draw a sum, we just draw each term with an addition symbol in between. More generally, drawing. equation allows to draw any list of diagrams and drawing.Equation allows to draw equations within equations.</p>
<p>Example 1.3.16. Drawing of a commutativity equation.</p><!-- Meanless: 90 1.3. Drawing & reading-->
<!-- Media -->
<hr>
<p>from discopy import drawing</p>
<hr>
<p>\(\mathrm{f},\mathrm{g},\mathrm{h} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{g}}^{\prime },\mathrm{y},\mathrm{z}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{h}}^{\prime },\mathrm{x},\mathrm{z}}\right)\)</p>
<p>drawing.equation(drawing.Equation(f >> g, h, symbol='$+$'),</p>
<p>drawing.Equation (h, f >> g, symbol='$+$'))</p>
<!-- figureText: \( {\left. {\left. \frac{f}{y}\right| }_{y}^{x}\right| }_{yz}^{x} + {\left. {\left. \frac{h}{h}\right| }_{z}^{x}\right| }_{yz}^{x} + {\left. {\left. \frac{h}{y}\right| }_{y}^{x}\right| }_{zx}^{x} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_89.jpg?x=477&#x26;y=584&#x26;w=619&#x26;h=194&#x26;r=0">
<!-- Media -->
<p>Example 1.3.17. Drawing a composition and tensor of sums.</p>
<hr>
<p>f0, g0 = Box("f0", x, y), Box("g0", y, z)
f1, g1 = Box("f1", x, y), Box("g1", y, z)
\(\left( {\left( {\mathrm{f}0 + \mathrm{f}1}\right)  >  > \left( {\mathrm{g}0 + \mathrm{g}1}\right) }\right) .\mathrm{{draw}}\left( \right)\)</p>
<hr>
<!-- Media -->
<!-- figureText: \( \begin{matrix} {}^{x} & {}^{x} \\  {}^{f0} & {}^{f1} \\  {}^{g0} & {}^{f1} \end{matrix} + \begin{matrix} {}^{x} & {}^{f1} \\  {}^{f0} & {}^{f1} \\  {}^{g0} & {}^{f1} \end{matrix} + \begin{matrix} {}^{x} & {}^{1x} \\  {}^{f1} & {}^{f2} \\  {}^{g1} & {}^{g2} \\  {}^{f2} & {}^{f2} \end{matrix} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_89.jpg?x=469&#x26;y=1033&#x26;w=630&#x26;h=194&#x26;r=0">
<!-- Media -->
<p>((f0 + f1) @ (g0 + g1)).draw(   )</p>
<!-- Media -->
<!-- figureText: \( \begin{matrix} {}^{x} \\  {}^{f\left( 0\right) } \\  {}^{y} \\  {}^{g\left( 0\right) } \end{matrix} + \begin{matrix} {}^{y} \\  {}^{f\left( 0\right) } \\  {}^{g\left( 1\right) } \end{matrix}{}^{y} + \begin{matrix} {}^{x} \\  {}^{f\left( 0\right) } \\  {}^{g\left( 1\right) } \end{matrix}{}^{y} + \begin{matrix} {}^{x} \\  {}^{f\left( 1\right) } \\  {}^{g\left( 2\right) } \end{matrix}{}^{y} + \begin{matrix} {}^{x} \\  {}^{f\left( 1\right) } \\  {}^{g\left( 2\right) } \end{matrix}{}^{y} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_89.jpg?x=313&#x26;y=1328&#x26;w=950&#x26;h=197&#x26;r=0">
<!-- Media -->
<p>The case of drawing bubbles is more interesting. One solution would be to draw the bubble as a rectangle like any other box, then draw the content of the bubble inside the rectangle. However, this would require some clever scaling so that the boxes of the diagram inside the bubble have the same size as the boxes outside, i.e. we would need to add more complexity to our drawing algorithm. The solution implemented in DisCoPy is to apply a faithful functor downgrade : \(F\left( {\sum }^{\beta }\right)  \rightarrow\) \(F\left( {\sum  \cup  {\text{ open }}^{\beta } \cup  {\text{ close }}^{\beta }}\right)\) from the free monoidal category with bubbles \(F\left( {\sum }^{\beta }\right)\) to the free monoidal category generated by the following signature. Take the objects \({\text{open}}_{0}^{\beta } = {\text{close}}_{0}^{\beta } = {\sum }_{0} + \{  \bullet  \}\) and boxes for opening \({\operatorname{open}}^{\beta }\left( x\right)  : {\beta }_{\text{dom }}\left( x\right)  \rightarrow   \bullet   \otimes  x \otimes   \bullet\) and closing \({\operatorname{close}}^{\beta }\left( x\right)  :  \bullet   \otimes  x \otimes   \bullet   \rightarrow  {\beta }_{\text{cod }}\left( x\right)\) bubbles for each type \(x \in  {\sum }_{0}^{ \star  }\) . Now define downgrade(f.bubble(   )) \(= {\mathtt{{open}}}^{\beta }\left( {\mathtt{f}.\mathtt{{dom}}}\right) {\;}_{9}^{ \circ  }\left( {\bullet  \otimes  \mathtt{f} \otimes   \bullet  }\right) {\;}_{9}^{ \circ  }{\mathtt{{close}}}^{\beta }\left( {\mathtt{f}.\mathtt{{cod}}}\right)\) for any diagram \(\mathrm{f}\) inside a bubble. That is,we draw a bubble as its opening,its inside with identity wires on both sides then its closing. The - labeled wires are drawn with Bézier curves so that the bubble looks a bit closer to a circle than a rectangle. In the case of bubbles that are length-preserving on objects, we also want to override the drawing of its opening and closing boxes so that the wires go straight through the bubble rather than meeting at the box node.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 91-->
<p>Example 1.3.18. Drawing of a bubbled diagram and a first-order logic formula.</p>
<hr>
<p>f, g, h = Box('f', x, y), Box('g', y, z), Box('h', y @ z, x)
(f @ g >> h).bubble(dom=a @ b, cod=c, name="$\\beta$").draw(   )</p>
<hr>
<!-- Media -->
<!-- figureText: a y X \( \beta \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_90.jpg?x=720&#x26;y=767&#x26;w=263&#x26;h=430&#x26;r=0">
<!-- Media -->
<hr>
<p>god = Predicate("G", x)
formula = god >> (Formula.id(x).cut(   ) >> god.dagger(   )).cut(   )
formula.draw(   )</p>
<hr>
<!-- Media -->
<!-- figureText: G -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_90.jpg?x=779&#x26;y=1374&#x26;w=140&#x26;h=217&#x26;r=0">
<!-- Media -->
<h4>1.3.5 Automatic diagram recognition</h4>
<p>We conclude this section with an application of proposition 1.3.13 to automatic diagram recognition: turning pictures of diagrams into diagrams. In listing 1.3.1, we described an abstract reading algorithm which took lgpp graphs as input and returned diagrams. We make it a concrete algorithm by taking bitmaps as input: grids of Boolean pixels describing a black-and-white picture. The algorithm read listed below takes as input a pair of bitmaps for the box nodes and the wires of the plane graph, it returns a Diagram. It is more general than the graph2diagram algorithm of listing 1.3.1 where we assumed that the embedding of the graph looked like the output of Diagram.draw. i.e. that edges are straight vertical lines. Indeed, our reading algorithm will accept any bitmaps as input and always return a valid diagram, however bended the edges are. If the bitmaps indeed represent a progressive generic plane graph \(G\) ,then we get \(\operatorname{read}\left( G\right)\) .draw \(\left( \right)  \sim  G\) up to progressive generic deformation. If not, the output will still be a diagram but its drawing may not look anything like the input.</p><!-- Meanless: 92 1.3. Drawing & reading-->
<!-- Media -->
<p>Listing 1.3.19. Implementation of the abstract reading algorithm of listing 1.3.1.</p>
<p>from numpy import array, argmin</p>
<hr>
<p>from skimage.measure import regionprops, label
def read(box_pixels: array, wire_pixels: array) -> Diagram:
connected_components = lambda img: regionprops(label(img))
box_nodes, wires = map(connected_components, (box_pixels, wire_pixels))
source, target, length, width = [], [], len(box_pixels), len(box_pixels[0])
critical_heights = [0] + [
int(node.centroid[0]) for node in box_nodes] + [length]
for wire, region in enumerate (wires):
top, bottom = (   )
minmax(i for i, _ in region.coords) for minmax in (min, max))
source.append(argmin(abs(array(critical_heights) - top)))
target.append(argmin(abs(array(critical_heights) - bottom)))
scan = [wire for wire, node in enumerate(source) if node == 0]
dom, boxes_and_offsets = Ty('x') ** len(scan), []
for depth, box_node in enumerate(box_nodes):
input_wires = [wire for wire in scan if target[wire] == depth + 1]
output_wires = [
wire for wire, node in enumerate (source) if node == depth + 1]
dom, cod = Ty('x') ** len(input_wires), Ty('x') ** len(output_wires)
box = Box ( ' box_{}_{}' . format ( len ( dom ) , len ( cod ) ), dom, cod )
height, left = map ( int , box_node. centroid )
left_of_box = [wire for wire in scan if wire not in input_wires
and dict(wires[wire].coords).get(height, width) &#x3C; left]
offset = max(len(left_of_box), 0)
boxes_and_offsets.append((box, offset))
scan = scan[:offset] + output_wires + scan[offset + len(input_wires):]</p>
<hr>
<p>return decode(dom, tuple(boxes_and_offsets))</p>
<!-- Media -->
<p>We use the array data structure of NumPy [vdWCV11] for bitmaps. We compute the connected components of box and wire pixels with Scikit-Image [Wal+14], using their default ordering by lexicographic order of top-left pixel. We then define a list of critical heights: the top of the picture, the height of the centroid of each box component, then the bottom of the picture. For each wire component, we define its source and target as the closest critical height to its top-most and bottom-most pixel. We define the domain of the diagram as the list of wires with the domain as source. We then scan through the picture top to bottom, keeping a list scan of the open wires at each height. For each box, we find its input wires in this list and define the offset as the number of wires left of the box node that are not inputs, then we update scan with the output wires. We get an encoding dom, boxes_and_offsets which yields a valid diagram by construction.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 93-->
<p>Example 1.3.20. Suppose we take the following picture of a diagram as input, where the red pixels are boxes and the black pixels are wires:</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_92.jpg?x=652&#x26;y=787&#x26;w=423&#x26;h=421&#x26;r=0">
<!-- Media -->
<p>We count \(\{ 1,\ldots ,6\}\) boxes and 8 wires</p>
<p></p>\[\{ 0 \rightarrow  3,0 \rightarrow  1,1 \rightarrow  4,1 \rightarrow  6,2 \rightarrow  4,3 \rightarrow  6,3 \rightarrow  5,6 \rightarrow  7\}\]<p></p>
<p>for 0 and 7 the domain and codomain of the whole diagram respectively.</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_92.jpg?x=546&#x26;y=1492&#x26;w=664&#x26;h=321&#x26;r=0">
<!-- Media -->
<p>From this, we reconstruct the following diagram by scanning top to bottom:</p><!-- Meanless: 94 1.3. Drawing & reading-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_93.jpg?x=633&#x26;y=299&#x26;w=294&#x26;h=377&#x26;r=0">
<!-- Media -->
<p>which is indeed equal to the input picture, up to generic progressive deformation.</p>
<p>Example 1.3.21. Suppose we start from the following pastiche of Kandinsky's Punkt und linie zu fläche (point and line on the plane):</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_93.jpg?x=588&#x26;y=915&#x26;w=379&#x26;h=320&#x26;r=0">
<!-- Media -->
<p>We count \(\{ 1,\ldots ,9\}\) boxes and 7 wires</p>
<p></p>\[\{ 0 \rightarrow  3,1 \rightarrow  3,2 \rightarrow  4,4 \rightarrow  8,4 \rightarrow  9,6 \rightarrow  {10},6 \rightarrow  {10}\}\]<p></p>
<p>for 0 and 10 the domain and codomain of the whole diagram respectively.</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_93.jpg?x=454&#x26;y=1549&#x26;w=653&#x26;h=247&#x26;r=0">
<!-- Media -->
<p>From this, we reconstruct the following diagram by scanning top to bottom:</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 95-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_94.jpg?x=693&#x26;y=300&#x26;w=326&#x26;h=446&#x26;r=0">
<p>which looks nothing like the input because Kandinsky's abstract paintings are not generic progressive plane graphs.</p>
<!-- Media -->
<p>What could be the applications of such a reading algorithm? Of course, real-world pictures do not come in clean red and black bitmaps. We need some more computer vision to label each pixel as belonging either to a box, a wire or the background. This can be achieved by training a convolutional neural network on a large number of example pictures, each annotated with their red and black bitmaps. Once we have trained the machine to classify whether pixels belong to a box or wire, we can also train it to output the label of each pixel, i.e. the label of the box or wire it belongs to. With enough training data, we could automatically turn pictures of Bob's blackboard into circuits that we can execute on a quantum computer. Less trivially, this could be applied to document layout analysis: from the picture of say, a hand-drawn calendar from the middle ages, we could train our recognition algorithm to output a diagram that encodes the structure of the calendar. In previous work \(\left\lbrack  {\text{Bor} + {19}}\right\rbrack\) ,we trained convolutional neural networks to extract lines of text in medieval manuscripts, but we had to exclude calendars from our analysis due to the complexity of their layouts. Our diagram recognition machines would enhance the automated analysis of such hand-drawn documents with structured layouts.</p>
<p>Our simple algorithm is robust to any deformation of lgpp graph, but there is much room for improvement. The easiest assumption to remove is genericity, i.e. boxes need not be at distinct heights. Non-generic progressive plane graphs, i.e. with potentially horizontal wires between boxes at the same height, have been characterised as the arrows of free double categories. Delpeuch [Del20b] shows how they can be encoded as lgpp graphs with an extra label on each wire for whether it is horizontal or vertical. We can also remove the progressivity assumption, i.e. wires can bend backwards. We have two options: either a) we write a geometric algorithm than can find the endpoints of any bended wire, or b) we train another neural network to detect each point of non-progressivity, i.e. the cups and caps where the vertical derivative of a wire changes sign. Such non-progressive plane graphs can be encoded as lgpp graphs with cups and caps boxes, they are the arrows of free pivotal categories which we discuss in section 1.4.1.</p><!-- Meanless: 96 1.4. Adding extra structure-->
<p>Next, we can get rid of the planarity assumption: the projection of the topological graph onto the plane need not be an embedding, i.e. wires can cross. We can improve our reading algorithm in a similar way: either a) some geometric algorithm or b) some black-box neural network that can detect the points of non-planarity, i.e. the intersection of wires. Such non-planar progressive graphs can be encoded as lgpp graphs with swap boxes, they are the arrows of free symmetric monoidal categories which we discuss in section 1.4.2. Non-planar non-progressive graphs, i.e. where wires can bend and swap, are the arrows of free compact closed categories, which play the starring role in categorical quantum mechanics.</p>
<p>Finally, we can even remove the graph assumption: wires need not be homeomorphic to an open interval. We merely require that they are one-dimensional open subsets of the plane, i.e. wires can split and merge. We do not even need to assume that their boundary is in the nodes of the graph, i.e. wires can start or end anywhere in the plane. Again, we can improve our reading algorithm by encoding such hypergraphs (i.e. where wires can have any number of sources and targets) as lgpp graphs with spider boxes for the splits, merges, starts and ends of each wire. Labeled hypergraphs are the arrows of free hypergraph categories, which we discuss in section 1.4.3. In section 1.5, we discuss the relationship between this definition of hypergraph diagrams as (equivalence classes of) planar diagrams with swap and spider boxes and the more traditional graph-based definition.</p>
<h3>1.4 Adding extra structure</h3>
<h4>1.4.1 Rigid categories &#x26; wire bending</h4>
<p>In sections 1.1 and 1.2 we discussed the fundamental notion of adjunction with the example of free-forgetful functors. The definition of left and right adjoints in terms of unit and counit natural transformations makes sense in \(\mathbf{{Cat}}\) ,but it can be translated in the context of any monoidal category \(C\) . An object \({x}^{l} \in  {C}_{0}\) is the left adjoint of \(x \in  {C}_{0}\) whenever there are two arrows \(\operatorname{cup}\left( x\right)  : {x}^{l} \otimes  x \rightarrow  1\) and \(\operatorname{cap}\left( x\right)  : 1 \rightarrow  x \otimes  {x}^{l}\) (also called counit and unit) such that:</p>
<ul>
<li>\(\operatorname{cap}\left( x\right)  \otimes  x\) ; \(x \otimes  \operatorname{cup}\left( x\right)  = \mathrm{{id}}\left( x\right)\) ,</li>
</ul><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 97-->
<!-- Media -->
<!-- figureText: \( x \) - -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_96.jpg?x=701&#x26;y=285&#x26;w=395&#x26;h=190&#x26;r=0">
<!-- Media -->
<ul>
<li>\({x}^{l} \otimes  \operatorname{cap}\left( x\right)\) ; \(\operatorname{cup}\left( x\right)  \otimes  {x}^{l} = \operatorname{id}\left( {x}^{l}\right)\) .</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_96.jpg?x=698&#x26;y=576&#x26;w=401&#x26;h=193&#x26;r=0">
<!-- Media -->
<p>This is equivalent to the condition that the functor \({x}^{l} \otimes   -  : C \rightarrow  C\) is the left adjoint of \(x \otimes   -  : C \rightarrow  C\) . Symmetrically, \({x}^{r} \in  {C}_{0}\) is the right adjoint of \(x \in  {C}_{0}\) if \(x\) is its left adjoint. We say that \(C\) is rigid (also called autonomous) if every object has a left and right adjoint. From this definition we can deduce a number of properties:</p>
<ul>
<li>
<p>adjoints are unique up to isomorphism,</p>
</li>
<li>
<p>adjoints are monoid anti-homomorphisms,i.e. \({\left( x \otimes  y\right) }^{l} \simeq  {y}^{l} \otimes  {x}^{l}\) and \({1}^{l} \simeq  1\) ,</p>
</li>
<li>
<p>left and right adjoints cancel,i.e. \({\left( {x}^{l}\right) }^{r} \simeq  x \simeq  {\left( {x}^{r}\right) }^{l}\) ,</p>
</li>
</ul>
<p>We say that \(C\) is strictly rigid whenever these isomorphisms are in fact equalities, again one can show that any rigid category is monoidally equivalent to a strict one. One can also show that cups and caps compose by nesting:</p>
<ul>
<li>\(\operatorname{cup}\left( {x \otimes  y}\right)  = {y}^{l} \otimes  \operatorname{cup}\left( x\right)  \otimes  y\) ; \(\operatorname{cup}\left( y\right)\) ,</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_96.jpg?x=539&#x26;y=1509&#x26;w=717&#x26;h=236&#x26;r=0">
<!-- Media -->
<ul>
<li>\(\operatorname{cap}\left( {x \otimes  y}\right)  = \operatorname{cap}\left( x\right)\) э \(x \otimes  \operatorname{cap}\left( y\right)  \otimes  {x}^{l}\) ,</li>
</ul>
<!-- Media -->
<!-- figureText: \( x \otimes  y \) \( {y}^{l} \) \( y \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_96.jpg?x=546&#x26;y=1849&#x26;w=706&#x26;h=225&#x26;r=0">
<!-- Media -->
<ul>
<li>\(\operatorname{cup}\left( 1\right)  = \operatorname{cap}\left( 1\right)  = \operatorname{id}\left( 1\right)\) ,drawn as the equality of three empty diagrams.</li>
</ul><!-- Meanless: 98 1.4. Adding extra structure-->
<p>The first two equations are drawn as diagrams in a non-foo monoidal category, i.e. with wires for composite types and explicit boxes for tensor. This can be taken as an inductive definition, once we have defined the cups and caps for generating objects, we have defined them for all types. Thus, we can take the data for a (strictly) rigid category \(C\) to be that of a free-on-objects monoidal category together with:</p>
<ul>
<li>
<p>a pair of unary operators \({\left( -\right) }^{l},{\left( -\right) }^{r} : {C}_{0} \rightarrow  {C}_{0}\) on generating objects,</p>
</li>
<li>
<p>and a pair of functions cup,cap : \({C}_{0} \rightarrow  {C}_{1}\) witnessing that \({x}^{l}\) and \({x}^{r}\) are the left and right adjoints of each generating object \(x \in  {C}_{0}\) .</p>
</li>
</ul>
<p>Diagrams in rigid categories are more flexible than monoidal categories: we can bend wires. They owe their name to the fact that they are less flexible than pivotal categories. For any rigid category \(C\) ,there are two contravariant endofunctors, called the left and right transpose respectively. They send objects to their left and right adjoints,and each arrow \(f : x \rightarrow  y\) to</p>
<!-- Media -->
<!-- figureText: and -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_97.jpg?x=355&#x26;y=1026&#x26;w=848&#x26;h=270&#x26;r=0">
<!-- Media -->
<p>A rigid category \(C\) is called pivotal when it has a monoidal natural isomorphism \({x}^{l} \sim  {x}^{r}\) for each object \(x\) ,which implies that the left and right transpose coincide: we can rotate diagrams by 360 degrees [Sel10,§4.2]. We say \(C\) is strictly piotal when this isomorphism is an equality. This is the case for any rigid category \(C\) with a dagger structure: the dagger of the cup (cap) for an object \(x\) is the cap (cup) of its left adjoint \({x}^{l}\) . When this is the case, \(C\) is called \(\dagger\) -pivotal. We say \(C\) is strictly piotal when left and right transpose are equal.</p>
<p>Example 1.4.1. Recall from example 1.2.5 that for any category \(C\) ,the category \({C}^{C}\) of endofunctors and natural transformations is monoidal. Its subcategory with endofunctors that have both left and right adjoints is rigid. Its subcategory with endofunctors that have equal left and right adjoints is pivotal.</p>
<p>Example 1.4.2. Tensor \({}_{\mathbb{S}}\) is \(\dagger\) -pivotal with left and right adjoints given by list reversal,cups and caps by the Kronecker delta \(\operatorname{cup}\left( n\right) \left( {i,j}\right)  = \operatorname{cap}\left( n\right) \left( {i,j}\right)  = 1\) if \(i = j\) else 0 . Note that for tensors of order greater than 2,the diagrammatic transpose defined in this way differs from the usual algebraic transpose: the former reverses list order while the latter is the identity on objects.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 99-->
<p>Example 1.4.3. Circ is \(\dagger\) -pivotal with the preparation of the Bell state as cap and the post-selected Bell measurement as cup (both are scaled by \(\sqrt{2}\) ). The snake equations yield a proof of correctness for the (post-selected) quantum teleportation protocol.</p>
<p>Example 1.4.4. A discrete rigid category is a group: if the cups and caps are identities then they define an inverse for the tensor. A rigid preordered monoid (i.e. a rigid category with at most one arrow between any two objects) is called a (quasi \({}^{1}\) ) pregroup, their application to NLP will be discussed in section 2.1. A commutative pregroup is a (preordered) abelian group: left and right adjoints coincide with the multiplicative inverse.</p>
<p>Natural examples of non-free non-commutative pregroups are hard to come by. One exception is the monoid of monotone unbounded functions \(\mathbb{Z} \rightarrow  \mathbb{Z}\) with composition as multiplication and pointwise order. The left adjoint of \(f : \mathbb{Z} \rightarrow  \mathbb{Z}\) is defined such that \({f}^{l}\left( m\right)\) is the minimum \(n \in  \mathbb{Z}\) with \(m \leq  f\left( n\right)\) and symmetrically \({f}^{r}\left( m\right)\) is the maximum \(n \in  \mathbb{N}\) with \(f\left( n\right)  \leq  m\) . Extending Cayley’s theorem from groups to pregroups, Buszkowski [Bus01, Proposition 2] proved that every pregroup \(G\) is in fact isomorphic to a subpregroup (i.e. a monoidal subcategory) of monotone functions \(G \rightarrow  G\) .</p>
<p>Any monoidal functor \(F : C \rightarrow  D\) between two rigid categories \(C\) and \(D\) preserves left and right adjoints up to isomorphism, we say it is strict when it preserves them up to equality. Thus,we have defined a subcategory RigidCat \(\hookrightarrow\) MonCat. We define a rigid signature \(\sum\) as a monoidal signature where the generating objects have the form \({\sum }_{0} \times  \mathbb{Z}\) . We identify \(x \in  {\sum }_{0}\) with \(\left( {x,0}\right)  \in  {\sum }_{0} \times  \mathbb{Z}\) and define the left and right adjoints \({\left( x,z\right) }^{l} = \left( {x,z - 1}\right)\) and \({\left( x,z\right) }^{r} = \left( {x,z + 1}\right)\) . The objects \({\sum }_{0}\) are called basic types,their iterated adjoints \({\sum }_{0} \times  \mathbb{Z}\) are called simple types. The integer \(z \in  \mathbb{Z}\) is called the adjunction number of the simple type \(\left( {x,z}\right)  \in  {\sum }_{0} \times  \mathbb{Z}\) by Lambek and Preller [PL07] and its winding number by Joyal and Street [JS88]. Again,a morphism of rigid signatures \(f : \sum  \rightarrow  {\sum }^{\prime }\) is a pair of functions \(f : {\sum }_{0} \rightarrow  {\sum }_{0}^{\prime }\) and \(f : {\sum }_{1} \rightarrow  {\sum }_{1}^{\prime }\) which commute with domain and codomain.</p>
<p>There is a forgetful functor \(U :\) RigidCat \(\rightarrow\) RigidSig which sends any strictly-rigid foo-monoidal category to its underlying rigid signature. We now describe its left adjoint \({F}^{r} :\) RigidSig \(\rightarrow\) RigidCat. Given a rigid signature \(\sum\) ,we define a monoidal signature \({\sum }^{r} = \sum  \cup  \{ \operatorname{cup}\left( x\right) {\} }_{x \in  {\sum }_{0}} \cup  \{ \operatorname{cap}\left( x\right) {\} }_{x \in  {\sum }_{0}}\) . The free rigid category is the quotient \({F}^{r}\left( \sum \right)  = F\left( {\sum }^{r}\right) /R\) of the free monoidal category by the snake equations \(R\) . That is,the objects are lists of simple types \({\left( {\sum }_{0} \times  \mathbb{Z}\right) }^{ \star  }\) ,the arrows are equivalence classes of diagrams with cup and cap boxes. This is implemented in the rigid module of DisCoPy as outlined below.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) In his original definition [Lam99b],Lambek also requires that pregroups are partial orders, i.e. preorders with antisymmetry \(x \leq  y\) and \(y \leq  x\) implies \(x = y\) . This implies that pregroups are strictly rigid,but also that they cannot be free on objects: \(\operatorname{cup}\left( x\right)  \otimes  \operatorname{id}\left( x\right)  : x \otimes  {x}^{l} \otimes  x \rightarrow  x\) and \(\operatorname{id}\left( x\right)  \otimes  \operatorname{cap}\left( x\right)  : x \rightarrow  x \otimes  {x}^{l} \otimes  x\) together would imply \(x = x \otimes  {x}^{l} \otimes  x\) .</p>
<!-- Footnote -->
<hr><!-- Meanless: 100 1.4. Adding extra structure-->
<!-- Media -->
<p>Listing 1.4.5. Implementation of objects and types of free rigid categories.</p>
<hr>
<p>@dataclass
class Ob(cat.Ob):
z: int = 0
l = property(lambda self: Ob(self.name, self.z - 1))
r = property(lambda self: 0b(self.name, self.z + 1))
@classmethod
def cast(cls, old: cat.0b) -> 0b:
return old if isinstance(old, cls) else cls(str(old), z=0)
class Ty (monoidal.Ty, Ob):
def <strong>init</strong>(self, inside=(   )):
monoidal.Ty.<em><strong><strong>init</strong></strong></em>(self, inside=tuple(map(Ob.cast, inside)))
1 = property(lambda self: type(self)([x.l for x in self.inside[::-1]]])
r = property(lambda self: type(self)([x.r for x in self.inside[::-1]]])</p>
<hr>
<!-- Media -->
<p>Example 1.4.6. We can check the axioms for objects in rigid categories hold on the nose.</p>
<hr>
<p>\(x,y = {Ty}\left( {1{x}^{\prime }}\right) ,{Ty}\left( {1{y}^{\prime }}\right)\)
assert Ty(   ).1 == Ty(   ) == Ty(   ).r
assert (x @ y).1 == y.1 @ x.1 and (x @ y).r == y.r @ x.r
assert x.r.l == x == x.l.r</p>
<hr>
<p>rigid. Ob and rigid. Ty are subclasses of cat. Ob and monoidal. Ty respectively, with property methods (i.e. attributes that are computed on the fly) 1 and \(\mathrm{r}\) for the left and right adjoints. Thanks to the cast method, we do not need to override the tensor method inherited from monoidal.Ty. In turn, subclasses of rigid. Ty will not need to override 1 and \(r\) . Similarly,the rigid. Diagram class is a subclass of monoidal. Diagram, thanks to the cast we do not need to reimplement the identity, composition or tensor. rigid. Box is a subclass of monoidal. Box and rigid. Diagram, with Box. cast = Diagram. cast. We need to be careful with the order of inheritance however: diagram equality is defined in terms of box equality, so if we had Box. <em><strong><strong>eq</strong></strong></em> = Diagram. <em><strong><strong>eq</strong></strong></em> then checking equality would enter an infinite loop. Cup (Cap) is a subclass of Box initialised by a pair of types \(\mathrm{x},\mathrm{y}\) such that \(\operatorname{len}\left( \mathrm{x}\right)  =  = \operatorname{len}\left( \mathrm{y}\right)  =  = 1\mathrm{x} =  = \mathrm{y}\) .1( \(\mathrm{x}{.1} =  = \mathrm{y}\) ,respectively). The class methods cups and caps construct diagrams of nested cups and caps by induction, with Cup and Cap as a base case.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 101-->
<!-- Media -->
<p>Listing 1.4.7. Implementation of the arrows of free rigid categories.</p>
<p>class Diagram (monoidal.Diagram) :</p>
<hr>
<pre><code>def transpose(self, left=True) -> Diagram:
	if left: ... # Symmetric to the right case.
	return self.caps(self.dom.r, self.dom) @ self.id(self.cod.r)\\\\
		>> self.id(self.dom.r) @ self @ self.id(self.cod.r)\\
		>> self.id(self.dom.r) @ self.cups(self.cod, self.cod.r)
</code></pre>
<p>class Box (monoidal. Box, Diagram) :
cast = Diagram.cast
class Cup (Box):
def <strong>init</strong>(self, x: Ty, y: Ty):
assert len ( x ) == 1 and x == y.l
super(   ).<em>init</em>("Cup({}, {})".format(repr(x), repr(y)), x @ y, x[:0])
class Cap (Box):
def <strong>init</strong>(self, x: Ty, y: Ty):
assert len ( x ) == 1 and x . l == y
super(   ).<em>init</em>("Cap({}, {})".format(repr(x), repr(y)), x[:0], x @ y)
def nesting(factory):
def method(cls, x: Ty, y: Ty) -> Diagram:
if \(\operatorname{len}\left( \mathrm{x}\right)  =  = 0 :\) return \(\operatorname{cls.id}\left( {\mathrm{x}\left\lbrack  { : 0}\right\rbrack  }\right)\)
if \(\operatorname{len}\left( \mathrm{x}\right)  =  = 1\) : return \(\mathrm{{factory}}\left( {\mathrm{x},\mathrm{y}}\right)\)
head = factory \(\left( {\mathrm{x}\left\lbrack  0\right\rbrack  ,\mathrm{y}\left\lbrack  {-1}\right\rbrack  }\right)\)
if head.dom: # We are nesting cups.
return \(\mathrm{x}\left\lbrack  0\right\rbrack  @\) method(cls, \(\mathrm{x}\left\lbrack  {1 : }\right\rbrack  ,\mathrm{y}\left\lbrack  { :  - 1}\right\rbrack  )@\mathrm{y}\left\lbrack  {-1}\right\rbrack   >  >\) head
return head >> x[0] @ method(cls, x[1:], y[:-1]) @ y[-1]
return classmethod(method)</p>
<hr>
<p>Diagram.cups, Diagram.caps = nesting(Cup), nesting(Cap)</p>
<!-- Media -->
<p>The snake removal algorithm listed below computes the normal form of diagrams in rigid categories. It is a concrete implementation of the abstract algorithm described in pictures by Dunn and Vicary [DV19, p. 2.12]. First, we implement a subroutine follow_wire. It takes a codomain node (given by the index i of its box and the index \(\mathrm{j}\) of itself in the box’s codomain) and follows the wire till it finds either the domain of another box or the codomain of the diagram. When we follow a wire, we compute two lists of obstructions, the index of each box on its left and right. The find_snake function calls follow_wire for each Cap in the diagram until it finds one that is connected to a Cup, or returns None otherwise. A Yankable snake is given by the index of its cup and cap, the two lists of obstructions on each side and whether it is a left or right snake. unsnake applies interchange repeatedly to remove the obstructions, i.e. to make the cup and cap consecutive boxes in the diagram, then returns the diagram with the snake removed. Each snake removed reduces the length \(n\) of the diagram by 2,hence the snake_removal algorithm makes at most \(n/2\) calls to find_snake. Finally,we call monoidal. Diagram.normal_form which takes at most cubic time. Finding a snake takes quadratic time (for each cap we need to follow the wire at each layer) as well as removing it (for each obstruction we make a linear number of calls to interchange). Thus, we can compute normal forms for diagrams in free rigid categories in cubic time.</p><!-- Meanless: 102 1.4. Adding extra structure-->
<p>Listing 1.4.8. Outline of the snake removal algorithm.</p>
<!-- Media -->
<hr>
<p>Obstruction = tuple[tuple[int, ...], tuple[int, ...]]
Yankable = tuple[int, int, Obstruction, bool]
def follow_wire(   )
self: Diagram, i: int, j: int) -> tuple[int, int, Obstruction]: ...
def find_snake(self: Diagram) -> Optional[Yankable]: ...
def unsnake(self: Diagram, yankable: Yankable) -> Diagram: ...
def snake_removal(self: Diagram) -> Diagram:
yankable = find_snake(diagram)
return snake_removal(unsnake(diagram, yankable)) if yankable else diagram
Diagram.normal_form = lambda self:</p>
<hr>
<p>monoidal.Diagram.normal_form(snake_removal(self))</p>
<!-- Media -->
<p>Example 1.4.9. We can check that the snake equations hold up to normal form.</p>
<hr>
<p>\(\mathrm{t} = \mathrm{x}@\mathrm{y}\)
left_snake = Diagram.id(t.l).transpose(left=False)
right_snake = Diagram.id(t).transpose(left=True)
assert left_snake.normal_form(   ) == Diagram.id(t)\</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 103-->
<pre><code>and right_snake.normal_form(   ) == Diagram.id(t.1)
</code></pre>
<p>drawing.equation (   )
drawing.Equation ( left_snake, Diagram.id(t)) ,
drawing.Equation (right_snake, Diagram.id(t.l)),
symbol='and', space=2, draw_type_labels=False)</p>
<hr>
<!-- Media -->
<!-- figureText: and -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_102.jpg?x=289&#x26;y=600&#x26;w=1133&#x26;h=234&#x26;r=0">
<!-- Media -->
<p>Example 1.4.10. We can check that left and right transpose cancel up to normal form.</p>
<hr>
<p>\(\bar{f} = \operatorname{Box}\left( {{}^{\prime }{f}^{\prime },x,y}\right)\)
lr_transpose = f.transpose(left=True).transpose(left=False)
rl_transpose = f.transpose(left=False).transpose(left=True)</p>
<hr>
<p>assert lr_transpose.normal_form(   ) == f == rl_transpose.normal_form(   )</p>
<p>drawing.equation ( lr_transpose, f, rl_transpose )</p>
<!-- Media -->
<!-- figureText: y. 1 X \( X \) y.r y X.r X.r -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_102.jpg?x=334&#x26;y=1303&#x26;w=1060&#x26;h=427&#x26;r=0">
<!-- Media -->
<p>Listing 1.4.11. Implementation of Circ as a pivotal category.</p>
<hr>
<p>class Qubits (monoidal.Qubits, Ty) :
l = r = property (lambda self: self)
class Circuit (monoidal. Circuit, Diagram) :
cups = nesting(lambda *_: sqrt2 @ Ket \(\left( {0,0}\right)  >  > \mathrm{H}\) @ qubit)
caps = lambda x, y: Circuit.cups(x, y).dagger(   )</p>
<hr>
<p>Example 1.4.12. We can verify the teleportation protocol for two qubits.</p><!-- Meanless: 104 1.4. Adding extra structure-->
<hr>
<p>Bell_state = Circuit.caps(qubit ** 2, qubit ** 2)
Bell_effect = Circuit.cups(qubit ** 2, qubit ** 2)
assert (Bell_state @ qubit ** 2 >> qubit ** 2 @ Bell_effect).eval(   )\
== (qubit ** 2).eval(   )\
== (qubit ** 2 @ Bell_state >> Bell_effect @ qubit ** 2).eval(   )</p>
<hr>
<p>rigid.Functor is implemented as a subclass of monoidal.Functor with the magic method _____ call_____ overriden. The image on types and on objects x with \(\mathrm{x}.\mathrm{z} = 0\) remains unchanged. The image on objects \(\mathrm{x}\) with \(\mathrm{x}.\mathrm{z} &#x3C; 0\) is defined by \(F\left( x\right)  = F\left( {x,r}\right)\) . 1 and symmetrically for \(x,z > 0\) . Indeed,when defining a strict rigid functor we only need to define the image of basic types, the image of their iterated adjoints is completely determined. The only problem arises when the objects in the codomain do not have 1 and \(r\) attributes,such as the implementation of Tensor \({}_{\mathbb{S}}\) with list [int] as objects. In this case,we assume that the left and right adjoints are given by list reversal.</p>
<!-- Media -->
<p>Listing 1.4.13. Implementation of strict rigid functors.</p>
<hr>
<p>class Functor (monoidal.Functor) :
dom = cod = Category(Ty, Diagram)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other,Ty) or isinstance(other,Ob) and other.z == 0 :
return super(   ).<strong>call</strong>(other)
if isinstance(other, Ob):
if not hasattr(self.cod.ob, 'l' if other.z &#x3C; 0 else 'r'):
return self(Ob(other.name, z=0)) [::-1]
return self(other.r).l if other.z &#x3C; 0 else self(other.l).r
if isinstance(other, Cup):
return self.cod.ar.cups(self(other.dom[:1]), self(other.dom[1:]))
if isinstance(other, Cap):
return self.cod.ar.caps(self(other.cod[:1]), self(other.cod[1:]))
return super(   ).<strong>call</strong>(other)</p>
<hr>
<!-- Media -->
<p>Listing 1.4.14. Implementation of \({\mathbf{{Tensor}}}_{\mathbb{S}}\) as a pivotal category.</p>
<hr>
<p>Tensor.cups = classmethod(lambda cls, x, y: cls(cls.id(x).inside, x + y, (   )))
Tensor.caps = classmethod(lambda cls, x, y: cls(cls.id(x).inside, (   ), x + y))</p>
<hr>
<p>Example 1.4.15. We can check that Tensor \(\mathbb{S}\) is indeed pivotal.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 105-->
<hr>
<p>F = Functor(   )
ob={x: 2, y: 3}, ar={f: [[1, 2], [3, 4], [5, 6]]},
cod=Category(tuple[int, ...], Tensor[int]))
assert F(left_snake) == F(Diagram.id(t.l)) == F(right_snake)
assert F(f.transpose(   )) == F(f).transpose(   ) == F(f.transpose(left=False))
#Diagrammatic and algebraic transpose differ for tensors of order >= 2.
assert \(F\left( {f \otimes  x}\right)\) .transpose(   ) != \(F\left( {\left( {f \otimes  x}\right) \text{.transpose())}}\right)\)</p>
<hr>
<p>Free pivotal categories are defined in a similar way to free rigid categories, with the two-element field \(\mathbb{Z}/2\mathbb{Z}\) instead of the integers \(\mathbb{Z}\) ,i.e. simple types with adjunction numbers of the same parity are equal. In this case, we usually write \({x}^{l} = {x}^{r} = {x}^{ \star  }\) with \({\left( {x}^{ \star  }\right) }^{ \star  } = x\) . Given a pivotal signature \(\sum\) with objects of the form \({\sum }_{0} \times  \left( {\mathbb{Z}/2\mathbb{Z}}\right)\) ,the free pivotal category is the quotient \({F}^{p}\left( \sum \right)  = {F}^{r}\left( \sum \right) /R\) of the free rigid category by the relation \(R\) equating the left and right transpose of the identity for each generating object. While the diagrams of free rigid categories can have snakes, those of free pivotal categories can have circles: we can compose \(\operatorname{cap}\left( x\right)  : 1 \rightarrow  {x}^{l} \otimes  x\) then \(\operatorname{cup}\left( {x}^{ \star  }\right)  : {x}^{l} \otimes  x \rightarrow  1\) to form a scalar diagram called the dimension of the system \(x\) . We also draw the wires with an orientation: the wire for \(x\) is labeled with an arrow going down,the one for \({x}^{ \star  }\) with an arrow going up.</p>
<p>To the best of our knowledge, the word problem for pivotal categories is still open. When defining the normal form of pivotal diagrams, we would need to make a choice between the diagrams for left or right transpose of a box. Another solution is to add a new box \({f}^{T} : {y}^{ \star  } \rightarrow  {x}^{ \star  }\) for the transpose of every box \(f : x \rightarrow  y\) in the signature, and set it as the normal form of both diagrams. We can add some asymmetry to the drawing of the box \(f\) ,and draw \({f}^{T}\) as its \({180}^{ \circ  }\) degree rotation. If the category is also \(\dagger\) -pivotal,we get a four-fold symmetry: the box, its dagger, its transpose and its dagger-transpose (also called its conjugate). This is still being developed by the DisCoPy community.</p>
<!-- Media -->
<p>Listing 1.4.16. Implementation of free †-pivotal categories.</p>
<hr>
<p>class Ob(rigid.Ob):
l = r = property(lambda self: self.cast(0b(self.name, (self.z + 1) % 2)))
class Ty (rigid. Ty, Ob):
def <strong>init</strong>(self, inside=(   )):
rigid.Ty.<em><strong><strong>init</strong></strong></em>(self, inside=tuple(map(Ob.cast, inside)))</p>
<hr><!-- Meanless: 106 1.4. Adding extra structure-->
<hr>
<p>class Diagram (rigid. Diagram): pass
class Box (rigid. Box, Diagram):
cast = Diagram.cast
class Cup (rigid. Cup, Box):
def dagger(self):
return Cap(self.dom[0], self.dom[1])
class Cap (rigid. Cap, Box):
def dagger(self):
return Cup ( self.cod [0] , self.cod [1] )
Diagram.cups, Diagram.caps = nesting(Cup), nesting(Cap)
class Functor (rigid. Functor) :
dom = cod = Category(Ty, Diagram)</p>
<hr>
<!-- Media -->
<h4>1.4.2 Braided categories &#x26; wire crossing</h4>
<p>With rigid and pivotal categories, we have removed the assumption that diagrams are progressive: we can bend wires. With braided and symmetric monoidal categories, we now remove the planarity assumption: wires can cross.</p>
<p>The data for a braided category is that of a monoidal category \(C\) together with a brading natural isomorphism \(B\left( {x,y}\right)  : x \otimes  y \rightarrow  y \otimes  x\) (and its inverse \({B}^{-1}\) ) drawn as a wire for \(x\) crossing under (over) a wire \(y\) . Braidings are subject to the following hexagon equations:</p>
<ul>
<li>\(B\left( {x,y \otimes  z}\right)  = B\left( {x,y}\right)  \otimes  z\) ; \(y \otimes  B\left( {x,z}\right)\) ,</li>
</ul>
<!-- Media -->
<!-- figureText: \( x \) \( x \) \( y \) \( y \) \( x \) \( x \) \( y \otimes  z \) \( x \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_105.jpg?x=532&#x26;y=1627&#x26;w=589&#x26;h=276&#x26;r=0">
<!-- Media -->
<ul>
<li>\(B\left( {x \otimes  y,z}\right)  = x \otimes  B\left( {y,z}\right)\) о \(B\left( {x,z}\right)  \otimes  y\) which owe their name to the shape of the corresponding commutative diagrams when \(C\) is non-strict monoidal. We also require that \(B\left( {x,1}\right)  = \operatorname{id}\left( x\right)  = B{\left( 1,x\right) }^{1}\) , i.e. braiding a wire \(x\) with the unit 1 does nothing,we do not need to draw it. The hexagon equations may be taken as an inductive definition: we can decompose the braiding \(B\left( {x,y \otimes  z}\right)\) of an object with a tensor in terms of two simpler braids \(B\left( {x,y}\right)\) and \(B\left( {x,z}\right)\) . Thus,we can take the data for a braided category to be that of a foo-monoidal category together with a pair of functions \(B,{B}^{-1} : {C}_{0} \times  {C}_{0} \rightarrow  {C}_{1}\) which send a pair of generating objects to their braiding and its inverse. Once we have specified the braids of generating objects, the braids of any type (i.e. list of objects) is uniquely determined. A monoidal functor \(F : C \rightarrow  D\) between two braided categories \(C\) and \(D\) is braided when \(F\left( {B\left( {x,y}\right) }\right)  = B\left( {F\left( x\right) ,F\left( y\right) }\right)\) . Thus, we get a category BraidCat with a forgetful functor \(U :\) BraidCat \(\rightarrow\) MonSig, we now describe its left adjoint.</li>
</ul><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 103-->
<!-- Media -->
<!-- figureText: \( y \) \( x \) \( y \) \( z \) \( y \) \( x \) \( x \otimes  y \) \( z \) \( x \otimes  y \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_106.jpg?x=612&#x26;y=286&#x26;w=588&#x26;h=278&#x26;r=0">
<!-- Media -->
<p>Given a monoidal signature \(\sum\) ,the free braided category is a quotient \({F}^{B}\left( \sum \right)  =\) \(F\left( {\sum }^{B}\right) /R\) of the free monoidal category generated by \({\sum }^{B} = \sum  \cup  B \cup  {B}^{-1}\) for the braiding \(B\left( {x,y}\right)  : x \otimes  y \rightarrow  y \otimes  x\) and its inverse \({B}^{-1}\left( {x,y}\right)  : y \otimes  x \rightarrow  x \otimes  y\) for each pair of generating objects \(x,y \in  {\sum }_{0}\) . The relation \(R\) is given by the following axioms for a natural isomorphism:</p>
<p></p>\[\text{-}B\left( {x,y}\right) {}_{9}^{ \circ  }{B}^{-1}\left( {y,x}\right)  = \operatorname{id}\left( {x \otimes  y}\right)  = {B}^{-1}\left( {y,x}\right) {}_{9}^{ \circ  }B\left( {x,y}\right) \text{,}\]<p></p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_106.jpg?x=572&#x26;y=1582&#x26;w=648&#x26;h=200&#x26;r=0">
<!-- Media -->
<ul>
<li>\(f \otimes  x\)  \(\square B\left( {b,x}\right)  = B\left( {a,x}\right) \mathring{} x \otimes  f\) and \(x \otimes  f\mathring{} B\left( {x,b}\right)  = B\left( {x,a}\right) \mathring{} f \otimes  x\) . for all generating objects \(x,y \in  {\sum }_{0}\) and boxes (including braidings) \(f : a \rightarrow  b\) in \({\sum }^{B}\) . From \(B\) being an isomorphism on generating objects,we can prove it is self-inverse on any type by induction. Similarly,from \(B\) being natural on the left and right for each box, we can prove by induction that it is in fact natural for any diagram. Note that the naturality axiom holds for boxes with domains and codomains of arbitrary length. In particular,it holds for \(f = B\left( {y,z}\right)\) in which case we get the following Yang-Baxter equation:</li>
</ul>
<!-- Media -->
<!-- figureText: \( a \) \( x \) \( x \) - -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_106.jpg?x=299&#x26;y=1876&#x26;w=1153&#x26;h=194&#x26;r=0">
<!-- Media -->
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Note that in a non-strict monoidal category this axiom is unnecessary,it follows from the coherence conditions.</p>
<!-- Footnote -->
<hr><!-- Meanless: 108 1.4. Adding extra structure-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_107.jpg?x=507&#x26;y=659&#x26;w=552&#x26;h=275&#x26;r=0">
<!-- Media -->
<p>It also holds for any scalar \(f : 1 \rightarrow  1\) ,which allows to pass them through a wire:</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_107.jpg?x=583&#x26;y=1010&#x26;w=396&#x26;h=108&#x26;r=0">
<!-- Media -->
<p>A braided category \(C\) is symmetric if the braiding \(B\) is its own inverse \(B =\) \({B}^{-1} = S\) ,in this case it is called a swap and drawn as the intersection of two wires. A symmetric functor is a braided functor between symmetric categories. A \(\dagger\) -braided category is a braided category with a dagger structure,such that the braidings are unitaries,i.e. their inverse is also their dagger. A †-symmetric category is a \(\dagger\) -braided category that is also symmetric.</p>
<p>Remark 1.4.17. A symmetric (braided) category with one generating object is called a PROP (PROB) for PROduct and Permutation (Braid). Indeed, the arrows of the free PROP with no generating boxes (i.e. only swaps) are permutations, the arrows of the free braided PRO with no boxes are called braids.</p>
<p>Both are groupoids, i.e. all their arrows are isomorphisms, which also implies that they are \(\dagger\) -braided with the dagger given by the inverse. For every \(n \in  \mathbb{N}\) , the arrows \(f : {x}^{n} \rightarrow  {x}^{n}\) in the free PROP (PROB) are the elements of the \(n\) -th symmetric group \({S}_{n}\) (braid group \({B}_{n}\) ).</p>
<p>DisCoPy implements free \(\dagger\) -symmetric ( \(\dagger\) -braided) categories with a class Swap (Braid) initialised by types of length one and a class method swap (braid) for types of arbitrary length. The method simplify cancels every braid followed by its inverse. The naturality method applies the naturality axiom to the box at a given index i: int. The optional argument left: bool allows to choose between left and right naturality axioms, down: bool allows to move the box either up or down</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 109-->
<p>the braid and braid: Callable allows to apply naturality to any subclass of Braid.</p>
<!-- Media -->
<p>Listing 1.4.18. Implementation of free \(\dagger\) -braided categories.</p>
<hr>
<p>class Diagram (monoidal.Diagram) :
def simplify(self):
for i, ((x, f, _), (y, g, _)) in enumerate(   )
zip(self.inside, self.inside[1:])):
if \(x =  = y\) and isinstance(f,Braid)and \(f =  = g\left\lbrack  { :  :  - 1}\right\rbrack\) :
inside = self.inside[:i] + self.inside[i + 2:]
return self.cast(Diagram(inside, self.dom, self.cod)).simplify(   )
return self
class Box (monoidal. Box, Diagram) :
cast = Diagram.cast
class Braid (Box):
def <strong>init</strong>(self, x: Ty, y: Ty, is_dagger=False):
assert len ( x ) == len ( y ) == 1
name = "{}({}, {})[::-1]".format(type(self), y, x) if is_dagger\
else "{}({}, {})".format(type(self), x, y)
super(   ).<em>init</em>(name, x @ y, y @ x, is_dagger)
def dagger(self): return Braid(*self.cod, is_dagger=not self.is_dagger)
def hexagon (factory) \(\rightarrow\) Callable:
def method(cls, x: Ty, y: Ty) -> Diagram:
if \(\operatorname{len}\left( \mathrm{x}\right)  =  = 0\) : return cls.id( \(\mathrm{y}\) )
if len ( x ) == 1 :
if \(\operatorname{len}\left( \mathrm{y}\right)  =  = 1\) : return \(\operatorname{factory}\left( {\mathrm{x}\left\lbrack  0\right\rbrack  ,\mathrm{y}\left\lbrack  0\right\rbrack  }\right)\)
return method(cls, x, y[:1]) @ cls.id(y[1:])\
>> cls.id(y[:1]) @ method(cls, x, y[1:]) # left hexagon equation.
return cls.id(x[:1]) @ method(cls, x[1:], y)\
>> method(cls, x[:1], y) @ cls.id(x[1:]) # right hexagon equation.
return classmethod(method)
Diagram.braid, Diagram.swap = hexagon(Braid), hexagon(Swap)
def naturality(self: Diagram, i: int, left=True, down=True, braid=None):
braid = braid or self.braid
layer, box = self.inside[i], self.inside[i].box
if left and down:
source = layer.left[-1] @ box >> braid(layer.left[-1], box.cod)
target = braid(layer.left[-1], box.dom) >> box @ layer.left[-1]</p>
<hr>
<!-- Media --><!-- Meanless: 110 1.4. Adding extra structure-->
<hr>
<pre><code>elif left: ...
elif down: ...
else:
	source = braid(layer.right[0], box.dom) >> box @ layer.right[0]
	target = layer.right[0] @ box >> braid(layer.right[0], box.cod)
match = Match(top=self[:i] if down else self[:i - len(source) + 1],
				bottom=self[i + len(source):] if down else self[i + 1:],
				left=layer.left[:-1] if left else layer.left,
				right=layer.right if left else layer.right[1:])
assert self == match.subs(source)
return match.subs(target)
</code></pre>
<p>Diagram.naturality = naturality
class Functor (monoidal.Functor) :
dom = cod = Category (Ty, Diagram)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Braid) and not other.is_dagger:
return self.cod.ar.braid(self(other.dom[0]), self(other.dom[1]))
return super(   ). _call (other)</p>
<hr>
<p>Example 1.4.19. We can check the hexagon equations hold on the nose.</p>
<hr>
<p>\(\mathrm{x},\mathrm{y},\mathrm{z} = \operatorname{map}\left( {\mathrm{{Ty}},\text{"xyz"}}\right)\)
assert Diagram.braid(x,y @ z) == Braid(x,y) @ z >> y @ Braid(x,z)
assert Diagram.braid(x @ y, z) == x @ Braid(y, z) >> Braid(x, z) @ y</p>
<hr>
<p>We can check that Braid is an isomorphism up to a simplify call.</p>
<hr>
<p>assert (Diagram braid(x, y @ z) >> Diagram braid(x, y @ z)[::-1]) simplify(   )
== Diagram.id(x @ y @ z)\
== (Diagram.braid(y @ z, x)[::-1] >> Diagram.braid(y @ z, x)).simplify(   )</p>
<hr>
<p>We can check that Braid and its dagger are natural.</p>
<hr>
<p>\(a,b = {Ty}\left( {1{a}^{\prime }}\right) ,{Ty}\left( {1{b}^{\prime }}\right)\)
f = Box \(\left( {{}^{\prime }{f}^{\prime },a,b}\right)\)
for braid in [Diagram.braid, (lambda x, y: Diagram.braid(y, x)[::-1])]:
source, target = x @ f >> braid(x, b), braid(x, a) >> f @ x
assert source.naturality \(\left( {0\text{,braid=braid}}\right)  =  =\) target
assert target.naturality(1, left=False, down=False, braid=braid) == source</p>
<hr>
<p>Listing 1.4.20. Implementation of free \(\dagger\) -symmetric categories.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 111-->
<!-- Media -->
<p>class Diagram (braided.Diagram): pass</p>
<hr>
<p>class Box (braided.Box, Diagram) :
cast = Diagram.cast
class Swap (Braid, Box) :
def dagger(self): return Swap(*self.cod)
Diagram.braid = Diagram.swap = hexagon(Swap)
class Functor (braided.Functor) :
dom = cod = Category(Ty, Diagram)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Swap):
return self.cod.ar.swap(self(other.dom[0]), self(other.dom[1]))
return super(   ). <em><strong><strong>call</strong></strong></em>(other)</p>
<hr>
<!-- Media -->
<p>Listing 1.4.21. Implementation of Pyth and Tensor \({}_{\mathbb{S}}\) as symmetric categories.</p>
<!-- Media -->
<hr>
<p>@staticmethod
def function_swap(x: tuple[type, ...], y: tuple[type, ...]) -> Function:
def inside(*xs):
return untuplify(tuplify(xs)[len(x):] + tuplify(xs)[:len(x)])
return Function (inside, dom=x + y, cod=y + x)
Function.swap = Function.braid = function_swap
@classmethod
def tensor_swap(cls, x: tuple[int, ...], y: tuple[int, ...]) -> Tensor:
inside = [[(i0, j0) == (i1, j1)
for j0 in range(product(y)) for i0 in range(product(x))]
for i1 in range(product(x)) for j1 in range(product(y))
return cls(inside,dom=x + y, cod=y + x)
Tensor.swap = Tensor.braid = tensor_swap</p>
<hr>
<!-- Media -->
<p>Example 1.4.22. We can check the axioms for symmetric categories hold in \({\text{Tensor}}_{\mathbb{S}}\) and Pyth.</p>
<hr>
<pre><code>swap_twice = Diagram.swap(x, y @ z) >> Diagram.swap(y @ z, x)
</code></pre>
<p>F = Functor (   )</p>
<hr><!-- Meanless: 112 1.4. Adding extra structure-->
<!-- Media -->
<hr>
<pre><code>ob=\{a: 1, b: 2, x: 3, y: 4, z: 5\},
ar=\{f: [[1-2j, 3+4j]]\},
cod=Category(tuple[int, ...], Tensor[complex]))
</code></pre>
<p>assert \(\mathrm{F}\left( {\mathrm{f}@\mathrm{x} > \mathrm{{Swap}}\left( {\mathrm{b},\mathrm{x}}\right) }\right)  =  = \mathrm{F}\left( {\mathrm{{Swap}}\left( {\mathrm{a},\mathrm{x}}\right)  >  > \mathrm{x}@\mathrm{f}}\right)\)
assert \(\mathrm{F}\left( {\mathrm{x}@\mathrm{f} >  > \operatorname{Swap}\left( {\mathrm{x},\mathrm{b}}\right) }\right)  =  = \mathrm{F}\left( {\operatorname{Swap}\left( {\mathrm{x},\mathrm{a}}\right)  >  > \mathrm{f}@\mathrm{x}}\right)\)
assert F(swap_twice) == Tensor.id(F(x @ y @ z))
G = Functor (   )
ob={a: complex, b: float, x: int, y: bool, z: str},
ar={f: lambda z: abs(z) ** 2},
cod=Category (tuple [type, ...], Function))
assert \(G\left( {f@x >  > \operatorname{Swap}\left( {b,x}\right) }\right) \left( {{1j},2}\right)  =  = G\left( {\operatorname{Swap}\left( {a,x}\right)  >  > x@f}\right) \left( {{1j},2}\right)\)
assert \(G\left( {x@f >  > {Swap}\left( {x,b}\right) }\right) \left( {2,{1j}}\right)  =  = G\left( {{Swap}\left( {x,a}\right)  >  > f@x}\right) \left( {2,{1j}}\right)\)
assert G(swap_twice)(42, True, "foo") == (42, True, "foo")</p>
<hr>
<!-- Media -->
<p>Remark 1.4.23. Note that the naturality axioms in Pyth hold only for its subcategory of pure functions,as we will see in section 1.5 Pyth is in fact a symmetric premonoidal category. This is also the case for Tensor \({}_{\mathbb{S}}\) when the rig \(\mathbb{S}\) is noncommutative.</p>
<p>A compact closed category is one that is both rigid and symmetric, which implies that it is also pivotal; a \(\dagger\) -compact closed category is both \(\dagger\) -pivotal and \(\dagger\) -symmetric. The arrows of free \(\dagger\) -compact closed categories (i.e. equivalence classes of diagrams with cups, caps and swaps) are also called tensor networks, a graphical equivalent to Einstein notation and abstract index notation, first introduced by Penrose [Pen71]. Unlike the computer scientists however, physicists tend to identify the diagram (syntax) with its image under some interpretation functor to the category of tensors (semantics).</p>
<p>A tortile category,also called a ribbon category \({}^{1}\) ,is a braided,pivotal category which furthermore satisfies the following untwisting equation: The scalars of the free tortile category with no boxes (i.e. equivalence classes of diagrams with only cups, caps and braids) are called links in general and knots when they are connected. Untwisting, the self-inverse equation and the Yang-Baxter equation (i.e. naturality with respect to braids) are called the three Reidemeister moves, they completely characterise the continuous deformations of circles embedded in three-dimensional space [Rei13].</p>
<!-- Media -->
<!-- figureText: \( {x}^{ \star  } \) \( x \) \( x \) \( x \) \( x \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_111.jpg?x=585&#x26;y=1726&#x26;w=389&#x26;h=264&#x26;r=0">
<!-- Media -->
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Here again we take a strict definition,where the twist is an identity rather than an isomorphism. In a non-strict tortile category, the wires would be drawn as ribbons, i.e. two wires side by side. The twist isomorphism would be drawn as the two wires being braided twice. In a strict tortile category, the ribbon has no width thus the twist is invisible.</p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 113-->
<p>The unknotting problem (given a knot, can it be untied, i.e. continuously deformed to a circle?) is a candidate NP-intermediate problem: it is decidable [Hak61] and in NP [Lac15], but there is neither a proof of it being NP-complete nor a polynomial-time algorithm. Delpeuch and Vicary [DV21] proved that the word problem for free braided categories is unknotting-hard. Hence, there is little hope of finding a simple polynomial-time algorithm for computing normal forms of braided diagrams. It is not known whether it is even decidable.</p>
<p>The word problem for free symmetric categories reduces to the graph isomorphism problem [PSV21], another potential NP-intermediate problem. The word problem for free compact closed categories also reduces to graph isomorphism [Sel07]. To the best of our knowledge, it is not known whether they are graph-isomorphism-hard, i.e. whether there is a reduction the other way around that sends any graph to a diagram with swaps (and cups and caps) so that graphs are isomorphic if and only their diagrams are equal. Thus, there could be a simple polynomial-time algorithm for computing normal forms of diagrams in symmetric and compact closed categories. In any case, DisCoPy does not implement any normal forms for diagrams with braids yet.</p>
<p>Of course, we can also enrich rigid and braided categories in commutative monoids, i.e. we can take formal sums of diagrams with cups, caps and braids in the same way as any other box. We can also define bubbles and draw them in the same way as for monoidal diagrams.</p>
<!-- Media -->
<p>Listing 1.4.24. Implementation of free tortile categories and functors.</p>
<hr>
<p>class Ty (pivotal.Ty, braided.Ty): pass
class Diagram(pivotal.Diagram, braided.Diagram): pass
class Box (pivotal. Box, braided. Box, Diagram):
cast = Diagram.cast
class Cup (pivotal. Cup, Box): pass
class Cap(pivotal.Cap, Box): pass
class Braid (braided. Braid, Box): pass
Diagram.braid = hexagon (Braid)</p>
<hr>
<!-- Media --><!-- Meanless: 114 1.4. Adding extra structure-->
<hr>
<p>Diagram.cups, Diagram.caps = nesting(Cup), nesting(Cap)
class Functor (pivotal.Functor, braided.Functor):
dom = cod = Category(Ty, Diagram)
def _call <em>(self, other) :
if isinstance(other, Braid):
return braided.Functor.<em>call</em>(self, other)
return pivotal.Functor.<em>call</em></em>(self, other)</p>
<hr>
<p>Example 1.4.25. We can define knot polynomials such as the Kauffman bracket using tortile functors into a self-dual category where the braiding is defined as a weighted sum of diagrams.</p>
<hr>
<p>Ty.l = Ty.r = property (lambda self: self)
\(\mathrm{x},\mathrm{A} = \mathrm{{Ty}}\left( {{}^{\prime }{\mathrm{x}}^{\prime }}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{A}}^{\prime },\mathrm{{Ty}}\left( \right) ,\mathrm{{Ty}}\left( \right) }\right)\)
class Polynomial (Diagram) :
def braid(x, y) :
return ( A @ x @ y ) + (Cup(x, y) >> A.dagger(   ) >> Cap(x, y))
Kauffman = Functor (   )
ob={x: x}, ar={}, cod=Category(Ty, Polynomial))</p>
<hr>
<p>drawing.equation (Braid(x, x).bubble(   ), Kauffman(Braid(x, x)))</p>
<!-- Media -->
<!-- figureText: \( {A}^{ \dagger  } \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_113.jpg?x=372&#x26;y=1381&#x26;w=818&#x26;h=265&#x26;r=0">
<!-- Media -->
<h4>1.4.3 Hypergraph categories &#x26; wire splitting</h4>
<p>With compact closed and tortile categories, we have removed both the progressivity and the planarity assumptions: wires can bend and cross. With hypergraph categories we remove the assumption that diagrams are graphs: wires can split and merge, they need not be homeomorphic to an open interval. A hypergraph category is a symmetric category with coherent special commutative spiders, let's spell out what this means.</p>
<p>An object \(x\) in a monoidal category \(C\) has spiders with phases in a monoid \(\left( {\Phi ,+,0}\right)\) if it comes equipped with a family of arrows spider \({}_{\phi ,a,b}\left( x\right)  : {x}^{a} \rightarrow  {x}^{b}\) for every phase \(\phi  \in  \Phi\) and pair of natural numbers \(a,b \in  \mathbb{N}\) ,such that the following spider fusion equation holds for all \(a,b,c,d,n \in  \mathbb{N}\) .</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 115-->
<p></p>\[{\operatorname{spider}}_{\phi ,a,c + n + 1}\left( x\right)  \otimes  {x}^{b},{x}^{c} \otimes  {\operatorname{spider}}_{{\phi }^{\prime },c + n + 1,d}\left( x\right)  = {\operatorname{spider}}_{\phi  + {\phi }^{\prime },a + b,c + d}\left( x\right)\]<p></p>
<p>We also require that our spiders satisfy the special condition \({\operatorname{spider}}_{0,1,1}\left( x\right)  = \operatorname{id}\left( x\right)\) . Spiders owe their name to their arachnomorphic drawing,for example spider \({}_{\phi ,2,6}\) is drawn as a node (the head, labeled by its phase when it's non-zero) and its wires (the eight legs of the spider, two of them menacing us):</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_114.jpg?x=646&#x26;y=752&#x26;w=416&#x26;h=104&#x26;r=0">
<!-- Media -->
<p>Once drawn, the spider fusion equation has the intuitive graphical meaning that if one or more legs of two spiders touch, they fuse and add up their phase.</p>
<!-- Media -->
<!-- figureText: \( {x}^{a} \) \( {x}^{b} \) \( {x}^{a} \) \( {x}^{b} \) \( {x}^{d} \) \( {x}^{c} \) \( x \) \( {x}^{n} \) \( {x}^{d} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_114.jpg?x=577&#x26;y=982&#x26;w=562&#x26;h=198&#x26;r=0">
<!-- Media -->
<p>From spider fusion, we can deduce the following properties:</p>
<ul>
<li>merge \(\left( x\right)  = {\operatorname{spider}}_{0,2,1}\left( x\right)\) and unit \(\left( x\right)  = {\operatorname{spider}}_{0,0,1}\left( x\right)\) form a monoid,</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_114.jpg?x=354&#x26;y=1353&#x26;w=1093&#x26;h=144&#x26;r=0">
<!-- Media -->
<ul>
<li>split \(\left( x\right)  = {\operatorname{spider}}_{0,1,2}\left( x\right)\) and counit \(\left( x\right)  = {\operatorname{spider}}_{0,1,0}\left( x\right)\) form a comonoid,</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_114.jpg?x=350&#x26;y=1613&#x26;w=1095&#x26;h=146&#x26;r=0">
<!-- Media -->
<ul>
<li>split(x), merge \(\left( x\right)  = \operatorname{id}\left( x\right)\) , called the special condition,</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_114.jpg?x=789&#x26;y=1875&#x26;w=217&#x26;h=140&#x26;r=0">
<!-- Media -->
<ul>
<li>merge \(\left( x\right)  \otimes  x\) ’ \(\otimes  x \otimes  \operatorname{split}\left( x\right)  = x \otimes\) merge(x)’ \(\operatorname{split}\left( x\right)  \otimes  x\) ’called the Frobenius law.</li>
</ul><!-- Meanless: 116 1.4. Adding extra structure-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_115.jpg?x=621&#x26;y=297&#x26;w=396&#x26;h=143&#x26;r=0">
<!-- Media -->
<p>In fact,when the phases are trivial \(\Phi  = \{ 0\}\) these four axioms are sufficient to deduce spider fusion, spiders are also called special Frobenius algebras. Indeed, given a monoid merge \(\left( x\right)  : x \otimes  x \rightarrow  x\) ,unit \(\left( x\right)  : 1 \rightarrow  x\) and a comonoid split(x): \(x \rightarrow  x \otimes  x\) ,counit \(\left( x\right)  : x \rightarrow  1\) subject to the Frobenius law,we can construct \({\operatorname{spider}}_{a,b}\left( x\right)  : {x}^{a} \rightarrow  {x}^{b}\) by induction on the number of legs. The base case is given by the special condition \({\operatorname{spider}}_{1,1}\left( x\right)  = \operatorname{id}\left( x\right)\) . Then we define spiders with \(a \in  \mathbb{N}\) input legs for \(a \neq  1\) :</p>
<ul>
<li>
<p>spider \({}_{0,b}\left( x\right)  = \operatorname{unit}\left( x\right) {}_{9}^{ \circ  }{\operatorname{spider}}_{1,b}\left( x\right)\) ,</p>
</li>
<li>
<p>spider \({}_{a + 2,b}\left( x\right)  =\) merge \(\left( x\right)  \otimes  {x}^{a}\) , \({\operatorname{spider}}_{a + 1,b}\left( x\right)\) ,</p>
</li>
</ul>
<!-- Media -->
<!-- figureText: \( x \) \( x \) \( {x}^{a} \) \( x \) \( x \) \( {x}^{a} \) \( x \) \( {x}^{b} \) \( {x}^{b} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_115.jpg?x=808&#x26;y=1003&#x26;w=559&#x26;h=200&#x26;r=0">
<!-- figureText: \( \varphi  = \left\{  \begin{array}{ll} 0 & x \\  {x}^{b} & 0 \end{array}\right. \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_115.jpg?x=192&#x26;y=1047&#x26;w=250&#x26;h=157&#x26;r=0">
<!-- Media -->
<p>Finally we define spiders with one input leg by induction on the output legs \(b \in  \mathbb{N}\) :</p>
<ul>
<li>
<p>spider \({}_{1,0}\left( x\right)  =\) counit(x),</p>
</li>
<li>
<p>spider \({}_{1,b + 2}\left( x\right)  = {\operatorname{spider}}_{1,b + 1}\left( x\right)\) " \(\operatorname{split}\left( x\right)  \otimes  {x}^{b}\) .</p>
</li>
</ul>
<!-- Media -->
<!-- figureText: \( x \) \( x \) \( x \) \( {x}^{b} \) \( x \) \( x \) \( x \) \( x \) \( {x}^{b} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_115.jpg?x=542&#x26;y=1457&#x26;w=555&#x26;h=190&#x26;r=0">
<!-- Media -->
<p>One can show that this satisfies the spider fusion law, again by induction on the legs [HV19, Lemma 5.20]. In this way, we can construct an infinite family of spiders from just the four boxes merge(x),unit(x),split(x),counit(x)and a finite set of equations: a spider is nothing but a big multiplication followed by a big co-multiplication. As for the phases, we can recover them from a family of phase shifts \({\left\{  {\operatorname{shift}}_{\phi }\left( x\right)  : x \rightarrow  x\right\}  }_{\phi  \in  \Phi }\) such that:</p>
<ul>
<li>shift_(x) is a monoid homomorphism \(\Phi  \rightarrow  C\left( {x,x}\right)\) ,i.e. shift \({\mathfrak{t}}_{0}\left( x\right)  = \operatorname{id}\left( x\right)\) and \({\operatorname{shift}}_{\phi }{\left( x\right) }_{9}^{ \circ  }{\operatorname{shift}}_{{\phi }^{\prime }} = {\operatorname{shift}}_{\phi  + {\phi }^{\prime }}\left( x\right)\) ,</li>
</ul><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 117-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_116.jpg?x=775&#x26;y=297&#x26;w=253&#x26;h=182&#x26;r=0">
<!-- Media -->
<ul>
<li>phase shifts commute with the product, \({\operatorname{shift}}_{\phi }\left( x\right)  \otimes  x\) , \({}_{9}^{ \circ  }\) merge \(\left( x\right)  =\) \(\operatorname{merge}\left( x\right)  \circ  {\operatorname{shift}}_{\phi }\left( x\right)  = x \otimes  {\operatorname{shift}}_{\phi }\left( x\right)  \circ  {\operatorname{merge}}^{2}\left( x\right) ,\)</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_116.jpg?x=576&#x26;y=633&#x26;w=649&#x26;h=179&#x26;r=0">
<!-- Media -->
<ul>
<li>phase shifts commute with the coproduct,split(x), \({\operatorname{shift}}_{\phi }\left( x\right)  \otimes  x =\) \({\operatorname{shift}}_{\phi }\left( x\right)\) " \(\operatorname{split}\left( x\right)  = x \otimes  \operatorname{split}\left( x\right)\) " \({\operatorname{shift}}_{\phi }\left( x\right) .\)</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_116.jpg?x=574&#x26;y=960&#x26;w=650&#x26;h=182&#x26;r=0">
<!-- Media -->
<p>We can then define \({\operatorname{spider}}_{\phi ,a,b}\left( x\right)  = {\operatorname{spider}}_{a,1}\left( x\right)\) go \({\operatorname{shift}}_{\phi }\left( x\right)\) ’ \({\operatorname{spider}}_{1,b}\left( x\right)\) and check that indeed, spiders fuse up to addition of their phase. Thus when the monoid is finite, we get a finite number of boxes and equations, i.e. a finite presentation of the spiders. In fact instead of taking it as data, we could have equivalently defined the monoid of phases \(\Phi\) as the set of endomorphisms \(x \rightarrow  x\) that satisfy the last two conditions.</p>
<p>Remark 1.4.26. Given any Frobenius algebra on an object \(x\) ,we can show that \(x\) is its own left and right adjoint. Indeed,take \(\operatorname{cup}\left( x\right)  = \operatorname{unit}\left( x\right)\) ,split(x)and \(\operatorname{cap}\left( x\right)  = \operatorname{merge}\left( x\right)\) ; \(\operatorname{counit}\left( x\right)\) ,then the Frobenius law and the (co)unit law of the (co)monoid implies the snake equations. Thus, a category with (not-necessarily special) spiders on every object is automatically a pivotal category.</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_116.jpg?x=593&#x26;y=1765&#x26;w=527&#x26;h=259&#x26;r=0">
<!-- Media -->
<p>Example 1.4.27. In any pivotal category, there is a Frobenius algebra for every object of the form \({x}^{ \star  } \otimes  x\) given by:</p><!-- Meanless: 118 1.4. Adding extra structure-->
<ul>
<li>
<p>merge \(\left( {{x}^{ \star  } \otimes  x}\right)  = {x}^{ \star  } \otimes  \operatorname{cup}\left( {x}^{ \star  }\right)  \otimes  x\) and \(\operatorname{unit}\left( x\right)  = \operatorname{cap}\left( x\right)\) ,</p>
</li>
<li>
<p>split \(\left( {{x}^{ \star  } \otimes  x}\right)  = {x}^{ \star  } \otimes  \operatorname{cap}\left( x\right)  \otimes  x\) and \(\operatorname{counit}\left( x\right)  = \operatorname{cup}\left( {x}^{ \star  }\right)\) .</p>
</li>
</ul>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_117.jpg?x=229&#x26;y=446&#x26;w=1103&#x26;h=121&#x26;r=0">
<!-- Media -->
<p>Due to the drawing of its comonoid, this is called the pair of pants algebra. The special condition requires the dimension of the system \(x\) to be the unit,i.e. the circle is equal to the empty diagram. Non-special Frobenius algebras can still be drawn as spiders, they satisfy a modifed version of spider fusion where we keep track of the number of circles, i.e. the number of splits followed by a merge. We can extend our inductive definition so that all the circles are in between the product and coproduct, see [HV19, Theorem 5.21].</p>
<p>Example 1.4.28. The category Tensor \({}_{\mathbb{S}}\) has spiders for every dimension \(n \in  \mathbb{N}\) with phases in any submonoid of \(\phi  \in  {\left( \mathbb{S},\times ,1\right) }^{n}\) . They are given by \({\operatorname{spider}}_{\phi ,a,b}\left( n\right)  =\) \(\mathop{\sum }\limits_{{i \leq  n}}{\phi }_{i}{\left| i{\rangle }^{\otimes a}\langle i\right| }^{\otimes b}\) where \(\left| {i\rangle \left( {\langle i}\right) }\right|\) is the \(i\) -th basis row (column) vector.</p>
<hr>
<p>class Tensor:
...
@classmethod
def spider(cls, a: int, b: int, n: int, phase=None) -> Tensor:
phase = phase or n * [1]
inside = [[sum(phase)]] if not a and not b\
else [[phase[xs[0]] for xs in itertools.product(*b * [range(n)])
if all ( x == xs[0] for x in xs)]] \
if not a else cls.spider([], a + b, n).inside
return cls(inside, dom=a * [n], cod=b * [n])</p>
<hr>
<p>When \(\mathbb{S}\) is a feld,we can divide every \({\phi }_{i}\) by \({\phi }_{0}\) ,or equivalently require that \({\phi }_{0} = 1\) . Indeed,we can represent any spider with \({\phi }_{0} \neq  1\) as a spider with \({\phi }_{0} = 1\) multiplied by the scalar \({\phi }_{0}\) ,which is called a global phase. When \(\mathbb{S} = \mathbb{C}\) and \(n = 2\) , we usually take the monoid of phases to be the unit circle and write it in terms of addition of angles.</p>
<p>Example 1.4.29. In the category Circ of quantum circuits, if we allow post-selected measurements then we can construct spiders with the unit circle as phases. The spiders with no inputs legs are called the (generalised) GHZ states:</p>
<p></p>\[{\operatorname{spider}}_{\alpha ,0,b} = \left| {0{\rangle }^{\otimes b} + {e}^{i\alpha }}\right| 1{\rangle }^{\otimes b}\]<p></p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 119-->
<p>Note that we need to scale by \(\frac{1}{\sqrt{2}}\) to make this a normalised quantum state. The spiders with \(a > 0\) input legs can be thought of as measuring a qubits,post-selecting on all of them giving the same result and then preparing \(b\) copies of this result. The evaluation functor \({\mathbf{{Circ}}}_{ \rightarrow  }{\mathbf{{Tensor}}}_{\mathbb{C}}\) sends spiders to spiders.</p>
<p>Spiders allow us to draw diagrams where wires can split and merge, connecting an arbitrary number of boxes. The PRO of Frobenius algebras (without the special condition), i.e. diagrams with only spider boxes, defines a notion of "well-behaved" 1d subspaces of the plane, up to continuous deformation. Indeed, it is equivalent to the category of planar thick tangles [Lau05]. Intuitively, planar thick tangles can be thought of as planar wires with a width, i.e. that we can draw with pens or pixels. The inductive definition of spiders in terms of monoids and comonoids has the topological interpretation that any wire can be deformed so that all its singular points (i.e. where the wire crosses itself) are binary splits and merges. The special condition has the non-topological consequence that we can contract the holes in the wires, splitting a wire then merging it back does nothing.</p>
<p>If the monoidal category \(C\) is braided,we can remove the planarity assumption and define commutative spiders as those where the monoid and comonoid are commutative, i.e.</p>
<p></p>\[{\operatorname{spider}}_{\phi ,a + b,c + d}\left( x\right) \text{ }。B\left( {{x}^{c},{x}^{d}}\right)  = {\operatorname{spider}}_{\phi ,a + b,c + d}\left( x\right)\]<p></p>
<p></p>\[= B\left( {{x}^{a},{x}^{b}}\right) \text{ э }{\operatorname{spider}}_{\phi ,a + b,c + d}\left( x\right)\]<p></p>
<!-- Media -->
<!-- figureText: \( \left( \begin{array}{l} {x}^{a} \\  {x}^{c} \\  {x}^{d} \end{array}\right) {x}^{d} = \left( \begin{array}{l} {x}^{a} \\  {x}^{c} \\  {x}^{d} \end{array}\right) {x}^{a} = \left( \begin{array}{l} {x}^{a} \\  {x}^{b} \\  {x}^{c} \end{array}\right)  = \left( \begin{array}{l} {x}^{a} \\  {x}^{b} \\  {x}^{c} \end{array}\right) {x}^{a} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_118.jpg?x=528&#x26;y=1409&#x26;w=658&#x26;h=206&#x26;r=0">
<!-- Media -->
<p>Together with spider fusion, this implies that the monoid of phases is also commutative. The PROB of commutative Frobenius algebras (without the special condition), i.e. diagrams with only spiders and braids, defines a notion of "well-behaved" 1d subspaces of \(3\mathrm{\;d}\) space,up to continuous deformation. When the category is furthermore symmetric, the PROP of commutative spiders defines a notion of "well-behaved" 1d spaces up to diffeomorphism, or equivalently 1d subspaces of 4d space, i.e. one where wires can pass through each other and all knots untie. It is equivalent to the category of two-dimensional cobordisms [Abr96], i.e. oriented 2d manifolds with a disjoint union of circles as boundary. Intuitively, a 2d cobordism can be thought of as a (non-planar) wire with a width, i.e. one that we can draw.</p><!-- Meanless: 120 1.4. Adding extra structure-->
<p>When \(C\) is braided,we can also give an inductive definition of spiders for tensors. Indeed,given the spiders for \(x\) and \(y\) we can construct the following comonoid:</p>
<ul>
<li>spider \({}_{1,0}\left( {x \otimes  y}\right)  = {\operatorname{spider}}_{1,0}\left( x\right)  \otimes  {\operatorname{spider}}_{1,0}\left( y\right)\) ,</li>
</ul>
<!-- Media -->
<!-- figureText: \( {\left. \mathop{\bigcup }\limits_{0}^{x}x \otimes  y\right| }_{0}^{y} = {\left. {b}^{x}\right| }_{0}^{y} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_119.jpg?x=630&#x26;y=505&#x26;w=392&#x26;h=160&#x26;r=0">
<!-- Media -->
<ul>
<li>spider \({}_{1,2}\left( {x \otimes  y}\right)  = {\operatorname{spider}}_{1,2}\left( x\right)  \otimes  {\operatorname{spider}}_{1,2}\left( y\right)\) ? \(x \otimes  S\left( {x,y}\right)  \otimes  y\)</li>
</ul>
<!-- Media -->
<!-- figureText: \( x \) \( y \) \( x \) \( y \) \( x \) \( x \) \( y \) \( y \) \( y \) \( x \) \( x \otimes  y \) \( x \otimes  y \) \( x \) \( y \) \( y \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_119.jpg?x=468&#x26;y=768&#x26;w=705&#x26;h=355&#x26;r=0">
<!-- Media -->
<p>and construct a monoid in a symmetric way, then show that they satisfy the spider fusion equations for \(x \otimes  y\) . We can also show that the identity of the unit defines a family of spiders,i.e. spider \({}_{a,b}\left( 1\right)  = \operatorname{id}\left( 1\right)\) . If we take them as axioms rather than definitions, these are called the coherence conditions for spiders.</p>
<p>Thus we get to our definition: a hypergraph category is a symmetric category with coherent special commutative spiders on each object. We can take the data to be that of a foo-monoidal category \(C\) together with a function spider : \(\mathbb{N} \times  \mathbb{N} \times\) \({C}_{0} \rightarrow  {C}_{1}\) or equivalenty,with four functions merge,unit,split,counit \(: {C}_{0} \rightarrow\) \({C}_{1}\) . Once we fix the spiders for generating objects,we get spiders for any type (i.e. list of objects). A hypergraph functor is a symmetric functor \(F : C \rightarrow  D\) between hypergraph categories such that \(F{}_{9}^{ \circ  }{\operatorname{spider}}_{a,b} = {\operatorname{spider}}_{a,b}{}_{9}^{ \circ  }F\) . Thus we get a category HypCat with a forgetful functor \(U :\) HypCat \(\rightarrow\) MonSig. Its left adjoint \({F}^{H} :\) MonSig \(\rightarrow\) HypCat is defined as a quotient \({F}^{S}\left( {\sum }^{H}\right) /R\) of the free symmetric category generated by \({\sum }^{H} = \sum\) spider and the relation \(R\) given by the equations for commutative spiders. Equivalently,we can take \({\sum }^{H} = \bigcup \{ \sum\) ,merge,unit,split,counit \(\}\) and \(R\) given by the equations for special commutative Frobenius algebras. A \(\dagger\) -hypergraph category is a \(\dagger\) -symmetric category (i.e. the swaps are unitaries) where the dagger is a hypergraph functor. We also require that the monoid of phases is in fact a group with the dagger as inverse or equivalently, that phase shifts are unitaries.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 121-->
<p>Example 1.4.30. For every commutative rig \(\mathbb{S}\) ,Tensor \(\mathbb{s}\) is a \(\dagger\) -hypergraph category with the transpose as dagger. Arguably, special commutative Frobenius algebras were first defined by Peirce [Pei06] with their interpretation in the category of relations,or equivalently \({\operatorname{Tensor}}_{\mathbb{B}}\) . Indeed,they correspond to what Peirce calls lines of identity: they express in two dimensions what one-dimensional first-order logic would express with equality symbols. For example, take a binary predicate encoded as a box \(p : 1 \rightarrow  {x}^{2}\) (interpreted as the formula \(\exists a \cdot  \exists b \cdot  p\left( {a,b}\right)\) ) then the diagram \(p\) ’ merge(x)is interpreted as the formula \(\exists a \cdot  \exists b \cdot  p\left( {a,b}\right)  \land  a = b\) or equivalently \(\exists a \cdot  p\left( {a,a}\right)\) . Thus,every first-order logic formula can be written as a diagram with boxes for predicates, spiders for identity and bubbles for negation. The equivalence of formulae can be defined as a quotient of a free hypergraph category with bubbles, i.e. all the rules of first-order logic can be given in terms of diagrams.</p>
<p>Example 1.4.31. The category of complex tensors \({\operatorname{Tensor}}_{\mathbb{C}}\) is \(\dagger\) -hypergraph with the spiders given in example 1.4.28. Any unitary matrix \(U : n \rightarrow  n\) defines another family of spiders \({U}^{\otimes a}{}_{9}^{ \circ  }{\operatorname{spider}}_{\phi ,a,b}\left( n\right) {}_{9}^{ \circ  }{\left( {U}^{ \dagger  }\right) }^{\otimes b}\) . In fact,every unitary arises in this way, see Heunen and Vicary [HV19, Corollary 5.32]. Thus, the axioms for spiders allow us to define any orthonormal basis without ever mentioning basis vectors: they are merely the states \(v : 1 \rightarrow  n\) for which the comonoid is natural,i.e. \({v}_{9}^{ \circ  }\operatorname{split}\left( x\right)  = v \otimes  v\) and \({v}_{9}^{ \circ  }\operatorname{counit}\left( x\right)  = \operatorname{id}\left( 1\right)\) .</p>
<p>Example 1.4.32. The category Circ is \(\dagger\) -hypergraph with the spiders defined in example 1.4.29,the evaluation functor \(\mathbf{{Circ}} \rightarrow  {\mathbf{{Tensor}}}_{\mathbb{C}}\) is a \(\dagger\) -hypergraph functor.</p>
<p>DisCoPy implements spiders for types of length one (i.e. generating objects) as a subclass of Box and spiders for arbitrary types as a method Diagram. spiders.</p>
<!-- Media -->
<p>Listing 1.4.33. Implementation of \(\dagger\) -hypergraph categories and functors.</p>
<hr>
<p>class Spider (Box):
def <em><strong><strong>init</strong></strong></em>(self, a: int, b: int, x: Ty, phase=None):
assert len ( x ) == 1
self.object, self.phase = x, phase or 0
name = "Spider({})".format(', '.join(map(str, (a, b, x, phase)))
super(   ).<em>init</em>(name, dom=x ** a, cod=x ** b)
def dagger(self):
a, b, x = len ( self.cod ), len ( self.dom ), self.object
phase = None if self.phase is None else -self.phase
return Spider (a, b, x, phase)</p>
<hr><!-- Meanless: 122 1.4. Adding extra structure-->
<hr>
<p>def coherence(factory):
def method(cls, a: int, b: int, x: Ty, phase=None) -> Diagram:
if len ( x ) == 0 and phase is None: return cls.id( x )
if \(\operatorname{len}\left( \mathrm{x}\right)  =  = 1\) : return factory(a,b,x, phase)
if phase is not None: # Coherence for phase shifters.
shift = cls.tensor(<em>[factory(1, 1, obj, phase) for obj in x])
return method (cls,a,1,x) >> shift >> method (cls,1,b,x)
if(a,b)in \(\left\lbrack  {\left( {1,0}\right) ,\left( {0,1}\right) }\right\rbrack   : \#\) Coherence for (co)units.
return cls.tensor(</em>[factory(a, b, obj) for obj in x])
#Coherence for binary (co)products.
if(a,b)in \(\left\lbrack  {\left( {1,2}\right) ,\left( {2,1}\right) }\right\rbrack\) :
spiders, braids = (   )
factory(a, b, x[0], phase) @ method(cls, a, b, x[1:], phase),
\(\mathrm{x}\left\lbrack  0\right\rbrack  @\) cls.braid( \(\mathrm{x}\left\lbrack  0\right\rbrack  ,\mathrm{x}\left\lbrack  {1 : }\right\rbrack\) ) \(@\mathrm{x}\left\lbrack  {1 : }\right\rbrack\) )
return spiders >> braids if \(\left( {a,b}\right)  =  = \left( {1,2}\right)\) else braids >> spiders
if \(\mathrm{a} =  = 1 : \;\#\) We can now assume \(\mathrm{b} > 2\) .
return method(cls,1,b - 1,x)\
>> method(cls, 1, 2, x) @ (x ** (b - 2))
if \(\mathrm{b} =  = 1 :\) # We can now assume a \(> 2\) .
return method(cls, 2, 1, x) @ (x ** (a - 2))\
>> method (cls, a - 1, 1, x)
return method ( cls , a , 1 , x ) >> method ( cls , 1 , b , x )
return classmethod(method)
Diagram.spiders = coherence (Spider)
Diagram.cups = nesting(lambda x,<em>: Spider(0, 2, x))
Diagram.caps = nesting(lambda x,</em>: Spider(2,0,x))
class Functor (symmetric.Functor) :
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Spider):
a, b = len (other.dom), len (other.cod)
x, phase = other.object, other.phase
return self.cod.ar.spiders (a, b, self(x), phase)
return super(   ). _call _(other)</p>
<hr>
<!-- Media -->
<p>Example 1.4.34. We can now extend example 1.2.37 to arbitrary formulae of first-order logic. Every variable that appears exactly twice is encoded as a wire (possibly with cups and caps),every variable that appears \(n \neq  2\) is encoded as an \(n\) -legged spider. For example,the formula \(\forall c\forall {oO}\left( {c,o}\right)  \land  R\left( c\right)  \land  C\left( c\right)  \Rightarrow  U\left( {c,o}\right)\) (interpreted as "every object of a rigid cartesian category is also its unit") can be encoded as a diagram with a wire for o and a four-legged spider for c.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 123-->
<hr>
<p>class Formula(Diagram):
cut = lambda self: Cut (self)
class Cut (Bubble, Formula) :
method = "_not"
cast = Formula.cast
class Predicate (Box, Formula) :
cast = Formula.cast
def model(size: dict[Ty, int], data: dict[Predicate, list[bool]]):
return Functor(ob=size, ar={p: [data[p]] for p in data},
dom \(=\) Category (Ty, Formula) ,
cod=Category ( list [ int ] , Tensor [ bool ] ) )
objects, categories = Ty('o'), Ty('c')
has_object, has_unit = [Predicate(p, Ty(   ), categories @ objects) for p in "OU"]
is_rigid, is_cartesian = [Predicate(p, Ty(   ), categories) for p in "RC"]
rigid_cartesian_implies_trivial = (   )
has_object >> Formula.spiders(1,3, categories) @ objects
>> (is_rigid @ is_cartesian @ has_unit.cut(   )).dagger(   )).cut(   )
size = {objects: 2, categories: 2}
predicate_values = itertools.product(*size[categories] * [[0, 1]])
relation_values = itertools.product(*size[categories] * size[objects] * [[0, 1]])
for O, U, R, C in itertools.product(   )
\(* \left( {2 * \text{ [predicate_values] } + 2 * \text{ [relation_values])) }}\right)\) :
F = model(size, {has_object: 0, has_unit: U, is_rigid: R, is_cartesian: C})
is_rigid_cartesian_and_has_object = lambda i, j:\
F(has_object)[i, j] and F(is_rigid)[i] and F(is_cartesian)[i]
assert F(rigid_cartesian_implies_trivial) == all(   )
not is_rigid_cartesian_and_has_object(i, j) or F(has_unit)[i, j]
for i in range (size[categories]) for j in range (size [objects]))
rigid_cartesian_implies_trivial.draw(   )</p>
<hr><!-- Meanless: 124 1.4. Adding extra structure-->
<!-- Media -->
<!-- figureText: R 0 \( U \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_123.jpg?x=527&#x26;y=292&#x26;w=494&#x26;h=339&#x26;r=0">
<!-- Media -->
<p>The equality of hypergraph diagrams reduces to hypergraph isomorphism, it will be discussed in section 1.5.2. The equality of non-commutative spiders is not implemented yet, spider fusion would be a natural extension of the snake removal algorithm for rigid diagrams: we find pairs fusable spiders then apply interchangers to make them adjacent. The possible obstructions are more serious for spiders than for cups and caps however,for example consider the diagram spider \({}_{0,3}\left( x\right)\) , \(x \otimes\) \(f \otimes  g\) ,spider \({}_{3,0}\left( x\right)\) . The two three-legged spiders want to fuse but the boxes \(f\) and \(g\) stand on the way,the best we can do is to bend their output wires with two cups and get a four-legged spider \({\operatorname{spider}}_{0,4}\left( x\right)\) , \(x \otimes  f \otimes  g \otimes  x\) , \(\operatorname{cup}\left( x\right)  \otimes  \operatorname{cup}\left( x\right)\) .</p>
<!-- Media -->
<!-- figureText: \( g \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_123.jpg?x=456&#x26;y=1113&#x26;w=594&#x26;h=230&#x26;r=0">
<!-- Media -->
<h4>1.4.4 Products &#x26; coproducts</h4>
<p>With hypergraph diagrams, we have enough syntax to discuss quantum protocols and first-order logic. However, the spiders of hypergraph categories are of no use if we want to interpret our diagrams as (pure) Python functions with tuple as tensor. Indeed,Pyth has the property that every function \(f : x \rightarrow  y \otimes  z\) into a composite system \(y \otimes  z\) is in fact a tensor product \(f = {f}_{0} \otimes  {f}_{1}\) of two separate functions \({f}_{0} : x \rightarrow  y\) and \({f}_{1} : x \rightarrow  z\) . If a Python type \(x\) had caps (let alone spiders) then we could break them in two with the consequence that the identity function on \(x\) is constant,i.e. \(x\) is trivial [CK17,Proposition 4.76]. Moreover,there is only one (pure) effect of every type,discarding it. Thus if a Python type \(x\) had cups then we could break them apart as well with the same consequence: only the trivial Python type can have spiders. A similar argument destroys our hopes for time reversal in Python: if we had a monoidal dagger on Pyth, every state would be equal to every other.</p>
<p>Now if we go back to the intuition of diagrams as pipelines and their wires as carrying data, not all might be lost about spiders. Indeed, it makes sense to split a data-carrying wire: it means we are copying information. Closing a data-carrying wire is the counit of the copying comonoid, it means we are deleting information. In this context, the special condition would translate as follows: if we copy some data then merge the two copies back together, then we haven't done anything. In order for the spider fusion equations to hold, we would need the monoid to take any two inputs and assert that they are equal or abort the computation otherwise, i.e. we would need side effects. Even more weirdly, we would need the unit of the monoid to be equal to anything else.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 125-->
<p>Rather than complaining that classical computing is weird because we cannot coherently merge data back together, we should embrace this as a feature, not a bug: in Python we can copy and discard data (at least assuming that we have enough RAM and that the garbage collector is doing its job). This means we can still keep the comonoid half of our spiders, forget that they are spiders and come to realise that they are in fact natural comonoids, i.e. every function is a comonoid homomorphism. Indeed,the functions copy = lambda *xs: xs + xs and delete \(= 1\) ambda *xs: (   ) define a pair of natural transformations \(x \rightarrow  x \otimes  x\) and \(x \rightarrow  1\) in Pyth:</p>
<hr>
<pre><code>- copy(f(xs)) == f(copy(xs)[:n]), f(copy(xs)[n:])
</code></pre>
<ul>
<li>delete(f(xs)) == delete(xs)</li>
</ul>
<hr>
<p>for all pure functions \(f\) and inputs \(\mathrm{{xs}}\) with \(\mathrm{n} = 1\mathrm{{en}}\left( \mathrm{{xs}}\right)\) . Once drawn as a diagram, the naturality equations for comonoids allows us to either copy or delete boxes by passing them through either the coproduct or the counit.</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_124.jpg?x=367&#x26;y=1487&#x26;w=377&#x26;h=199&#x26;r=0">
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_124.jpg?x=1113&#x26;y=1487&#x26;w=225&#x26;h=146&#x26;r=0">
<!-- Media -->
<p>A cartesian category is a symmetric category with coherent, natural commutative comonoids. The category Pyth is an example of cartesian category, as well as the categories Set,Mon,Cat,MonCat,etc. The category \({\mathbf{{Mat}}}_{\mathbb{S}}\) is also a cartesian category with the direct sum as tensor. Our definition of cartesian is convenient if we want to draw string diagrams and interpret them as functions but it is rather cumbersome: checking that a given category fits the definition involves a lot of structure (tensor, swaps and comonoids) and many axioms relating them. In practice,we usually take an equivalent definition: a category \(C\) is cartesian if it has categorical products and a terminal object. An object \(1 \in  {C}_{0}\) is terminal if there is a unique arrow \(\operatorname{counit}\left( x\right)  : x \rightarrow  1\) from each object \({C}_{0}\) . An object \({x}_{0} \times  {x}_{1} \in  {C}_{0}\) is the product of two objects \({x}_{0},{x}_{1} \in  {C}_{0}\) if it comes equipped with a pair of arrows \({\pi }_{0} : {x}_{0} \times  {x}_{1} \rightarrow  {x}_{0}\) and \({\pi }_{1} : {x}_{0} \times  {x}_{1} \rightarrow  {x}_{1}\) such that for all pairs of arrows \({f}_{0} : y \rightarrow  {x}_{0}\) and \({f}_{1} : y \rightarrow  {x}_{1}\) there is a unique \(f = \left\langle  {{f}_{0},{f}_{1}}\right\rangle   : y \rightarrow  {x}_{0} \times  {x}_{1}\) such that \(f\mathring{} {\pi }_{0} = {f}_{0}\) and \(f\mathring{} {\pi }_{1} = {f}_{1}\) . These definitions are usually drawn as commutative diagrams where the full lines are universally quantified and the dotted line is uniquely existentially quantified.</p><!-- Meanless: 126 1.4. Adding extra structure-->
<p>From these two universal properties we can deduce that terminal objects and categorical products are unique up to a unique isomorphism. Given two arrows \(f : a \rightarrow  b\) and \(g : c \rightarrow  d\) we have two arrows \({\pi }_{0} \circ  f : a \times  c \rightarrow  b\) and \({\pi }_{1} \circ  g : a \times  c \rightarrow  d\) , thus there is a unique \(f \times  g = \left\langle  {{\pi }_{0}\mathring{} f,{\pi }_{1}\mathring{} g}\right\rangle   : a \times  b \rightarrow  c \times  d\) . One can show that this makes the category \(C\) a (non-strict) monoidal category. Furthermore,we can show \(C\) is symmetric with the swaps given by \(S\left( {x,y}\right)  = \left\langle  {{\pi }_{1},{\pi }_{0}}\right\rangle   : x \times  y \rightarrow  y \times  x\) . Finally,we can show \(C\) has coherent natural commutative comonoids given by \(\operatorname{split}\left( x\right)  = \langle \operatorname{id}\left( x\right) ,\operatorname{id}\left( x\right) \rangle  : x \rightarrow  x \times  x\) and \(\operatorname{counit}\left( x\right)  : x \rightarrow  1.\)</p>
<p>In the other direction,if \(C\) has coherent natural commutative comonoids we can deduce that 1 is a terminal object from the naturality of the counit. For any arrows \({f}_{0} : y \rightarrow  {x}_{0}\) and \({f}_{1} : y \rightarrow  {x}_{1}\) we can define</p>
<p></p>\[\text{-}\left\langle  {{f}_{0},{f}_{1}}\right\rangle   = \operatorname{split}\left( y\right) 。{f}_{0} \otimes  {f}_{1}\text{,}\]<p></p>
<p></p>\[\text{-}{\pi }_{0} = \operatorname{id}\left( {x}_{0}\right)  \otimes  \operatorname{counit}\left( {x}_{1}\right) \text{and}{\pi }_{1} = \operatorname{counit}\left( {x}_{0}\right)  \otimes  \operatorname{id}\left( {x}_{1}\right) \text{,}\]<p></p>
<p>and show that \(\otimes   =  \times\) is in fact a categorical product,see Selinger’s survey [Sel10, Section 6.1]. A functor is cartesian when it preserves the categorical product, or equivalently if it is a symmetric functor that preserves the comonoid. This defines a category CCat of cartesian categories and functors. We can assume that cartesian categories are free-on-objects, i.e. the monoid axioms for objects are equalities rather than natural transformations. Thus, we get a forgetful functor \(U : \mathbf{{CCat}} \rightarrow\) MonSig with its left adjoint given by a quotient of the free symmetric category \({F}^{C}\left( \sum \right)  = {F}^{S}\left( {\sum  \cup  \text{split} \cup  \text{counit}}\right) /R\) with the relations \(R\) given by the naturality equations for each box.</p>
<p>Taking the opposite definition, a cocartesian category is one with a categorical coproduct, or equivalently with a coherent natural commutative monoid. For example, the category Set is cocartesian with the disjoint union as tensor. The category Pyth is cocartesian with tagged union: the merging function takes a tagged element of an \(\mathrm{n}\) -fold union and forgets the tag. While cartesian structures can be thought of in terms of data copying, cocartesian structures formalise conditional branching. Indeed, when we interpret cocartesian diagrams in Pyth parallel wires encode the different branches of a program, merging two wires of the same type means forgetting the difference between two branches.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 127-->
<p>DisCoPy implements free (co)cartesian categories with subclasses of Box for making and merging \(\mathrm{n}\) copies of a type \(\mathrm{x}\) of length one. The class methods copy and merge extend this to types of arbitrary length by calling the coherence subroutine of the previous section. Cartesian functors take Copy (Merge) boxes of its domain to the copy (merge) method of its codomain.</p>
<!-- Media -->
<hr>
<p>Listing 1.4.35. Implementation of free (co)cartesian categories and functors.
class Diagram (symmetric. Diagram) :
@classmethod
def copy(cls, x: Ty, n=2) -> Diagram:
def factory(a, b, x, _):
assert a == 1
return Copy (x, b)
return coherence(factory). _func (cls, 1, n, x)
@classmethod
def merge(cls, \(\mathrm{x} : \mathrm{{Ty}},\mathrm{n} = 2\) ) \(\rightarrow\) Diagram:
return cls.copy(x, n).dagger(   )
class Box (symmetric. Box, Diagram) :
cast = Diagram.cast
class Swap (symmetric. Swap, Box): pass
Diagram.swap = Diagram.braid = hexagon(Swap)
class Copy (Box) :
def <em>init</em>(self, x: Ty, n: int = 2) :
super(   ).<em>init</em>(name="Copy({}, {})".format(x, n), dom=x, cod=x ** n)
dagger = lambda self: Merge(self.dom, len(self.cod))
class Merge (Box):
def <strong>init</strong>(self, x: Ty, n: int = 2) :
super(   ).<em>init</em>(name="Merge({}, {})".format(x, n), dom=x ** n, cod=x)
dagger = lambda self: Copy(self.cod, len(self.dom))
class Functor (symmetric.Functor) :
dom = cod = Category(Ty, Diagram)</p>
<hr>
<!-- Media --><!-- Meanless: 128 1.4. Adding extra structure-->
<hr>
<p>def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Copy):
return self.cod.ar.copy(self(other.dom), len(other.cod))
if isinstance(other, Merge):
return self.cod.ar.merge(self(other.cod), len(other.dom))
return super(   ). _call (other)</p>
<hr>
<p>Listing 1.4.36. Implementation of Pyth as a cartesian category.</p>
<hr>
<p>class Function:
...
@staticmethod
def copy(x: tuple[type, ...], n: int):
return Function (lambda *xs: n * xs, dom=x, cod=n * x)</p>
<hr>
<p>Example 1.4.37. We can implement the architecture of a neural network as a cartesian diagram and its evaluation as a functor to Function.</p>
<!-- Media -->
<hr>
<p>\(\mathrm{x} = \mathrm{{Ty}}\left( {1{\mathrm{x}}^{\prime }}\right)\)
add = lambda n : Box ( ' $+$ ', x ** n, x )
ReLU = Box ('$\\sigma$', x, x)
weights = [Box('w{}'.format(i),x,x) for i in range(4)]
bias = Box \(\left( {{}^{\prime }{b}^{\prime },{Ty}\left( \right) ,x}\right)\)
network = Diagram.copy(x 0 x, 2)'</p>
<blockquote>
<blockquote>
<p>Diagram.tensor(*weights) @ bias >> add(5) >> ReLU
F = Functor(ob={x: int}, ar={
add(5): lambda *xs: sum(xs),
ReLU: lambda x: max(0,x),
bias: lambda: -1, **{
weight: lambda x, w=w: x * w
for weight, w in zip(weights, range(4)))},
cod=Category (tuple [type, ...], Function))
assert F(network) \(\left( {{42},{43}}\right)  = \max \left( {0,\operatorname{sum}\left( \left\lbrack  {{42} * 0,{43} * 1,{42} * 2,{43} * 3, - 1}\right\rbrack  \right) }\right)\)</p>
</blockquote>
</blockquote>
<hr>
<!-- Media -->
<p>Example 1.4.38. In a cartesian category, every monoid is automatically a bialge-bra, i.e. the monoid is a comonoid homomorphism or equivalently, the comonoid is a homomorphism for the monoid. When furthermore the monoid has an inverse, then it is automatically a Hopf algebra, the generalisation of groups to arbitrary monoidal categories.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 129-->
<hr>
<p>\(\mathrm{x} = \mathrm{{Ty}}\left( {1{\mathrm{x}}^{\prime }}\right)\)
copy, discard = Copy(x), Copy(x, n=0)
add, minus, zero = Box('+', x @ x, x), Box('-', x, x), Box('0', Ty(   ), x)</p>
<hr>
<p>drawing.equation(add >> copy, copy @ copy >> x @ Swap(x, x) @ x >> add @ add) drawing.equation (zero >> copy, zero @ zero)</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_128.jpg?x=280&#x26;y=638&#x26;w=423&#x26;h=320&#x26;r=0">
<!-- figureText: 0 -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_128.jpg?x=1138&#x26;y=740&#x26;w=309&#x26;h=132&#x26;r=0">
<!-- Media -->
<p>drawing.equation(add >> discard, discard @ discard)</p>
<p>drawing.equation(zero >> discard, Diagram.id(Ty(   )))</p>
<hr>
<!-- Media -->
<pre><code>&#x3C;img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_128.jpg?x=279&#x26;y=1133&#x26;w=299&#x26;h=120&#x26;r=0"/>
</code></pre>
<!-- Media -->
<hr>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_128.jpg?x=1272&#x26;y=1149&#x26;w=123&#x26;h=104&#x26;r=0">
<!-- Media -->
<p>drawing.equation (copy >> minus @ x >> add, discard >> zero, copy >> x @ minus >> add)</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_128.jpg?x=638&#x26;y=1453&#x26;w=441&#x26;h=202&#x26;r=0">
<!-- Media -->
<p>A bialgebra which is also a Frobenius algebra is necessarily trivial, i.e. isomorphic to the unit.</p>
<hr>
<p>drawing.equation (   )
Diagram.id(x),
x @ zero >> x @ copy >> add @ x >> discard @ x,
x @ zero @ zero >> discard @ discard @ x,
discard >> zero)</p>
<hr><!-- Meanless: 130 1.4. Adding extra structure-->
<!-- Media -->
<!-- figureText: - -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_129.jpg?x=438&#x26;y=298&#x26;w=679&#x26;h=259&#x26;r=0">
<!-- Media -->
<p>A cartesian category that is also a PROP is called a Lawvere theory [Law63], they were first introduced as a high-level language for universal algebra. take the boxes \({x}^{n} \rightarrow  x\) to be the primitive \(n\) -ary operations of your language (e.g. for rigs we have unary boxes for 0 and 1,binary boxes for + and ×) then the diagrams in the free Lawvere theory are all the terms of your language. We can write down any universally quantified axiom as a relation between diagrams and the cartesian functors from the resulting quotient to Set are algebras, i.e. sets equipped with operations that satisfy the axioms. The natural transformations between models are precisely the homomorphisms between the algebras, i.e. the functions that commute with the operations. If we add colours back in and allow many generating objects, we can define many-sorted theories such as that of modules, with a ring acting on a group. If we take every pair of objects \(\left( {x,y}\right)  \in  {C}_{0} \times  {C}_{0}\) as colour and a box \(\left( {x,y}\right)  \otimes  \left( {y,z}\right)  \rightarrow  \left( {x,z}\right)\) for every possible composition,then we can even define the Lawvere theory of categories with \({C}_{0}\) as objects. Thus,categories (with some fixed objects) can also be seen as the functors from this Lawvere theory to Set, functors can also be seen as the natural transformations between such functors.</p>
<p>The free Lawvere theory with no boxes (only swaps, coproducts and counits) is equivalent to \({\mathbf{{FinSet}}}^{op}\) ,the opposite category to finite sets and functions,with the disjoint union as tensor. Indeed,a cartesian diagram \(f : {x}^{n} \rightarrow  {x}^{m}\) can be seen as the graph of a function from the \(m\) to \(n\) elements. This free Lawvere theory is also called the theory of equality, a functor from it to Set (i.e. an algebra for the theory) is just a set with its equality relation, a natural transformation between those functors is just a function. Thus, equality of cartesian diagrams with no boxes reduces to equality of functions between finite sets, which can be implemented as equality of finite dictionaries in Python. It is easy to show that the rules for naturality are confluent and terminating when applied from left to right, i.e. we copy (delete) every box by passing it down through all possible coproducts (counits). At each rewrite step there is one fewer box node above a comonoid node, thus we can reduce the word problem for free cartesian categories to that of free symmetric categories and then to graph isomorphism.</p>
<p>Listing 1.4.39. Implementation of the free cartesian category \({\mathbf{{FinSet}}}^{op}\) with int</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 131-->
<!-- Media -->
<hr>
<p>as objects and Dict as arrows.
@dataclass
class Dict (Composable, Tensorable):
inside: dict[int, int]
dom: int
cod: int
<strong>getitem</strong> = lambda self, key: self.inside[key]
@staticmethod
def id(x: int = 0): return Dict ({i: i for i in range(x)), x, x)
@inductive
def then(self,other: Dict) -> Dict:
inside = {i: self[other[i]] for i in range(other.cod)}
return Dict (inside, self.dom, other.cod)
@inductive
def tensor(self,other: Dict) -> Dict:
inside = {i: self[i] for i in range(self.cod)}
inside.update({
self.cod + i: self.dom + other[i] for i in range(other.cod)})
return Dict (inside, self.dom + other.dom, self.cod + other.cod)
@staticmethod
def swap(x: int, y: int) -> Dict:
inside = \(\{ i : i + x\) if \(i &#x3C; x\) else \(i - x\) for \(i\) in range \(\left( {x + y}\right) \}\)
return Dict (inside, \(x + y,x + y\) )
@staticmethod
def copy ( \(\mathrm{x}\) : int, \(\mathrm{n}\) : int) -> Dict:
return Dict ({i: i % x for i in range(n * x)}, x, n * x)</p>
<hr>
<!-- Media -->
<p>Example 1.4.40. We can check equality of cartesian diagrams with one generating object and no boxes.</p>
<hr>
<pre><code>\( \mathrm{x} = \mathrm{{Ty}}\left( {{}^{\prime }{\mathrm{x}}^{\prime }}\right) \)
copy, discard, swap = \( \operatorname{Copy}\left( {x,2}\right) ,\operatorname{Copy}\left( {x,0}\right) ,\operatorname{Swap}\left( {x,x}\right) \)
F = Functor(\{x: 1\}, \{\}, cod=Category(int, Dict))
assert \( \mathrm{F}\left( {\text{copy } >  > \text{ discard }@\mathrm{x}}\right)  =  = \mathrm{F}\left( {\text{ Diagram. id }\left( \mathrm{x}\right) }\right)  =  = \mathrm{F}\left( {\text{ copy } >  > \mathrm{x}@\text{ discard }}\right) \)
</code></pre>
<p>assert \(\mathrm{F}\left( {\operatorname{copy} >  > \operatorname{copy}@\mathrm{x}}\right)  =  = \mathrm{F}\left( {\operatorname{Copy}\left( {\mathrm{x},3}\right) }\right)  =  = \mathrm{F}\left( {\operatorname{copy} >  > \mathrm{x}@\operatorname{copy}}\right)\)
assert \(\mathrm{F}\left( {\text{copy } >  > \text{ swap }}\right)  =  = \mathrm{F}\left( \text{ copy }\right)\)</p>
<hr><!-- Meanless: 132 1.4. Adding extra structure-->
<p>A rig category has two monoidal structures \(\oplus\) and \(\otimes\) that satisfy the equations of a rig up to natural isomorphism. This is the case for the category Set as well as for Pyth. The Kronecker product is not a cartesian product for \({\mathbf{{Mat}}}_{\mathbb{S}}\) (since this role is taken by direct sums) but it does form a rig category with the direct sum. The arrows of free rig categories can be described as (equivalence classes of) three-dimensional sheet diagrams where composition, additive and multiplicative tensor are encoded in three orthogonal axes [CDH20]. These 3d diagrams are a complete language for dataflow programming [Del20a], they are not implemented in DisCoPy yet.</p>
<h4>1.4.5 Biproducts</h4>
<p>A category has biproducts if the cartesian and cocartesian structures coincide, a \(\dagger\) -category has \(\dagger\) -biproducts when furthermore the monoid is the dagger of the comonoid. This is the case in the \(\dagger\) -category \({\mathbf{{Mat}}}_{\mathbb{S}}\) with direct sum \(\oplus\) as tensor.</p>
<!-- Media -->
<p>Listing 1.4.41. Implementation of \(\dagger\) -biproducts for \({\mathbf{{Mat}}}_{\mathbb{S}}\) .</p>
<hr>
<p>class Matrix:
...
@classmethod
def copy(cls, \(\mathrm{x} :\) int, \(\mathrm{n} :\) int) \(\rightarrow\) Matrix:
inside = [
i + int(j % n * x) == j for j in range(n * x)] for i in range(x)]
return cls(inside, x, n * x)
@classmethod
def merge(cls, \(\mathrm{x}\) : int, \(\mathrm{n}\) : int) -> Matrix:
return cls.copy(x, n).dagger(   )
@classmethod
def basis(cls, x: int, i: int) -> Matrix:
return cls ([[i == j for j in range(x)]], x ** 0, x)</p>
<hr>
<!-- Media -->
<p>Biproducts and matrices happen to be intimately related. Indeed, given any commutative-monoid-enriched category \(C\) we can construct its free biproduct completion \({\mathbf{{Mat}}}_{C}\) as the monoidal category with objects given by \({C}_{0}^{ \star  }\) and arrows \(f : x \rightarrow  y\) given by matrices \({f}_{ij} : {x}_{i} \rightarrow  {y}_{j}\) of arrows in \({C}_{1}\) . Composition in \({\mathbf{{Mat}}}_{C}\) is an extension of the usual matrix multiplication with composition as product. In particular,if \(C = \mathbb{S}\) is a rig,i.e. a one-object CM-enriched category,then this definition coincides with the usual one. Any category with biproducts is automatically enriched in commutative monoids with \(f + g : x \rightarrow  y\) given by split \(\left( x\right) \mathring{} f \oplus  g\mathring{}\) merge(x)and the zero morphism \(0 = \operatorname{counit}\left( x\right) \mathring{}\) unit(y). One can verify that the free completion is indeed the left adjoint to the forgetful functor from biproducts to CM-enrichment, see [Mac71, Exercise VIII.2.6]. Similarly, if \(C\) is a \(\dagger\) -category then \({\mathbf{{Mat}}}_{C}\) is its free \(\dagger\) -biproduct completion with the element-wise dagger of the transpose. If \(C\) is also a monoidal category,then \({\mathbf{{Mat}}}_{C}\) is a rig category with the tensor given by an extension of the usual Kronecker product with tensor as product.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 133-->
<p>We implement free \(\dagger\) -biproduct completion as a subclass of Matrix [Sum] with tuple \(\left\lbrack  {\mathrm{{Ty}},\ldots }\right\rbrack\) as objects and addition given by the formal sum of diagrams. We use Python's duck typing to lift the code for composition, tensor and direct sum from int to tuple [Ty, ...]. We also use a contextmanager to temporarily replace the multiplication of two Sum entries by composition or tensor. Again, we override equality so that diagrams are equal to the matrix of just themselves.</p>
<!-- Media -->
<p>Listing 1.4.42. Implementation of free \(\dagger\) -biproduct completion.</p>
<p>@dataclass</p>
<hr>
<p>class FakeInt:
inside: tuple \(\left\lbrack  {\mathrm{{Ty}},\ldots }\right\rbrack   = \left( {\mathrm{{Ty}}\left( \right) ,}\right)\)
__index _ = lambda self: len(self.inside)
___<strong>iter</strong> = property(lambda self: self.inside.<em>iter</em>)
<em><strong><strong>add</strong></strong></em> = lambda self, other: FakeInt(self.inside + other.inside)
<em><strong><strong>mul</strong></strong></em> = lambda self, other: FakeInt(   )
tuple ( \(\mathrm{x}0@\mathrm{x}1\) for \(\mathrm{x}0\) in self.inside for \(\mathrm{x}1\) in other))
<em><strong><strong>rmul</strong></strong></em> = lambda self, n: FakeInt(n * self.inside)
<em><strong><strong>pow</strong></strong></em> = lambda self, n: product(n * (self, ), unit=FakeInt(   ))
class Diagram (monoidal.Diagram) :
def <em><strong><strong>eq</strong></strong></em> (self, other):
if isinstance(other, Biproduct):
return other.inside == [[self]]
return monoidal.Diagram. <em><strong><strong>eq</strong></strong></em> (self, other)
def direct_sum(self, *others):
return Biproduct.cast(self).direct_sum(*others)
___<strong>or</strong> = direct_sum
class Box (monoidal. Box, Diagram) :
cast = Diagram.cast
class Sum (monoidal. Sum, Box):</p>
<hr><!-- Meanless: 134 1.4. Adding extra structure-->
<hr>
<pre><code>id = lambda x: Sum.cast(Diagram.id(x))
</code></pre>
<p>Diagram.sum = Sum
class Biproduct(Matrix):
dtype = Sum
def <em><strong><strong>init</strong></strong></em>(self, inside: list[list[Sum]], dom: FakeInt, cod: FakeInt):
self.dom, self.cod, self.inside = dom, cod, [[
self.dtype.id(x) if val == 1
else self.dtype.zero (x,y) if val == 0
else self.dtype.cast(val)
for y, val in zip(cod, row)] for x, row in zip(dom, inside)]
@contextmanager
def fake_multiplication ( self, method ) :
self.dtype.<em><strong><strong>mul</strong></strong></em> = getattr(self.dtype, method)
yield
delattr(self.dtype, "<em><strong><strong>mul</strong></strong></em>")
@classmethod
def cast(cls, old: Diagram):
if isinstance(old, cls): return old
return cls([[old]], FakeInt((old.dom, )), FakeInt((old.cod, )))
@inductive
def then(self, other: Biproduct | Diagram) -> Biproduct:
with self.fake_multiplication ("then") :
return Matrix.then(self, self.cast(other))
@inductive
def tensor(self, other: Biproduct | Diagram) -> Biproduct:
with self.fake_multiplication ("tensor") :
return Matrix.Kronecker ( self, self.cast (other))
@inductive
def direct_sum(self, other: Biproduct | Diagram) -> Biproduct:
with self.fake_multiplication ("then") :
return Matrix.direct_sum(self, self.cast(other))
dagger = lambda self: self.transpose(   ).map(lambda f: f.dagger(   ))
<em><strong><strong>eq</strong></strong></em> = lambda self, other: Matrix.<em><strong><strong>eq</strong></strong></em>(self, self.cast(other))</p>
<hr>
<!-- Media -->
<p>Example 1.4.43. We can define the object bit as the list of two empty types, with</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 135-->
<!-- Media -->
<p>true and false the two basis states then we can implement conditional expressions as biproducts.</p>
<hr>
<p>unit = FakeInt(   )
true = Biproduct.copy(unit, 2)\ )
>> (Biproduct.id(unit) | Biproduct.zero(unit, unit))
false = Biproduct.copy(unit, 2)\ )
>> (Biproduct.zero(unit, unit) | Biproduct.id(unit))
\(x,y = {Ty}\left( {{}^{\prime }{x}^{\prime }}\right) ,{Ty}\left( {{}^{\prime }{y}^{\prime }}\right)\)
\(\mathrm{f},\mathrm{g} = \operatorname{Box}\left( {{}^{\prime }{\mathrm{f}}^{\prime },\mathrm{x},\mathrm{y}}\right) ,\operatorname{Box}\left( {{}^{\prime }{\mathrm{g}}^{\prime },\mathrm{x},\mathrm{y}}\right)\)
conditional = (f | g) >> Biproduct.merge(FakeInt((y, )), 2)
assert true @ FakeInt((x, )) >> conditional == f\
and false @ FakeInt \(\left( \left( {x,\;}\right) \right)  >  >\) conditional \(=  = g\)</p>
<hr>
<!-- Media -->
<p>Example 1.4.44. We can implement quantum measurements as biproducts of two quantum effects and classical control as a biproduct of two quantum states. When we compose classical control with measurement, we get a matrix where the entries are scalar diagrams. The squared amplitude of the evaluation of these scalars give us the measurement probabilities for each classical choice of state. We leave the implementation of such biproduct-valued functors to future work: it would require to augment the syntax of types from monoids to semirings.</p>
<p>As we mentioned at the end of section 1.2, DisCoPy uses a point-free syntax and it can be rather tedious to define any complex diagram in this way. It is straightforward to extend the diagramize method to cartesian diagrams, so that they can be defined using the standard syntax for Python functions, where we can use arguments any number of times in any order. Extending it to cocartesian diagrams so that they can be defined using the standard Python syntax for conditionals will likely be more challenging. Given enough engineering, it would be possible to turn any pure Python function into a diagram, however this will require more structure than just (co)cartesian categories. Functions with side effects can be seen as arrows in premonoidal categories which are the topic of section 1.5, while recursive functions are arrows in traced categories, both will be discussed in section 1.5. Higher-order functions are modeled as arrows in closed categories, the topic of the next section.</p>
<h4>1.4.6 Closed categories</h4>
<p>As we have seen in sections 1.4.3 and 1.4.4, cartesian categories like Pyth and hypergraph categories like Tensor are two orthogonal extensions of monoidal categories. The former have natural comonoids on each object, the latter have spiders on each object, an object that has both is necessarily trivial. Nevertheless, the category Pyth does share a common structure with rigid categories beyond being monoidal: both are closed monoidal categories. A monoidal category \(C\) is left-closed if for every object \(x \in  {C}_{0}\) ,the functor \(x \otimes   -  : C \rightarrow  C\) has a right adjoint \(x \smallsetminus   -  : C \rightarrow  C\) called \(x\) under - . Symmetrically, \(C\) is right-closed if the functor \(-  \otimes  x : C \rightarrow  C\) has a right adjoint \(- /x : C \rightarrow  C\) called - over \(x{.}^{1}\) A closed (monoidal) category is one that is closed on the left and the right. For example, a rigid category is a closed category where the over and under types have the form \(x \smallsetminus  y = {x}^{r} \otimes  y\) and \(y/x = y \otimes  {x}^{l}\) . When the category is symmetric,over and under types coincide,they are called exponentials \(x \smallsetminus  y = y/x = {y}^{x}\) .</p><!-- Meanless: 136 1.4. Adding extra structure-->
<p>Example 1.4.45. A discrete monoidal category (i.e. a monoid) is closed if and only if it is a group. A closed preordered monoid (i.e. a closed category with at most one arrow between any two objects) is also called a residuated monoid [Coe13], their application to NLP will be discussed in section 2.1. The powerset of any monoid \(M\) can be given the structure of a residuated monoid where:</p>
<p></p>\[\text{-}X \otimes  Y = \{ {xy} \in  M \mid  x \in  X \land  y \in  Y\} \text{,}\]<p></p>
<p></p>\[\text{-}\left( {X/Y}\right)  = \{ z \in  M \mid  \forall y \in  Y \cdot  {zy} \in  X\} \text{,}\]<p></p>
<p></p>\[\text{-}\left( {X \smallsetminus  Y}\right)  = \{ z \in  M \mid  \forall x \in  X \cdot  {xz} \in  Y\} \text{.}\]<p></p>
<p>for all subsets \(X,Y \subseteq  M\) .</p>
<p>As the name suggests, a cartesian closed category is a cartesian category that is also closed. Examples of cartesian closed categories include Set with the exponential \({Y}^{X}\) given by the set of functions from \(X\) to \(Y\) and Cat with \({D}^{C}\) the category of functors from \(C\) to \(D\) with natural transformations as arrows. The category Pyth with tuple [type, ...] as objects and pure functions between tuples as arrows is also cartesian closed, the exponential of two lists of types \(\mathrm{x},\mathrm{y}\) is given by Callable \(\left\lbrack  {\mathrm{x},\text{tuple}\left\lbrack  \mathrm{y}\right\rbrack  }\right\rbrack\) . The natural isomorphism \(\Lambda  : \operatorname{Pyth}\left( {x \times  y,z}\right)  \rightarrow  \operatorname{Pyth}\left( {y,{z}^{x}}\right)\) is called currying,after the founding father of functional programming Haskell Curry. A function of two arguments \(x \times  y \rightarrow  z\) is the same as a one-argument higher-order function \(y \rightarrow  {z}^{x}\) . Taking the equivalent definition of adjunctions,the unit \({\eta }_{y} : y \rightarrow  {\left( y \times  x\right) }^{x}\) is given by concatenation,</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) There is a simple mnemonic to remember what comes over or under: the input is under the slash in the same way that the denominator is under the fraction bar, it gets canceled when multiplied on the appropriate side \(x/y \otimes  y \rightarrow  x\) and \(y \otimes  y \smallsetminus  x \rightarrow  x\) .</p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 137-->
<p>i.e. lambda *ys: lambda *xs: ys + xs,while the counit \({\epsilon }_{y} : {y}^{x} \times  x \rightarrow  x\) is given by evaluation,i.e. lambda \(\mathrm{f}, * \mathrm{{xs}} : \mathrm{f}\left( {*\mathrm{{xs}}}\right)\) . In fact,we can take the data for a cartesian closed category to be that of a cartesian category \(C\) together with:</p>
<ul>
<li>
<p>an operation \(\exp  : {C}_{0}^{ \star  } \times  {C}_{0}^{ \star  } \rightarrow  {C}_{0}\) sending every pair of types to a generating object,</p>
</li>
<li>
<p>an operation ev \(: {C}_{0}^{ \star  } \times  {C}_{0}^{ \star  } \rightarrow  {C}_{1}\) sending every pair of types \(x,y\) to an arrow \(\operatorname{ev}\left( {x,y}\right)  : \exp \left( {y,x}\right)  \times  x \rightarrow  y,\)</p>
</li>
<li>
<p>an operation \({\Lambda }_{n} : {C}_{1} \rightarrow  {C}_{1}\) for each \(n \in  \mathbb{N}\) ,sending every arrow \(f : x \times  y \rightarrow  z\) with \(x\) of length \(n\) to an arrow \({\Lambda }_{n}\left( f\right)  : y \rightarrow  \exp \left( {z,x}\right)\) .</p>
</li>
</ul>
<p>We can take the axioms to be those of cartesian categories together with \({\Lambda }_{n}(f \times\) \(x\) , \(\left. {{}_{9}\operatorname{ev}\left( {z,x}\right) }\right)  = f\) for all \(f : y \rightarrow  \exp \left( {z,x}\right)\) . Intuitively,if we take a higher-order function, evaluate it then abstract away the result, we get back to where you started,i.e. \({\Lambda }_{n}^{-1}\left( f\right)  = f \times  x\) , ev(z,x).</p>
<!-- Media -->
<p>Listing 1.4.46. Implementation of Pyth as a cartesian closed category.</p>
<p>Ty = tuple [type, ...]</p>
<hr>
<p>def exp(base: Ty, exponent: Ty) -> Ty:
return (Callable[exponent, tuple[base]], )
class Function:
...
def curry(self, n=1, left=True) -> Function:
inside = lambda *xs: lambda <em>ys: self(</em>(xs + ys) if left else (ys + xs))
if left :
dom = self.dom [:len ( self.dom ) - n ]
cod = exp(self.cod, self.dom[len(self.dom) - n:])
else: dom, cod = self.dom[n:], exp(self.cod, self.dom[:n])
return Function (inside, dom, cod)
@staticmethod
def ev(base: Ty, exponent: Ty, left=True) -> Function:
if left :
inside = lambda f, *xs: f(*xs)
return Function (inside, exp (base, exponent) + exponent, base)
inside = lambda *xs: xs[-1] (*xs[:-1])
return Function (inside, exponent + exp(base, exponent), base)
def uncurry(self, left=True) -> Function:</p>
<hr>
<!-- Media --><!-- Meanless: 138 1.4. Adding extra structure-->
<hr>
<pre><code>base, exponent = self.cod[0]._____args_____[-1], self.cod[0]._____args_____[:-1]
base = tuple(base._args_) if is_tuple(base) else (base, )
return self ( exponent >> Function.ev(base, exponent) if left\\\\
	else exponent @ self >> Function.ev (base, exponent, left=False)
</code></pre>
<p>exp = under = over = staticmethod(exp)</p>
<hr>
<!-- Media -->
<p>Example 1.4.47. We can check the axioms for cartesian closed categories hold in Pyth.</p>
<hr>
<p>x, y, z = (complex, ), (bool, ), (float, )
f = Function (dom=y, cod=exp(z, x),
inside=lambda y: lambda x: abs(x) ** 2 if y else 0)
\(\mathrm{g} =\) Function \(\left( {\text{dom} = \mathrm{x} + \mathrm{y},\text{ cod} = \mathrm{z}\text{,inside} = {lambda}\mathrm{x},\mathrm{y} : \mathrm{f}\left( \mathrm{y}\right) \left( \mathrm{x}\right) }\right)\)
assert f.uncurry(   ).curry(   )(True)(1j) == f(True)(1j)
assert g.curry(   ).uncurry(   )(True, 1j) == g(True, 1j)</p>
<hr>
<!-- Media -->
<p>A (strict) cartesian closed functor is a cartesian functor \(F\) which respects the exponential,i.e. \(F\left( {y}^{x}\right)  = F{\left( y\right) }^{F\left( x\right) }\) . Thus,we get a category CCCat of cartesian closed categories and functors,with a forgetful functor \(U : \mathbf{{CCCat}} \rightarrow\) MonSig. Its left adjoint \({F}^{CC} :\) MonSig \(\rightarrow  \mathbf{{CCCat}}\) can be constructed in two steps. First,, we define a closed signature as a signature \(\sum\) with a pair of binary operators \(\left( {-/ - }\right) ,\left( {- \smallsetminus   - }\right)  : {\sum }_{0} \times  {\sum }_{0} \rightarrow  {\sum }_{0}\) ,i.e. for every pair \(x,y \in  {\sum }_{0}\) there are two generating objects \(x/y,y \smallsetminus  x \in  {\sum }_{0}\) . A closed monoidal signature is both a monoidal signature (i.e. its generating objects are a free monoid) and a closed signature. Morphisms of closed monoidal signatures are defined in the obvious way, thus we get a category CMonSig with two forgetful functors \(U : \mathbf{{CCCat}} \rightarrow  \mathbf{{CMonSig}}\) and \(U : \mathbf{{CMonSig}} \rightarrow\) MonSig. The left adjoint \({F}^{C} : \mathbf{{MonSig}} \rightarrow  \mathbf{{CMonSig}}\) takes a monoidal signature and freely adds extra objects for the over and under slashes, it can be defined by induction on the number of nested slashes. Now we can define the left adjoint \(F : \mathbf{{CMonSig}} \rightarrow  \mathbf{{CCCat}}\) as a quotient of the free cartesian category with boxes for evaluations, bubbles for currying (i.e. by induction on the number of nested curryings) and relations given by the axioms for natural isomorphisms. Composing the two adjunctions we get \({F}^{CC} :\) MonSig \(\rightarrow  \mathbf{{CCCat}}\) .</p>
<p>Remark 1.4.48. Diagrams in free cartesian closed categories can also be seen as terms of the simply typed lambda calculus (up to \({\beta \eta }\) -equivalence) or as proofs in minimal logic (the fragment of propositional logic with only conjunction and implication). See Abramsky and Tzevelekos [AT11] for an introduction to this Curry-Howard-Lambek correspondence. The problem of deciding the \(\left( {\beta \eta }\right)\) equivalence of a given pair of simply typed lambda terms (or equivalently the equivalence of two minimal logic formulae) is decidable [Tai67] but not elementary recursive [Sta79], i.e. its time complexity is not bounded by any tower of exponentials. As such, the word problem for free cartesian closed categories is as intractable as it gets. If we remove the copying and discarding, the word problem for free symmetric closed categories is decidable in linear time [Vor77]. The algorithm is based on a variant of Gentzen's cut-elimination theorem [Gen35] for multiplicative intuitionistic linear logic (MILL), a substructural logic where the weakening and contraction rules are omitted, i.e. we cannot discard or copy assumptions. To the best of our knowledge, the case of (non-symmetric) closed monoidal categories is still open. We conjecture it can be solved with a variant of cut-elimination for a non-commutative logic omitting the exchange rule, i.e. we cannot swap assumptions.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 139-->
<p>DisCoPy implements the types of the closed diagrams with a subclass Exp of Ty for exponentials. Over and Under are two subclasses of Exp,shortened to \(\mathrm{x} \gg  \mathrm{y}\) and \(\mathrm{y} &#x3C; \mathrm{x}\) ,and attached to the Diagram class as two static methods over and under. We need to initalise the type self: Exp with some list of objects, our only choice is self.inside=[self]. Thus, we need to override the equality and printing methods so that we don't fall into infinite recursion. We also need to override the cast method so that the unit law is satisfied,i.e. self ( \(\mathrm{{Ty}}\left( \right)  =  =\) self \(=  = \mathrm{{Ty}}\left( \right)  @\) self.</p>
<!-- Media -->
<p>Listing 1.4.49. Implementation of the types in free closed categories.</p>
<hr>
<p>class Ty (monoidal.Ty):
@classmethod
def cast(cls, old: monoidal.Ty) -> Ty:
return old[0] if len(old) == 1 and isinstance(old[0], Exp) else cls(old)
def _____pow _ (self, other) :
return Exp(self, other) if isinstance(other, Ty)\\
else super(   ). _pow _ (other)
class Exp(Ty) :
cast = Ty.cast
def <em><strong><strong>init</strong></strong></em>(self, base, exponent):
self.base, self.exponent = base, exponent
super(   ).<strong>init</strong>(inside=(self, ))</p>
<hr>
<!-- Media --><!-- Meanless: 140 1.4. Adding extra structure-->
<hr>
<pre><code>def _____eq_____ (self, other):
	return isinstance(other, type(self))\\
		and (self.base, self.exponent) == (other.base, other.exponent)
_____str_____ = lambda self: "(\{\} ** \{\})".format(self.base, self.exponent)
</code></pre>
<p>class Over (Exp) :
<em><strong><strong>str</strong></strong></em> = lambda self: "({} &#x3C;&#x3C; {})".format(self.base, self.exponent)
class Under (Exp) :
<em><strong><strong>str</strong></strong></em> = lambda self: "({} >> {})".format(self.exponent, self.base)
Ty. <em>1shift</em> = lambda self, other: Over(self, other)
Ty. <em>rshift</em> = lambda self, other: Under(other, self)</p>
<hr>
<p>Closed diagrams are implemented with two subclasses of Box for currying and evaluation, which are attached to the Diagram class as two static methods curry and ev. We shorten Diagram.ev (base, exponent, left) to Ev (exponent >> base) if left else Ev (base &#x3C;&#x3C; exponent). Closed functors map Exp types to the over and under methods of their codomain, similarly for Curry and Uncurry boxes.</p>
<!-- Media -->
<p>Listing 1.4.50. Implementation of free closed categories and functors.</p>
<p>class Diagram(monoidal.Diagram):</p>
<hr>
<pre><code>curry = lambda self, n=1, left=True: Curry(self, n, left)
@staticmethod
def ev(base: Ty, exponent: Ty, left=True) -> Ev:
	return Ev (base &#x3C;&#x3C; exponent if left else exponent >> base)
def uncurry(self: Diagram, left=True) -> Diagram:
	base, exponent = self.cod.base, self.cod.exponent
	return self @ exponent >> Ev(base &#x3C;&#x3C; exponent) if left\\;
		else exponent @ self >> Ev (exponent >> base)
</code></pre>
<p>class Box (monoidal. Box, Diagram) :
cast = Diagram.cast
class Ev (Box) :
def _<em>init</em>(self, x: Exp) :
self.base, self.exponent = x.base, x.exponent
self.left = isinstance(x, 0ver)
dom, cod = (x @ self.exponent, self.base) if self.left\\
else (self.exponent @ x, self.base)</p>
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 141-->
<hr>
<pre><code>	super(   )._init_("Ev" + str(x), dom, cod)
</code></pre>
<p>class Curry (Box):
def <em><strong><strong>init</strong></strong></em>(self, diagram: Diagram, n=1, left=True):
self.diagram, self.n, self.left = diagram, n, left
name = "Curry({}, {}, {})".format(diagram, n, left)
if left :
dom = diagram.dom [:len (diagram.dom) - n]
cod = diagram.cod &#x3C;&#x3C; diagram.dom[len(diagram.dom) - n:]
else: dom, cod = diagram.dom[n:], diagram.dom[:n] >> diagram.cod
super(   ).<strong>init</strong>(name, dom, cod)
Diagram.over, Diagram.under, Diagram.exp = map(staticmethod, (Over, Under, Exp))
class Functor (monoidal.Functor) :
dom = cod = Category(Ty, Diagram)
def <em><strong><strong>call</strong></strong></em> (self, other) :
for cls, attr in [(Over, "over"), (Under, "under"), (Exp, "exp")]:
if isinstance(other, cls):
method = getattr(self.cod.ar, attr)
return method ( self (other.base ) , self (other.exponent ) )
if isinstance(other, Curry):
return self.cod.ar.curry(   )
self(other.diagram), len(self(other.cod.exponent)), other.left)
if isinstance(other, Ev):
return self.cod.ar.ev(   )
self(other.base), self(other.exponent), other.left)
return super(   ). _call (other)</p>
<hr>
<!-- Media -->
<p>Example 1.4.51. We can check the axioms by applying functors into Pyth and evaluating the result on some test input.</p>
<hr>
<p>x, y, z = map(Ty, "xyz")
f, g = Box ('f', y, z &#x3C;&#x3C; x), Box ('g', y, z >> x)
F = Functor (   )
ob={x: complex, y: bool, z: float},
ar={f: lambda y: lambda x: abs(x) ** 2 if y else 0,
g: lambda y: lambda z: z + 1j if y else -1j}
cod=Category (Ty, Function))
assert \(F\left( {f\text{.uncurry().curry())(True)(1j) ==}F\left( f\right) \text{(True)(1j)}}\right)\)
assert F(g.uncurry(left=False).curry(left=False))(True)(1.2) == F(g)(True)(1.2)</p>
<hr><!-- Meanless: 142 1.4. Adding extra structure-->
<p>Understanding the relationship between closed and rigid categories will also explain how we draw closed diagrams, using the bubble notation introduced by Baez and Stay [BS10, Section 2.6]. Indeed, in a free rigid category the exponentials are given as a tensor of a type and an adjoint, thus we can draw them as two wires side by side. On the other hand, the exponentials of a free closed category are defined as generating objects, they ought to be drawn as one wire but we can decide to draw them as two, inseparable wires. This constraint can be materialised by a clasp that binds the two wires together. Similarly, in free rigid categories we can draw evaluation and currying as diagrams with cups and caps while in a free closed category they are defined as generating boxes, which ought to be drawn as black boxes. We can decide to draw them the same way as in a rigid category, with a bubble surrounding them to prohibit illicit rewrites. Once drawn in this way, the equations for currying become a special case of the snake equations, although in general closed categories do not have boxes for cups and caps.</p>
<!-- Media -->
<p>Listing 1.4.52. Implementation of free rigid categories as closed categories.</p>
<hr>
<p>rigid.Ty.<em><strong><strong>lshift</strong></strong></em> = lambda self, other: self @ other.1
rigid.Ty. <em>rshift</em> = lambda self, other: self.r @ other
rigid.Diagram.over = staticmethod(lambda base, exponent: base &#x3C;&#x3C; exponent)
rigid.Diagram.under = staticmethod(lambda base, exponent: exponent >> base)
@classmethod
def ev(cls, base: rigid.Ty, exponent: rigid.Ty, left=True) -> rigid.Diagram:
return base @ cls.cups(exponent.l, exponent) if left\
else cls.cups(exponent, exponent.r) @ base
def curry(self: rigid.Diagram, n=1, left=True) -> rigid.Diagram:
if left :
base, exponent = self.dom[:n], self.dom[n:]
return base @ self.caps(exponent, exponent.1) >> self @ exponent.1
offset = len ( self.dom ) - n
base, exponent = self.dom[offset:], self.dom[:offset]
return self.caps (exponent.r, exponent) @ base >> exponent.r @ self
Diagram.ev, Diagram.curry = ev, curry</p>
<hr>
<!-- Media -->
<p>Example 1.4.53. We can draw closed diagrams by applying a functor to a rigid category with bubbled evaluation and currying.</p>
<hr>
<!-- Footnote -->
<hr>
<p>class ClosedDrawing(rigid.Diagram):
ev = staticmethod(lambda base, exponent, left=True:</p>
<hr>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 143-->
<hr>
<pre><code>	rigid. Diagram.ev (base, exponent, left). bubble(   ))
curry = lambda self, \( \mathrm{n} = 1 \) , left=True: \\\\
	rigid. Diagram. curry ( self , n , left ). bubble (   )
</code></pre>
<p>Draw = Functor(lambda x: x, lambda f: f, cod=Category(rigid.Ty, ClosedDrawing))
Diagram.draw = lambda self, **params: Draw(self).draw(**params)
f, g, h = Box('f', x, z &#x3C;&#x3C; y), Box('g', x @ y, z), Box('h', y, x >> z)
drawing.equation ( f. uncurry (   ) . curry (   ) , f )
drawing.equation ( h.uncurry ( left = False ).curry ( left = False ) , h )</p>
<hr>
<!-- Media -->
<!-- figureText: \( x \) \( x \) \( x \) \( x \) \( y \) \( {y}^{l} \) \( z \) \( {y}^{l} \) \( y \) \( {y}^{\prime } \) \( {y}^{r} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_142.jpg?x=269&#x26;y=804&#x26;w=1188&#x26;h=320&#x26;r=0">
<p>drawing.equation (g.curry(   ). uncurry(   ), g, g.curry(left=False).uncurry(left=False))</p>
<!-- figureText: \( x \) \( y \) \( y \) \( {x}^{r} \) \( z \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_142.jpg?x=517&#x26;y=1231&#x26;w=682&#x26;h=312&#x26;r=0">
<!-- Media -->
<h4>1.4.7 Traced categories</h4>
<p>The category Pyth has another categorical structure in common with hypergraph categories like Tensor: they are both traced symmetric categories. A symmetric category is traced when it comes equipped with a family of functions \({\operatorname{trace}}_{x}\left( {a,b}\right)\) : \(C\left( {a \otimes  x,b \otimes  x}\right)  \rightarrow  C\left( {a,b}\right)\) subject to axioms that formalise the intuition that we can trace a morphism \(f : a \otimes  x \rightarrow  b \otimes  x\) by connecting its input and output \(x\) -wires in a loop,see Joyal et al. [JSV96].</p>
<p>Every compact closed category has a trace given by cups and caps, traced symmetric categories allow to express recursion and fixed points more generally in non-rigid categories. Indeed in the case of a cartesian category such as Pyth, the trace can equivalently be given in terms of fixed point operators \({\operatorname{fix}}_{x} : C(a \times\) \(x,x) \rightarrow  C\left( {a,x}\right)\) [Sel10,Proposition 6.8]. Dually,in a cocartesian category the trace can be defined in terms iteration operators iter \(x : C\left( {x,a + x}\right)  \rightarrow  C\left( {x,a}\right)\) . When the category has biproducts, it is sufficient to define a repetition operator \({\text{repeat}}_{x} : C\left( {x,x}\right)  \rightarrow  C\left( {x,x}\right)\) [Sel10,Proposition 6.11]. In the category of finite sets and relations \({\mathbf{{Mat}}}_{\mathbb{B}}\) with the direct sum as tensor,this coincides with the usual notion of reflexive transitive closure [JSV96, Proposition 6.3].</p><!-- Meanless: 144 1.4. Adding extra structure-->
<!-- Media -->
<p>Listing 1.4.54. Implementation of the syntax for free traced categories.</p>
<hr>
<p>class Diagram (symmetric. Diagram) :
def trace ( self , n=1 ) :
return Trace(self, n)
class Box (symmetric. Box, Diagram) :
cast = Diagram.cast
class Trace(Box):
def <strong>init</strong>(self, diagram: Diagram, n=1) :
assert diagram.dom \(\left\lbrack  {-\mathrm{n} : }\right\rbrack   =  =\) diagram.cod \(\left\lbrack  {-\mathrm{n} : }\right\rbrack\)
self.diagram, name = diagram, "Trace({}, {})".format(diagram, n)
super(   ). <em><strong><strong>init</strong></strong></em>(name, diagram.dom[:-n], diagram.cod[:-n])
class Functor (symmetric.Functor) :
dom = cod = Category (Ty, Diagram)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Trace):
n = len(self(other.diagram.dom)) - len(self(other.dom))
return self.cod.ar.trace(self(other.diagram), n)
return super(   ). _call (other)</p>
<hr>
<!-- Media -->
<p>Example 1.4.55. We can draw traced diagrams by applying a traced functor into compact-closed categories with bubbles.</p>
<hr>
<p>def compact_trace(self, n=1):
return self.dom[:-n] @ self.caps(self.dom[-n:], self.dom[-n:].r)\\
>> self @ self.dom[-n:].r\
>> self.cod[:-n] @ self.cups(self.cod[-n:], self.cod[-n:].r)
compact.Diagram.trace = compact_trace
class TracedDrawing(compact.Diagram) :
trace = lambda self, n: compact_trace(self, n).bubble(   )</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 145-->
<pre><code>Draw = Functor(lambda x: x, lambda f: f, cod=Category(Ty, TracedDrawing))
Diagram.draw = lambda self, **params: Draw(self).draw(**params)
</code></pre>
<p>\(\mathrm{a},\mathrm{b},\mathrm{x} = \operatorname{map}\left( {\mathrm{{Ty}},\text{"abx"}}\right)\)
\(\operatorname{Box}\left( {{}^{\prime }{f}^{\prime },a@x,b@x}\right)\) .trace(   ).draw(   )</p>
<hr>
<!-- Media -->
<!-- figureText: \( a \) \( x \) \( x \) \( a \) \( b \) \( b \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_144.jpg?x=680&#x26;y=555&#x26;w=339&#x26;h=429&#x26;r=0">
<!-- Media -->
<p>Listing 1.4.56. Implementation of Pyth as a traced cartesian category.</p>
<!-- Media -->
<hr>
<p>class Function:
...
def fix(self, \(\mathrm{n} = 1\) ):
if n > 1 : return self.fix(   ).fix(n - 1)
dom, cod = self.dom[:-1], self.cod
def inside(*xs, y=None):
result = self.inside (*xs + ((   ) if y is None else (y, )))
return \(y\) if result == \(y\) else inside (*xs, \(y =\) result)
return Function (inside, dom, cod)
def trace(self, n=1) :
dom, cod, traced = self.dom[:-n], self.cod[:-n], self.dom[-n:]
fixed = (self >> self.discard(cod) @ traced).fix(   )
return self.copy(dom) >> dom @ fixed\
>> self >> cod @ self.discard(traced)</p>
<hr>
<!-- Media -->
<p>Example 1.4.57. We can compute the golden ratio as a fixed point. Note that in order to find a fixed point we need a default value to start from.</p>
<hr>
<p>phi = Function(lambda x=1: 1 + 1 / x, [int], [int]).fix(   )
assert phi(   ) == (1 + sqrt(5)) / 2</p>
<hr>
<p>Listing 1.4.58. Implementation of \({\mathbf{{Mat}}}_{\mathbb{S}}\) as a traced biproduct category.</p><!-- Meanless: 146 1.5. A premonoidal approach-->
<!-- Media -->
<hr>
<p>class Matrix:
...
def repeat ( self ) :
assert self.dtype is bool and self.dom == self.cod
return sum(   )
Matrix.id(self.dom).then(*n * [self]) for \(\mathrm{n}\) in range(self.dom + 1)
def trace(self, n=1):
assert self.dtype is bool
\(\mathrm{A},\mathrm{B},\mathrm{C},\mathrm{D} =\) (row >> self >> column
for row in [self.id(self.dom - n) @ self.unit(n),
self.unit ( self.dom - n ) @ self.id ( n ) ]
for column in [self.id(self.cod - n) @ self.discard(n),
self.discard(self.cod - n) @ self.id(n)])
return \(\mathrm{A} + \left( {\mathrm{B} >  > \mathrm{D}\text{. repeat ()} >  > \mathrm{C}}\right)\)</p>
<hr>
<!-- Media -->
<h3>1.5 A premonoidal approach</h3>
<p>In the previous section, we have seen that cartesian closed categories give us enough syntax to interpret (simply typed) lambda terms. Thus, we can execute the diagrams in a free cartesian closed category as functions by applying a functor into Set or Pyth, we can also interpret them as functors by applying a functor into Cat with the cartesian product as tensor. Now if we remove the cartesian assumption, the diagrams of free closed categories give us a programming language with higher-order functions where we cannot copy, discard or even swap data: the (non-commutative) linear lambda calculus. With a more restricted language, we get a broader range of possible interpretations. For example, there can be only one cartesian closed structure on Cat (because any other would be naturally isomorphic) but are there any other monoidal closed structures? Foltz, Lair and Kelly [FLK80] answer the question with the positive: Cat has exactly two closed structures: the usual cartesian closed structure with the exponential \({D}^{C}\) given by the category of functors \(C \rightarrow  D\) and natural transformations,and a second one where the exponential \(C \Rightarrow  D\) is given by the category of functors \(C \rightarrow  D\) and transformations, with no naturality requirement.</p>
<p>The corresponding tensor product on Cat,i.e. the left adjoint \(C\square  -  \dashv  C \Rightarrow   -\) ,is called the funny tensor product, maybe because mathematicians thought it was funny not to require naturality. More explicitly,the funny tensor \(C\square D\) can be described as the push-out of \(C \times  {D}_{0} \leftarrow  {C}_{0} \times  {D}_{0} \rightarrow  {C}_{0} \times  D\) where \({C}_{0},{D}_{0}\) are the discrete categories of objects,or equivalently as a quotient of the coproduct \(\left( {C \times  {D}_{0} + {C}_{0} \times  D}\right) /R\) where the relations are given by \(\left( {0,\operatorname{id}\left( x\right) ,y}\right)  = \left( {1,x,\operatorname{id}\left( y\right) }\right)\) . Even more explicitly, the objects of \(C\square D\) are given by the cartesian product \({C}_{0} \times  {D}_{0}\) ,the arrows are alternating compositions \(\left( {0,{f}_{1},{y}_{1}}\right) \overset{ \circ  }{ \circ  }\left( {1,{x}_{2},{g}_{2}}\right) \overset{ \circ  }{ \circ  }\cdots \overset{ \circ  }{ \circ  }\left( {0,{f}_{n - 1},{y}_{n - 1}}\right) \overset{ \circ  }{ \circ  }\left( {1,{x}_{n},{g}_{n}}\right)\) of arrows in one category paired with an object of the other. When the two categories are in fact monoids, the funny tensor is called the free product because it sends free monoids to free monoids,i.e. \({X}^{ \star  }\square {Y}^{ \star  } = {\left( X + Y\right) }^{ \star  }\) . This is also true for free categories,i.e. \(F\left( \sum \right) \square F\left( {\sum }^{\prime }\right)  = F\left( {\sum  \times  {\sum }_{0}^{\prime } \cup  {\sum }_{0} \times  \sum }\right)\) ,so maybe [ should be called free rather than funny. While a functor on a cartesian product \(F : C \times  D \rightarrow  E\) can be seen as a functor of two arguments that is functorial in both simultaneously,i.e. \(F\left( {f\mathring{} {f}^{\prime },g\mathring{} {f}^{\prime }}\right)  = F\left( {f,g}\right) \mathring{} F\left( {{f}^{\prime },{g}^{\prime }}\right)\) ,a functor on a funny product \(F : C\square D \rightarrow  E\) is functorial separately in its \(C\) and \(D\) arguments,i.e. \(F\left( {0,f\mathring{} {f}^{\prime },y}\right)  = F\left( {0,f,y}\right) \mathring{} F\left( {0,{f}^{\prime },y}\right)\) and \(F\left( {1,x,g\mathring{} {g}^{\prime }}\right)  = F\left( {1,x,g}\right) \mathring{} F\left( {1,x,{g}^{\prime }}\right)\) .</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 147-->
<h4>1.5.1 Premonoidal categories &#x26; state constructions</h4>
<p>Now recall that a (strict) monoidal category \(C\) is a monoid in \(\left( {\mathbf{{Cat}}, \times  }\right)\) ,i.e. the tensor is a functor on a cartesian product \(\otimes   : C \times  C \rightarrow  C\) . In a similar way,we define a (strict) premonoidal category as a monoid in \(\left( {\mathbf{{Cat}},\square }\right)\) ,i.e. a category \(C\) with an associative,unital functor on the funny product \(\boxtimes   : C\square C \rightarrow  C\) . A (strict) premonoidal functor \({}^{1}\) is a functor that commutes with \(\boxtimes\) ,i.e. \(F\left( {f \boxtimes  g}\right)  = F\left( f\right)  \boxtimes  F\left( g\right)\) , thus we get a category PreMonCat. As for monoidal categories, we can show that every premonoidal category is equivalent to a foo one, i.e. where the monoid of objects is free,thus we get a forgetful functor \(U :\) PreMonCat \(\rightarrow\) MonSig. The image of \(\boxtimes\) on objects may be given by concatenation,its image on arrows is called whiskering,it is denoted by \(\boxtimes  \left( {0,f,x}\right)  = f \boxtimes  x\) and \(\boxtimes  \left( {1,x,f}\right)  = x \boxtimes  f\) . As we have seen in section 1.2, from whiskering we can define a (biased) tensor product on arrows \(f \boxtimes  g = f \boxtimes  \operatorname{dom}\left( g\right)\) , \(\operatorname{cod}\left( f\right)  \boxtimes  g\) and conversely,we can define whiskering as tensoring with identity arrows.</p>
<p>Thus,we can take the data for a premonoidal category \(C\) to be the same as that of a foo-monoidal category and the only axioms to be those for \(\left( {{C}_{1},\boxtimes ,\operatorname{id}\left( 1\right) }\right)\) being a monoid. That is, a premonoidal category is almost a monoidal category, only the interchange law does not necessarily hold. Every monoidal category (functor) is also a premonoidal category (functor), hence we have an inclusion functor MonCat \(\hookrightarrow\) PreMonCat. An arrow of a premonoidal category \(C\) is called central if it interchanges with every other arrow, a transformation is called central if every component is central. Every identity is central and composition preserves centrality,thus we can define the center \(Z\left( C\right)\) as the subcategory of central arrows and show that \(Z :\) PreMonCat \(\rightarrow\) MonCat. A symmetric premonoidal category is a premonoidal category with a central natural isomorphism \(S : x \boxtimes  y \rightarrow  y \boxtimes  x\) such that the hexagon equations hold and \(S\left( {x,1}\right)  = \operatorname{id}\left( x\right)  = S\left( {1,x}\right)\) .</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) As we mention in remark 1.5.1,the original definition from Power and Robinson [PR97] requires premonoidal functors to be center-preserving. This is not necessary for strict premonoidal functors.</p>
<!-- Footnote -->
<hr><!-- Meanless: 148 1.5. A premonoidal approach-->
<p>Remark 1.5.1. The definition of non-strict premonoidal category and functor requires some caution. Indeed, in order to get a coherence theorem (i.e. in order to prove that every premonoidal category is equivalent to a strict one) we need to assume that the associator and unitor morphisms are central. Then for the composition of premonoidal functors to be well-defined, we need them to be center-preserving which rules out important examples [SL13]. This motivates the definition of (non-cartesian) Freyd categories, also called effectful categories [Rom22]: a triple (C,V,J)of a premonoidal category \(C\) ,a monoidal category \(V\) of values and an identity-on-objects strict premonoidal functor \(J : V \rightarrow  C\) whose image is central. An effectful functor is a functor between effectful categories which restricts to a monoidal functor on their values. Every premonoidal category can be taken as an effectful category with its center as values (in which case effectful functors are center-preserving) or with its discrete category of objects as values (in which case effectful functors don't necessarily preserve centers).</p>
<p>Example 1.5.2. A premonoidal category with one object is just a set with two monoid structures. They do not satisfy the interchange law so the Eckmann-Hilton argument does not apply, the two monoids need not coincide nor be commutative. In this case, the notion of center coincides with the usual notion of center of a monoid, i.e. the submonoid of elements that commute with everything else. Indeed, the monoidal center of a one-object premonoidal is the intersection of the centers of its two monoid structures.</p>
<p>Example 1.5.3. For any small category \(C\) ,the category \(C \Rightarrow  C\) of endofunctors \(C \rightarrow  C\) with (not-necessarily-natural) transformations as arrows is premonoidal.</p>
<p>Example 1.5.4. The category of matrices \({\mathbf{{Mat}}}_{\mathbb{S}}\) with entries in a rig \(\mathbb{S}\) with the Kronecker product as tensor is a premonoidal category, it is monoidal precisely when \(\mathbb{S}\) is commutative.</p>
<p>Example 1.5.5. The category Pyth with tuple as tensor is premonoidal. Every pure function is in the center \(Z\left( \mathbf{{Pyth}}\right)\) ,but the converse is not necessarily true: take the side effect \(f : x \rightarrow  1\) which increments a private,internal counter every time it is called. It is impure, but not enough that we can observe it by parallel composition, i.e. although it does not commute with copy and discard, it can still be interchanged with any other function. In other words, it is in the monoidal center, but not the cartesian center (i.e. the subcategory of comonoid homomorphisms).</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 149-->
<p>Premonoidal categories were introduced by Power and Robinson [PR97] as a way to model programming languages with side effects, reformulating an earlier framework of Moggi [Mog91] which captured notions of computation as monads. Our last two examples can be seen as special cases of a more general pattern: they are Kleisli categories for a strong monad. Infamously, a monad is just a monoid \(T : C \rightarrow  C,\mu  : {T}_{\vartheta }T \rightarrow  T,\eta  : 1 \rightarrow  T\) in the category \({C}^{C}\) of endofunctors with natural transformations as arrows. Its Kleisli category \(K\left( T\right)\) has the same objects as \(C\) and arrows given by \(K\left( T\right) \left( {x,y}\right)  = C\left( {x,T\left( y\right) }\right)\) ,with the identity given by the unit \({\operatorname{id}}_{K}\left( x\right)  = \eta \left( x\right)\) and composition given by post-composition with the multiplication, i.e. \({f}_{\% K}^{ \circ  }g = {f}_{\varnothing }^{ \circ  }T\left( g\right) \mathring{} \mu \left( z\right)\) for \(f : x \rightarrow  T\left( y\right)\) and \(g : y \rightarrow  T\left( z\right)\) . Now if \(C\) happens to be a monoidal category,we can ask for \(T\) to be a monoidal functor,but we also want the multiplication and unit of the monad to play well with the monoidal structure. We could ask for a monoidal monad where \(\mu\) and \(\eta\) are monoidal transformations, i.e. for the monad to be a monoid in the category of monoidal endofunctors and monoidal natural transformations and show that the Kleisli category \(K\left( T\right)\) inherits a monoidal structure. More generally, we can ask only for a (bi)strong monad, equipped with two natural transformations \(\sigma \left( {a,b}\right)  : a \otimes  T\left( b\right)  \rightarrow  T\left( {a \otimes  b}\right)\) and \(\tau \left( {a,b}\right)  : T\left( a\right)  \otimes  b \rightarrow  T\left( {a \otimes  b}\right)\) subject to sufficient conditions for the Kleisli category \(K\left( T\right)\) to inherit a premonoidal structure. It is monoidal precisely when the monad is commutative,i.e. the two arrows from \(T\left( x\right)  \otimes  T\left( y\right)\) to \(T\left( {x \otimes  y}\right)\) are equal.</p>
<p>Example 1.5.6. Take the category \(C =\) Set and the distribution monad \(T\left( X\right)  =\) \(\{ p : X \rightarrow  \mathbb{S} \mid\) phas finite support \(\}\) for a rig \(\mathbb{S}\) with the image on arrows given by pushforward \(T\left( {f : X \rightarrow  Y}\right) \left( {p : X \rightarrow  \mathbb{S}}\right)  : y \mapsto  \mathop{\sum }\limits_{{x \in  {f}^{-1}\left( y\right) }}p\left( x\right)\) ,the multiplication and unit induced by the rig multiplication and unit. If we construct its Kleisli category and take the subcategory spanned by finite sets,we get the category \({\mathbf{{Mat}}}_{S}\) of matrices seen as functions \(m : Y \rightarrow  {\mathbb{S}}^{X} \simeq  X \times  Y \rightarrow  \mathbb{S}\) . One can show this is a strong monad, and it is commutative precisely when the rig is commutative.</p>
<p>Example 1.5.7. Take any closed symmetric category \(C\) and the state monad \(T\left( x\right)  = {s}^{s \otimes  x}\) for some object \(s\) ,an arrow \(f : x \rightarrow  y\) in the Kleisli category \(K\left( T\right)\) is given by an arrow \(f : s \otimes  x \rightarrow  s \otimes  y\) in \(C\) (up to uncurrying). One can show that \(T\) is strong and thus \(K\left( T\right)\) is premonoidal. When \(C =\) Set the state monad is a non-commutative as it gets: \(T\) is commutative if and only if \(s\) is trivial. Whiskering an arrow \(f : s \otimes  x \rightarrow  s \otimes  y\) by an object \(z\) on the left is given by pre- and post-composition with swaps \(z \boxtimes  f = S\left( {s,z}\right)  \otimes  x\) ; \(z \otimes  f\) ; \(S\left( {z,s}\right)  \otimes  y\) ,whiskering on the right is easier \(f \boxtimes  z = f \otimes  z\) .</p><!-- Meanless: 150 1.5. A premonoidal approach-->
<p>Jeffrey [Jef97] then gave the first definition of free premonoidal categories, his construction formalises the intuition that non-central arrows are to be thought as arrows with side effects. The state construction takes as input a symmetric monoidal category \(C\) and an object \(s\) ,and builds a symmetric premonoidal category \(\mathbf{{St}}\left( {C,s}\right)\) with the same objects as \(C\) ,arrows given by \(\operatorname{St}\left( {C,s}\right) \left( {x,y}\right)  = C\left( {s \otimes  x,s \otimes  y}\right)\) and whiskering defined as in the state monad. Intuitively,an arrow in \(\operatorname{St}\left( {C,s}\right)\) is an arrow in \(C\) which also updates a global state encoded in the object \(s\) ,which we can draw as an extra wire passing through every box of the diagram, preventing them from being interchanged. More formally,given a monoidal signature \(\sum\) we can construct the free symmetric premonoidal category by taking the state construction \(\operatorname{St}\left( {{F}^{S}\left( {\sum +\{ s\} }\right) ,s}\right)\) over the free symmetric category with an extra object \(s\) ,then taking the subcategory spanned by objects of the form \(s \otimes  t\) for \(t \in  {\sum }_{0}^{ \star  }\) . We can generalise this to (non-symmetric) free premonoidal categories but we still need symmetry at least for the extra object,i.e. natural isomorphisms \(S\left( {s,x}\right)  : s \otimes  x \rightarrow  x \otimes  s\) for each object \(x\) , subject to hexagon and unit equations. We refer the reader to Roman [Rom22] for a formalisation of this result in the framework of effectful categories.</p>
<p>We call this definition of the free premonoidal category as a state construction over a free monoidal category with an extra swappable object the monoidal approach to premonoidal categories. In what we call the premonoidal approach to monoidal categories, definitions go the other way around with free premonoidal categories as the fundamental notion and free monoidal categories as an interesting quotient. Indeed, we have been using the arrows of free premonoidal categories all along: they are string diagrams, defined as lists of layers without quotienting by interchanger. Equivalently, they are labeled generic progressive plane graphs up to generic deformation, i.e. with at most one box node at each height. While in the monoidal approach, string diagrams are defined as non-planar graphs and the ordering of boxes is materalised by extra wires connecting the boxes in sequence, in the premonoidal approach we take this ordering as data: boxes are in a list. This comes with an immediate advantage: equality of premonoidal diagrams can be defined in terms of equality of lists, hence it is decidable in linear time whereas equality of monoidal diagrams has quadratic complexity and equality of symmetric diagrams could be as hard as graph isomorphism. Another advantage of representing string diagrams with lists rather than graphs is that the code for functor application, i.e. the interpretation of diagrams, is a simple for loop rather than an elaborate graph algorithm. Similarly, the algorithm for drawing premonoidal diagrams requires almost no choices, the order of wires and boxes is fixed, we can only choose their shape and the spacing between them. On the other hand, drawing graphs requires complex heuristics and graphical interfaces in order to get satisfying results.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 151-->
<h4>1.5.2 Hypergraph versus premonoidal diagrams</h4>
<p>In order to compare the graph-based and list-based approaches, we need to say a few words about how string diagrams for symmetric categories are implemented. Recall from sections 1.4.2 and 1.4.3 that equality of diagrams in symmetric and hypergraph categories reduce to graph and hypergraph isomorphisms respectively. This can be made explicit by implementing these diagrams as graphs and hypergraphs rather than lists of layers with explicit boxes for swaps and spiders. Given a monoidal signature \(\sum\) ,a hypergraph diagram (also called hypergraphs with ports) \(f\) is given by:</p>
<ul>
<li>
<p>its domain and codomain \(\operatorname{dom}\left( f\right) ,\operatorname{cod}\left( f\right)  \in  {\sum }_{0}^{ \star  }\) ,</p>
</li>
<li>
<p>a list of boxes boxes \(\left( f\right)  \in  {\sum }_{1}^{ \star  }\) from which we define:</p>
</li>
<li>
<p>input_ports \(\left( f\right)  = \operatorname{cod}\left( f\right)  + \mathop{\coprod }\limits_{i}\operatorname{dom}\left( {f}_{i}\right)\) ,</p>
</li>
<li>
<p>output_ports \(\left( f\right)  = \operatorname{dom}\left( f\right)  + \mathop{\coprod }\limits_{i}\operatorname{cod}\left( {f}_{i}\right)\) ,</p>
</li>
<li>
<p>and ports \(\left( f\right)  =\) input_ports \(\left( f\right)  +\) output_ports(f)</p>
</li>
<li>
<p>a number of spiders \(\operatorname{spiders}\left( f\right)  = n \in  \mathbb{N}\) together with their list of types spider_types \(\left( f\right)  \in  {\sum }_{0}^{n}\) ,</p>
</li>
<li>
<p>a set of wires wires \(\left( f\right)  : \operatorname{ports}\left( f\right)  \rightarrow\) spiders(f).</p>
</li>
</ul>
<p>The tensor of two hypergraph diagrams is given by concatenating their domain, codomain, boxes and spiders. The composition is defined in terms of pushouts. Given \(f : x \rightarrow  y\) and \(g : y \rightarrow  x\) we have a span of functions spiders \(\left( f\right)  \leftarrow  y \rightarrow\) spiders(g)induced by the wires from the codomain of \(f\) and the domain of \(g\) ,we define spiders(f,g)as the size of the quotient set \(\left( {\operatorname{spiders}\left( f\right)  + \operatorname{spiders}\left( g\right) }\right) /R\) under the relation given by the codomain wires of \(f\) and the domain wires of \(g\) . Concretely, this is computed as the reflexive transitive closure of the binary relation on spiders \(\left( f\right)  +\) spiders(g). The identity diagram id(x)has spiders \(\left( f\right)  = \left| x\right|\) and wires given by the two injections \(\left| x\right|  + \left| x\right|  \rightarrow\) spiders(f). Now we can define a notion of interchanger which takes a hypergraph diagram \(f\) and some index \(i &#x3C; \left| {\operatorname{boxes}\left( f\right) }\right|\) and returns the diagram with boxes \(i\) and \(i + 1\) interchanged,i.e. with the wires relabeled appropriately. While the interchanger of monoidal diagrams is ill-defined when the boxes are connected, that of hypergraph diagrams is always defined. The category \(\operatorname{Hyp}\left( \sum \right)\) with equivalence classes of hypergraph diagrams is in fact isomorphic to the free hypergraph category \({F}^{H}\left( \sum \right)\) which we defined in section 1.4.3 in terms of special commutative Frobenius algebras [Bon+16, Theorem 3.3]. The data structure for hypergraph diagrams has swaps and spiders built-in: they are hypergraph diagrams with no boxes.</p><!-- Meanless: 152 1.5. A premonoidal approach-->
<p>We say a hypergraph diagram is bijective when each spider to be connected to either zero or two ports,so that they define a bijection ports \(\left( f\right)  \rightarrow\) ports(f). We conjecture the subcategory of bijective hypergraph diagrams is isomorphic to the free compact-closed category defined in section 1.4.1 in terms of cups and caps. Spiders connected to zero ports correspond to dimension scalars, i.e. circles composed of a cap then a cup. A hypergraph diagram is monogamous when each spider is connected to exactly one input port and one output port, so that they define a bijection output_ports \(\left( f\right)  \rightarrow\) input_ports(f). We conjecture the subcategory of monogamous hypergraph diagrams is the free traced symmetric category as defined in section 1.4.7. We have not been able to find a proof of this statement nor of the compact-closed case in the literature, although they are a straightforward generalisation of [Bon+16, Theorem 3.3].</p>
<p>A hypergraph diagram is progressive when it is monogamous and furthermore when the output port of box \(i\) is connected to the input port of box \(j\) we have \(i &#x3C; j\) . An equivalent condition is that the underlying hypergraph obtained by forgetting the ports is acyclic and the order of boxes witnesses that acyclicity. An interchanger between boxes \(i\) and \(i + 1\) is progressive when the two boxes are not connected, i.e. progressive interchangers preserve progressivity. The resulting category of progressive hypergraph diagrams up to progressive interchangers is isomorphic to the free symmetric category defined in section 1.4.2 in terms of braidings [Bon+16, Theorem 3.12]. If we remove the interchanger quotient, we get premonoidal versions of free hypergraph, compact closed, traced and symmetric categories. Traced preonoidal categories were introduced by Benton and Hyland [BH03] in order to model recursion in the presence of side-effects. To the best of our knowledge, no one has ever considered premonoidal compact closed categories: the snake equations still hold but we cannot yank the snakes away if there are obstructions, i.e. the snake removal algorithm of section 1.2 does not apply.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 153-->
<p>At every level of this symmetric-traced-compact-hypergraph hierarchy, pre-monoidal diagrams have the same linear-time algorithm for deciding equality, the data structure for hypergraph diagrams faithfully encode the premonoidal axioms without needing to compute any quotient: normal form becomes identity. Now suppose we want to compute the interpretation of such a hypergraph diagram in a category given only access to its methods for identity, composition, tensor, swaps and spiders. This requires to compute the isomorphism \(\operatorname{Hyp}\left( \sum \right)  \rightarrow  {F}^{H}\left( \sum \right)\) ,i.e. we want to describe the given hypergraph diagram as a chosen representative in its equivalence class of premonoidal diagrams with explicit boxes for swaps and spiders. The inverse isomorphism \({F}^{H}\left( \sum \right)  \rightarrow  \mathbf{{Hyp}}\left( \sum \right)\) is computed by applying a premonoidal functor (i.e. a for loop on a list of layers) sending swap and spider boxes to hypergraph diagrams with no boxes.</p>
<p>This isomorphism is implemented in the hypergraph module of DisCoPy which is outlined below. The composition method calls a pushout subroutine which takes as input the numbers of spiders on the left and right, the wires from some common boundary ports to the left and right spiders, and returns the two injections into their pushout. The three properties for bijective, monogamous and progressive diagrams implement the subcategory of compact closed, traced and symmetric diagrams respectively. The three corresponding methods take a diagram and add explicit boxes for spiders, cups and caps so that f.make_bijective(   ).is_bijective for all \(\mathrm{f}\) : Diagram and similarly for monogamous and progressive. The downgrade method calls make_progressive to construct a compact.Diagram with explicit boxes for swaps and spiders.</p>
<p>The method cast applies a compact.Functor from premonoidal to hyper-graph diagrams so that we have cast \(\left( {\mathrm{f}\text{.downgrade())}}\right)  =  = \mathrm{f}\) on the nose for any f: Diagram and cast(f).downgrade(   ) is equal to any f: compact.Diagram up to the special commutative Frobenius axioms. The draw method uses a randomised force-based layout algorithm for graphs to compute an embedding from the hypergraph diagram to the plane where wires do not cross too much. This is still an experimental feature and the results of \(\mathrm{f}\) .draw(   ) usually look much worse than the drawing of \(f\) . downgrade(   ).draw(   ) using the deterministic algorithm of section 1.3.</p>
<p>Listing 1.5.8. Outline of the discopy. hypergraph module.</p>
<hr>
<!-- Footnote -->
<p>def pushout(left: int, right: int,</p>
<p>left_wires: tuple[int, ...], right_wires: tuple[int, ...]</p>
<!-- Footnote -->
<hr><!-- Meanless: 154 1.5. A premonoidal approach-->
<hr>
<pre><code>		) -> tuple[dict[int, int], dict[int, int]]: ...
</code></pre>
<p>@dataclass
class Diagram (Composable, Tensorable):
dom: Ty
cod: Ty
boxes: tuple [Diagram, ...]
wires: tuple [int, ...]
spider_types: tuple [Ty, ...]
@staticmethod
def id(x: Ty) -> Diagram: ...
def then(self, *others: Diagram) -> Diagram: ...
def tensor(self, *others: Diagram) -> Diagram: ...
def interchange(self,i: int) -> Diagram: ...
swap: Callable [[Ty, Ty], Diagram] = staticmethod (...)
spiders: Callable [[int, int, Ty], Diagram] = staticmethod(...)
is_bijective: bool = property(...)
is_monogamous: bool = property(...)
is_progressive: bool = property(...)
def make_bijective(self) -> Diagram: ...
def make_monogamous(self) -> Diagram: ...
def make_progressive(self) -> Diagram: ...
def downgrade(self) -> compact.Diagram: ...
cast = staticmethod(compact.Functor(   )
ob=lambda x: Ty(x.inside[0]),
ar=lambda box: Box (box.name, box.dom, box.cod),
cod=Category(Ty, Diagram)))
def draw(self, **params): ...
class Box (Diagram) :
def <strong>init</strong>(self, name: str, dom: Ty, cod: Ty):
boxes, spider_types, wires = (self, ), tuple(map(Ty, dom @ cod)), ...
self.name = name; super(   ).<em>init</em>(dom, cod, boxes, wires, spider_types)
<em><strong><strong>eq</strong></strong></em> = lambda self, other: cat.Box.<em><strong><strong>eq</strong></strong></em>(self, other)\
if isinstance(other, Box) else super(   ).<em><strong><strong>eq</strong></strong></em>(other)</p>
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 155-->
<p>In some cases however, we can compute the interpretation of hypergraph diagrams without having to downgrade them back to premonoidal diagrams. This is the case for tensor networks, i.e. hypergraph diagrams interpreted in the category Tensor \({}_{\mathbb{S}}\) . Indeed,rather than applying premonoidal functors into our naive Matrix class, DisCoPy can translate hypergraph diagrams as input to tensor contraction algorithms such as the Einstein summation of NumPy [vdWCV11] combined with the just-in-time compilation of JAX [Bra+20], or the specialised TensorNetwork library \(\left\lbrack  {\mathrm{{Rob}} + {19}}\right\rbrack\) . Another example is that of quantum circuits: they are inherently symmetric diagrams. Indeed, the data structure for circuits in a quantum compiler such as \(\mathrm{t} \mid  \mathrm{{ket}}\rangle \left\lbrack  {\text{Siv} + {20}}\right\rbrack\) is secretly some premonoidal symmetric category: objects are lists of qubit (and bit) identifiers, arrows (i.e. circuits) are lists of operations. When circuits are encoded as premonoidal diagrams as we have done in example 1.2.26, qubits are forced into a line because their wires are ordered from left to right, thus applying gates to non-adjacent qubits is encoded in terms of swap boxes. When we apply a premonoidal functor to the category of \(\mathrm{t}|\mathrm{{ket}}\rangle\) circuits,those swap boxes are not interpreted as the physical operation of applying three CNOT gates, but as the logical operation of relabeling our qubit identifiers. It is then the job of the compiler to map these symmetric diagrams (where every qubit can talk to every other) onto the architecture of the machine and potentially introduce physical swaps when a logical gate applies to physical qubits that are not adjacent.</p>
<p>The main advantage of representing diagrams as hypergraphs rather than lists is that we can use graph rewriting algorithms to implement quotient categories. Indeed, the double push-out (DPO) rewriting of Ehrig et al. [EPS73] can be extended from graphs to hypergraph diagrams so that we can match the left-hand side of an axiom in a hypergraph diagram and then compute the substitution with the right-hand side [Bon+20]. Abstractly, DPO rewriting takes two hypegraph diagrams self and pattern and iterates through all possible match (i.e. pairs of diagrams for top and bottom and pairs of types for left and right as defined in section 1.2.3) such that match.subs (pattern) is equal to self up to interchanger. This can be extended to the case of symmetric diagrams by implementing a Boolean property match.is_convex that makes sure that pattern matching does not introduce spiders [Bon+16]. DPO rewriting has been the basis of tools such as Quantomatic and its successor PyZX [KvdW19] [KZ15] for automated diagrammatic reasoning, it is also at the core of circuit optimisation in the \(\mathrm{t}|\mathrm{{ket}}\rangle\) compiler. DisCoPy implements back and forth translations from diagrams to both PyZX and t|ket\ ), thus we can use their rewriting engines to implement quotient categories, i.e. to define normal forms.</p><!-- Meanless: 156 1.5. A premonoidal approach-->
<p>However, the hypergraph approach breaks down in the case of non-symmetric monoidal categories. Indeed, the monoidal functor from the free monoidal category to the free symmetric category is not faithful, for example it sends two nested circles and two circles side by side to the same hypergraph diagram. We conjecture that the category of planar \({}^{1}\) progressive hypergraph diagrams is the free spacial category, i.e. one with \(s \otimes  x = x \otimes  s\) for all scalars \(s : 1 \rightarrow  1\) and objects \(x\) . Translated in terms of the topological definition of string diagrams, this would correspond to taking labeled progressive plane graphs up to deformation of three-dimensional space rather than up to deformation of the plane [Sel10, Conjecture 3.4]. When presented as quotients of free monoidal categories, spacial categories require an infinite family of axioms indexed by all possible scalar diagrams: in the absence of symmetry we cannot decompose the equation \(\left( {f,g}\right)  \otimes  x = x \otimes  \left( {f,g}\right)\) for a state \(f : 1 \rightarrow  y\) followed by an effect \(g : y \rightarrow  1\) in terms of two smaller equations about \(f\) and \(g\) passing through the wire \(x\) . That every braided monoidal category is spacial follows from the naturality of the braiding, we do not know of any natural example of non-free non-braided spacial category. Moreover, it is an open question whether we can extend DPO rewriting to the case of spacial monoidal categories, i.e. whether there is an efficiently checkable condition that ensures that pattern matching does not introduce swaps.</p>
<p>Thus, DisCoPy's planar premonoidal approach to string diagrams allows to define diagrams in non-symmetric categories that cannot be defined as hypergraphs. Although the concrete examples of categories we have discussed so far (functions, matrices, circuits) are all symmetric, planarity is essential if we are to model grammatical structure in terms of string diagrams as we will in section 2.1. Indeed, the left to right order of wires in a planar diagram encode the chronological order of words in a sentence, allowing arbitrary swaps would make grammaticality permutation-invariant: if a sentence is grammatical, then so would be any random shuffling of it. More impotantly, planarity in grammar has been given a cognitive explanation. In order to minimise the computational resources needed by the brain, human languages tend to minimise the distance between words that are syntactically connected [FMG15] and the minimisation of swaps comes as a side-effect [Can06]. It can also be given a complexity-theoretic explanation: planar grammatical structures such as Chomsky's syntax trees, Lambek's pregroup diagrams or Gaifman's dependency trees (which we introduce in section 2.1) are all context-free, they have the same expressive power as push-down automaton. As we will mention in section 2.1.1, cross-serial dependencies are counter examples where grammatical wires are allowed to cross, albeit in a restricted way that makes them mildly context-sensitive [Sta04]. Yeung and Kartsaklis [YK21] showed that up to word reordering, the diagrams for these cross-serial dependencies can always be rewritten in a planar way using naturality. They then used DisCoPy to encode every sentence of Alice in Wonderland as a diagram, ready to be translated into a circuit and sent to a quantum computer.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A hypergraph diagram is planar when we can embed it in the plane,or equivalently it is the image of a swap-free premonoidal diagram.</p>
<!-- Footnote -->
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 157-->
<h4>1.5.3 Towards higher-dimensional diagrams</h4>
<p>The premonoidal approach is also well-suited to be generalised from two- to arbitrary-dimensional diagrams. The first step would be to add some colours to our diagrams, generalising them from monoidal categories to (strict) 2-categories, or equivalently from premonoidal categories to sesquicategories. The data for a sesquicategory \(C\) is given by:</p>
<ul>
<li>
<p>the data for a category \(\left( {{C}_{0},{C}_{1},{\operatorname{dom}}_{0},{\operatorname{cod}}_{0},{}_{90}^{ \circ  },{\operatorname{id}}_{0}}\right)\) where the objects \({C}_{0}\) and arrows \({C}_{1}\) are called the class of0- and 1-cells,</p>
</li>
<li>
<p>a class \({C}_{2}\) of 2-cells,</p>
</li>
<li>
<p>domain and codomain \({\operatorname{dom}}_{1},{\operatorname{cod}}_{1} : {C}_{2} \rightarrow  {C}_{1}\) ,</p>
</li>
<li>
<p>an identity \({\operatorname{id}}_{1} : {C}_{1} \rightarrow  {C}_{2}\) and a partial composition \(\left( {§}_{1}\right)  : {C}_{2} \times  {C}_{2} \rightarrow  {C}_{1}\) . such that the following holds</p>
</li>
<li>
<p>\(C\left( {x,y}\right)  = \left\{  {f \in  {C}_{2} \mid  f : x \rightarrow  y}\right\}\) is a category for every pair of 1-cells \(x,y \in  {C}_{1}\) ,</p>
</li>
<li>
<p>composition of 1-cells is a functor \({\left( {}_{9}^{o}\right) }_{0} : C\left( {x,y}\right) \square C\left( {y,z}\right)  \rightarrow  C\left( {x,z}\right)\) for \(\square\) the funny tensor product on Cat.</p>
</li>
</ul>
<p>The axioms for 2-categories are the same but now composition is a bifunctor \({}_{91}^{o}\) : \(C\left( {x,y}\right)  \times  C\left( {y,z}\right)  \rightarrow  C\left( {x,z}\right)\) on a cartesian product. Every bifunctor is also functorial in its two arguments separately thus every 2-category is also a sesquicategory. The canonical example of a (2-category) sesquicategory is \(\mathbf{{Cat}}\) with categories as 0- cells, functors as 1-cells and (natural) transformations as 2-cells. Every monoidal (premonoidal) category is a 2-category (sesquicategory) with one 0-cell. A 2-functor \(F : C \rightarrow  D\) between two 2-categories is given by three functions \({\left\{  {F}_{i} : {C}_{i} \rightarrow  {D}_{i}\right\}  }_{0 \leq  i \leq  2}\) such that \(\left( {{F}_{0},{F}_{1}}\right)  : \left( {{C}_{0},{C}_{1}}\right)  \rightarrow  \left( {{D}_{0},{D}_{1}}\right)\) and \(\left( {{F}_{1},{F}_{2}}\right)  : C\left( {x,y}\right)  \rightarrow  D\left( {{F}_{1}\left( x\right) ,{F}_{1}\left( y\right) }\right)\) are functors for all \(x,y \in  {C}_{1}\) .</p><!-- Meanless: 158 1.5. A premonoidal approach-->
<p>Free sesquicategories are defined in the same way as free premonoidal categories (i.e. as lists of layers) except that now every type comes itself with a domain and codomain, represented as the background colours on the left and right of the wire. Thus we need a 2-signature \(\sum  = \left( {{\sum }_{0},{\sum }_{1},{\sum }_{2},\text{dom,cod}}\right)\) where</p>
<ul>
<li>
<p>\({\sum }_{0}\) is a set of colours,</p>
</li>
<li>
<p>\({\sum }_{1}\) is a set of objects with colours as domain and codomain,</p>
</li>
<li>
<p>\({\sum }_{2}\) is a set of boxes with domain and codomain in the free category \(F\left( {{\sum }_{0},{\sum }_{1}}\right)\) , i.e. lists of generating objects with composable colours.</p>
</li>
</ul>
<p>We also need to require the globular conditions \(\operatorname{dom}\left( {\operatorname{dom}\left( f\right) }\right)  = \operatorname{dom}\left( {\operatorname{cod}\left( f\right) }\right)\) and \(\operatorname{cod}\left( {\operatorname{dom}\left( f\right) }\right)  = \operatorname{cod}\left( {\operatorname{cod}\left( f\right) }\right)\) that ensure that the top-left (top-right) colour is the same as the bottom-left (bottom-right, respectively). Intuitively, the only changes in background colour happen at the wires, labeled by a generating object with the appropriate domain and codomain. The free 2-category \({F}^{2C}\left( \sum \right)\) can then be described by its set of \(\theta\) -cells \({\sum }_{0}\) (the colours),its category of 1-cells \(F\left( {{\sum }_{0},{\sum }_{1}}\right)\) (the types) and a category for every pair of 1-cells: the category of coloured diagrams up to interchanger. The implementation is straightforward: we just need to make Ty a subclass of both monoidal. Ty (so that it can be used as domain and codomain for diagrams) and Arrow (so that it can have a domain and codomain itself).</p>
<p>Listing 1.5.9. Implementation of the free sesquicategory with Colour as 0 -cells,</p>
<p>Ty as 1-cells and Diagram as 2-cells.</p>
<!-- Media -->
<hr>
<p>class Colour(cat.Ob):
pass
class TyArrow ( cat. Arrow, monoidal.Ty ) :
@inductive
def tensor(self, other):
if isinstance(other, TyArrow):
return cat. Arrow. then ( self , other )
return NotImplemented # Allows whiskering on the left.
___<strong>matmul</strong> = tensor
class Ty ( cat. Box, TyArrow ) :
cast = TyArrow.cast
class Layer (monoidal. Layer):
def <em><strong><strong>init</strong></strong></em>(self, left: Ty, box: monoidal.Box, right: Ty):</p>
<hr>
<!-- Media --><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 159-->
<hr>
<pre><code>	assert left.cod == box.dom.dom and box.dom.cod == right.dom
	super(   ). _____init_(left, box, right)
</code></pre>
<p>class Diagram (monoidal.Diagram) :
pass
class Box (monoidal. Box, Diagram) :
def <strong>init</strong>(self, name: str, dom: Ty, cod: Ty):
assert (dom.dom, dom.cod) == (cod.dom, cod.cod)
monoidal.Box. <em>init</em>(self, name, dom, cod)
Diagram. <em><strong><strong>init</strong></strong></em>(self, (Layer.cast(self), ), dom, cod)
cast = Diagram.cast
@dataclass
class TwoCategory:
colours: type = Colour
ob: type = Ty
ar: type = Diagram
@dataclass
class TwoFunctor (monoidal.Functor) :
colours: DictOrCallable [Colour, Colour]
ob: DictOrCallable [Ty, Ty]
ar: DictOrCallable [Box, Diagram]
dom: TwoCategory = TwoCategory(   )
cod: TwoCategory = TwoCategory(   )
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Colour):
return self.colours[other]
if isinstance(other, Ty):
return self.ob[other]
if isinstance(other, TyArrow):
base_case = self.cod.ob.id(self(other.dom))
return base_case.then(*[self(box) for box in other.inside])
return super(   ). _call (other)</p>
<hr>
<p>Listing 1.5.10. Implementation of Cat as a sesquicategory with transformations as 2-cells.</p>
<hr>
<p>class Transformation (Composable, Tensorable):
def <em><strong><strong>init</strong></strong></em>(self, inside: Callable, dom: Functor, cod: Functor):</p>
<hr><!-- Meanless: 160 1.5. A premonoidal approach-->
<!-- Media -->
<hr>
<pre><code>	assert (dom.dom, dom.cod) == (cod.dom, cod.cod)
	self.inside, self.dom, self.cod = inside, dom, cod
@staticmethod
def id(F: Functor):
	return Transformation (F. cod.ar.id, dom=F, cod=F)
@inductive
def then(self, other: Transformation) -> Transformation:
	return Transformation (lambda x: self(x) >> other(x), self.dom, other.cod)
@inductive
def tensor(self, other: Transformation) -> Transformation:
	return self @ other.dom >> self.cod @ other
def _____matmul_____(self, other: Transformation | Functor) -> Transformation:
	if isinstance(other, Functor):
		return Transformation (   )
				lambda x: other(self(x)),self.dom >> other,self.cod >> other)
	return self.tensor(other)
def _____rmatmul_____(self, other: Transformation | Functor) -> Transformation:
	if isinstance(other, Functor):
		return Transformation (   )
				lambda x: self(other(x)), other >> self.dom, other >> self.cod)
	raise TypeError
def _call_(self, other: Ob) -> Arrow:
	inside, dom, cod = self.inside(other), self.dom(other), self.cod(other)
	return self.cod.cod.ar(inside, dom, cod)
</code></pre>
<p>Cat = TwoCategory (Category, Functor, Transformation)</p>
<hr>
<!-- Media -->
<p>Example 1.5.11. We can interpret colours as categories, types as functors and diagrams as transformations.</p>
<hr>
<p>a = Colour \(\left( {{}^{\prime }{a}^{\prime }}\right)\)
\(\mathrm{x} = \mathrm{{Ty}}\left( {{}^{\prime }{\mathrm{x}}^{\prime },\text{ dom=a,cod=a }}\right)\)
f, g = Box ('f', Ty.id (a), x), Box ('g', x @ x, x)
Pyth = Category (tuple [type, ...], Function)
List = Functor (   )
ob=lambda xs: list[xs],
ar=lambda f: lambda xs: list(map(f, xs)),</p>
<hr><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 161-->
<!-- Media -->
<hr>
<pre><code>dom=Pyth, cod=Pyth)
</code></pre>
<p>Unit = Transformation (   )
lambda _: lambda x: [x], dom=Functor.id(Pyth), cod=List)
Mult = Transformation (   )
lambda _: lambda xs: sum(xs, []), dom=List >> List, cod=List)
F = TwoFunctor(   )
colours={a: Pyth}, ob={x: List}, ar={f: Unit, g: Mult}, cod=Cat)
assert F(f @ x >> g)(int) \(\left( \left\lbrack  {1,2,3}\right\rbrack  \right)\) \
\(= F\left( {x@f > g}\right)\) (int) \(\left( \left\lbrack  {1,2,3}\right\rbrack  \right)  \smallsetminus\)
== F(Diagram.id(x))(int)(([1, 2, 3]) == [1, 2, 3]
assert F(g @ x >> g)(int)([[[42]]]) == [42] == F(x @ g >> g)(int)(([[42]]])</p>
<hr>
<!-- Media -->
<p>We have already discussed another way to construct a 2-categories: taking types as 0 -cells, diagrams as 1-cells and rewrites as 2-cells, in fact this gives a premonoidal sesquicategory. A monoidal 2-signature \(\sum\) is a 2-signature where the objects in \({\sum }_{1}\) have lists of colours \({\sum }_{0}^{ \star  }\) as domain and codomain and the boxes in \({\sum }_{2}\) have domain and codomain in the free premonoidal category \({F}^{P}\left( {{\sum }_{0},{\sum }_{1}}\right)\) . Thus,a box \(r : f \rightarrow  g\) in a monoidal 2-signature may be seen as a rewrite rule with parallel diagrams \(f : x \rightarrow  y\) and \(g : x \rightarrow  y\) as domain and codomain. It generates a free premonoidal sesquicategory with types \({\sum }_{0}^{ \star  }\) as 0 -cells,diagrams \({F}^{P}\left( {{\sum }_{0},{\sum }_{1}}\right)\) as 1-cells and rewrites as 2-cells. We can construct it explicitly by generalising layers to slices with not only types on the left and right but also diagrams on the top and bottom, i.e. a rewrite rule together with a match. Rule is a subclass of Box with diagrams as domain and codomain, Slice is a box made of a rule inside a match with methods for left and right whiskering as well as pre- and post-composition. Rewrite is a subclass of Diagram with Slice as layers, it inherits its vertical composition (i.e. two rewrites applied in sequence) from the diagram class as well as its tensor product (i.e. two rewrites applied in parallel on the tensor of two diagrams). The horizontal composition (i.e. two rewrites applied in parallel on the composition of two diagrams) can be implemented by temporarily replacing left and right whiskering by pre- and post-composition before calling Diagram.tensor.</p>
<p>Listing 1.5.12. Outline of the implementation of free premonoidal sesquicategories.</p>
<hr>
<p>class Slice(monoidal.Box):
def <strong>init</strong>(self, rule: Rule, match: Match):
dom, cod = match.subs(rule.dom), match.subs(rule.cod)
super(   ).<em>init</em>("Slice({}, {})".format(rule, match), dom, cod)</p>
<hr><!-- Meanless: 162 1.5. A premonoidal approach-->
<!-- Media -->
<hr>
<pre><code>@classmethod
def cast(cls, old: Rule) -> Slice:
	\( \mathrm{x},\mathrm{y} = \) old.dom.dom,old.cod.cod
	top, bottom, left, right = old.id(x), old.id(y), x[:0], y[len(y):]
	return cls(old, Match(top, bottom, left, right))
</code></pre>
<p>class Rewrite (Diagram) :
inside: tuple [Slice, ...]
dom: Diagram
cod: Diagram
class Rule (monoidal.Box, Rewrite) :
def <em><strong><strong>init</strong></strong></em>(self, name: str, dom: Diagram, cod: Diagram):
monoidal.Box. _ init_( self, name, dom, cod)
Rewrite. <em><strong><strong>init</strong></strong></em>(self, (Slice.cast(self), ), dom, cod)</p>
<hr>
<!-- Media -->
<p>Note that when the monoidal 2-signature \(\sum\) is in fact a simple 2-signature,i.e. every box \(f \in  {\sum }_{1}\) has domain and codomain of length one,the definition of a rewrite coincides with the definition of coloured diagram. Indeed we can relabel everything one level down: the types are colours, the boxes are types and the rules are boxes: a coloured diagram can be seen as a rewrite of one dimensional diagrams, i.e. lists of types with composable colours. Symmetrically, rewriting an 2-dimensional diagram can itself be seen as a 3-dimensional diagram. If we compose the two constructions (colours and rewrites) together, we get the free 3-sesquicategory with rewrites of coloured diagrams as 3-cells. We can keep on going with modifications of rewrites, i.e. 4-dimensional diagrams, by generalising layers one step further with not only a pair of types (left and right) and a pair of diagrams (top and bottom) but also a pair of rewrites (before and after). What could be the use of a such four-dimensional diagram? For example, a free 4-category with a single 0-, 1- and 2-cell is the same as a free symmetric category (once we relabel everything three levels down). Indeed, the swaps are given by the interchange law and the \(4\mathrm{\;d}\) space in which the diagrams live allows wires to cross and every knot to be untied: every diagram interpreted in Pyth or \({\mathbf{{Mat}}}_{\mathbb{S}}\) is secretly four-dimensional. One dimension lower,a free 3-category with a single 0 - and 1-cell is the same as a free braided category, this is only the tip of the periodic table of k-tuply monoidal n-categories [BS10, Section 2.5].</p>
<p>The proof assistant Globular [BKV18] allows to construct 4-dimensional diagrams using a graphical interface for drawing slices and projections in two dimensions. In fact, the drawing algorithm presented in section 1.3 was reverse engineered from that of Globular. Its successor homotopy.io [RV19] went from four to arbitrary dimensions based on a data structure for diagrams in free n-sesquicategories [BV17]. Interfacing DisCoPy with homotopy.io is in the backlog of features yet to be implemented, so that the user can define diagrams by drag-and-dropping boxes then interpret them in arbitrary n-categories. One of the new feature of homotopy.io compared to its predecessor is the possibility of drawing non-generic diagrams, i.e. with more than one box on the same layer. This amounts to taking the free category over \({L}^{ + }\left( \sum \right)  = {\left( {\sum }_{0} + {\sum }_{1}\right) }^{ \star  } \simeq  {\sum }_{0}^{ \star  }\square {\sum }_{1}^{ \star  }\) rather than \(L\left( \sum \right)  = {\sum }_{0}^{ \star  } \times  {\sum }_{1} \times  {\sum }_{0}^{ \star  }\) . This is also in DisCoPy's backlog, implementing the syntax is straightforward but then it requires to extend the algorithms for functors, drawing, normal forms, etc.</p><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 163-->
<p>Layers with arbitrarily many boxes also allow to define the depth of an arrow in any quotient of a free premonoidal category as the minimum number of layers in its equivalence class of diagrams. As we mentioned in section 1.2.3, premonoidal diagrams also have a well-defined notion of width (the maximum number of parallel wires) which we can extend in the same way to define the width of any quotient. This makes diagrams a foundational data structure for computational complexity theory: a signature can be seen as both a machine and a language, a diagram as both code and data. In the other direction, this also allows to borrow results from complexity theory to characterise the computational resources required in solving problems about diagrams. This will be needed in the next chapter when we will look at NLP problems through the lens of diagrams.</p>
<h3>1.6 Summary &#x26; future work</h3>
<p>This chapter gave a comprehensive overview of DisCoPy and the mathematics behind its design principles: we take the definitions of category theory (as strictly and freely as possible) and translate them into a Pythonic syntax. Figure 1.3 summarises the different modules and their inheritance hierarchy, implementing a subset of the hierarchy of graphical languages surveyed by Selinger [Sel10]. We hope it may be useful both as an introduction to monoidal categories for the Python programmer, and an introduction to Python programming for the applied category theorist.</p>
<p>Note that the code presented in this thesis represents a significant refactoring of the original implementation of DisCoPy v0.4.2 as available online at the time this thesis is submitted \({}^{1}\) . It is available as a standalone version \({}^{2}\) which will later</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) <a href="https://github.com/oxford-quantum-group/discopy/releases/tag/0.4.2">https://github.com/oxford-quantum-group/discopy/releases/tag/0.4.2</a></p>
<p>\({}^{2}\) <a href="https://github.com/toumix/thesis">https://github.com/toumix/thesis</a></p>
<!-- Footnote -->
<hr><!-- Meanless: 164 1.6. Summary & future work-->
<!-- Media -->
<!-- figureText: closed1.4.6 cat1.1 monoidal1.2 spacial1.5.2 braided1.4.2 symmetric1.4.2,1.5.2 cartesian1.4.4 traced1.5.2 matrix python biproducts1.4.5 rigid \( {}^{1,4,1} \) pivotal 1.4.1 tortile1.4.2 hypergraph1.4.3,1.5.2 tensor -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_163.jpg?x=286&#x26;y=292&#x26;w=1000&#x26;h=975&#x26;r=0">
<p>Figure 1.3: DisCoPy's modules and the sections where they are discussed, arrows indicate software dependency.</p>
<!-- Media -->
<p>be merged with the original repository and released as DisCoPy v1.0. We list some of the significant changes between the two versions.</p>
<ul>
<li>
<p>We add type annotations throughout the codebase, using the postponed evaluation of annotations introduced in Python 3.7 [Lan17].</p>
</li>
<li>
<p>We simplify the inheritance mechanism using Python's classmethod decorator. This improves the code reuse for composition of diagrams, application of functors, etc.</p>
</li>
<li>
<p>We reorganise the codebase so that it follows more closely the hierarchy of categorical structures. For example, we move the code for Braid outside of the monoidal module into its own braided module, we also introduce e.g. the tortile module which imports from both rigid and braided.</p>
</li>
<li>
<p>We make the syntax more uniform for arrows in different categories, which</p>
</li>
</ul><!-- Meanless: 1. DisCoPy: Python for the applied category theorist 165-->
<p>are all initialised with the same attributes inside, dom and cod.</p>
<ul>
<li>
<p>We implement whiskering, i.e. tensoring with the identity of a given type on the left or right. This avoids to clutter diagram definitions with Id.</p>
</li>
<li>
<p>Arrows in concrete categories like Matrix, Tensor and Function are no longer subclasses of Box. Instead, we implement the syntactic sugar for composition, whiskering, etc. with abstract classes Composable and Tensorable.</p>
</li>
<li>
<p>We make the Matrix and Tensor classes parameterised by the datatype of their entries. This makes use of the magic method _____ class_getitem_____ which appeared in Python 3.10 [Lev17].</p>
</li>
</ul>
<p>We list but a few of the many potential directions for further developments.</p>
<ul>
<li>
<p>DisCoPy was implemented mainly with correctness in mind, thus there is much room for improving performance. For now, this has not been quite necessary since the diagrams we manipulate are exponentially smaller than the computation they represent. However if we want to implement any serious rewriting efficiently, we will need to port the core algorithms to a lower-level language such as Rust [KN19] and wrap them with Python bindings. This strategy has improved the time performance of PyZX by over 4000 on a small benchmark consisting of the fusion of 1 million spiders \({}^{1}\) .</p>
</li>
<li>
<p>As we mentioned in section 1.2.5, DisCoPy uses a point-free, tacit programming style which can get very verbose as soon as diagrams have more than a few boxes. One of the features in our backlog is implementing an explicit syntax where diagrams are defined as decorated Python functions taking the wires in their domain as argument, applying boxes to them and returning their codomain. We already have a working version of this for planar diagrams, it would be straightforward to extend it to any cartesian diagram where we can swap, copy and discard arguments. What would be less straightforward is to extend it to the syntax of structures beyond cartesian: cocartesian (control flow), closed (higher-order functions) and traced (iteration and recursion). One starting point for this, rather than reinventing the wheel, would be to use JAX [Bra+20] expressions as an intermediate language between pure Python and diagrams.</p>
</li>
</ul>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) <a href="https://github.com/quantomatic/quizx">https://github.com/quantomatic/quizx</a></p>
<!-- Footnote -->
<hr><!-- Meanless: 166 1.6. Summary & future work-->
<ul>
<li>
<p>There are many more ways we can interpret diagrams as code, i.e. many more functors into concrete categories we can implement. One example is probabilistic functions which can be modeled as arrows of Markov categories [Fri+20] where the objects have comonoids but only the counit is natural. DisCoPy has already been interfaced with the probabilistic programming language Pyro [Bin+19] in order to learn both the structure and the parameters of a machine learning model end-to-end [Sen20].</p>
</li>
<li>
<p>Some of these concrete categories will not be strictly associative: \(\left( {x \otimes  y}\right)  \otimes  z\) and \(x \otimes  \left( {y \otimes  z}\right)\) can represent two different ways of storing the same data,and using one versus the other may have an impact on performance. Diagrams for non-strict monoidal categories have been used to give an elementary proof of MacLane's coherence theorem for monoidal categories [WGZ22]. We have also drawn them throughout this thesis when discussing coherence for rigid, braided and hypergraph categories. For now we had to cheat and manually define a new type xy with boxes from \(\mathrm{x}@\mathrm{y}\) to \(\mathrm{{xy}}\) an back,better support for such monoidal coherence is also in the backlog.</p>
</li>
<li>
<p>Categories with a tensor product that is not necessarily associative or unital, sometimes called magmoidal categories, also play a role in linguistics. Indeed, the Lambek calculus in its 1961 version [Lam61] is non-associative and non-unital, which gives a finer control over the grammaticality of trees rather than lists. With skew monoidal categories [UVZ18], one re-introduces the natural transformation for associativity but in only one direction. In another generalisation, Grishin [Gri83] introduced a coproduct and its left and right adjoints as dual to the tensor product. This new binary operation comes with interaction rules for distributing over the tensor, see Moortgat [Moo09] for a modern presentation. Wijnholds [Wij15; Wij17] gave a distributional compositional semantics to this Lambek-Grishin calculus in terms of weakly distributive categories [CS97]. We leave the implementation of categories with multiple non-associative monoidal structures and their potential application to QNLP as a direction for future work.</p>
</li>
<li>
<p>There are many more constructions from category theory that could be implemented in DisCoPy. One example is the Int construction which defines the free compact-closed category generated by a traced symmetric category \(C\) [JSV96,Section 4]. Generalising the way the integers \(\mathbb{Z}\) are constructed as a quotient of pairs of natural numbers,the objects of \(\operatorname{Int}\left( C\right)\) are given by pairs of objects in \(C\) ,the arrows by pairs of arrows going in opposite direction and their composition by the trace. The Int construction allows to reason about bidirectional processes such as optics in functional programming [LR19]. It is also related to the notion of combs or open diagrams [Rom20a] which have been used to reason about processes with feedback \(\left\lbrack  {\mathrm{{Rom}}{20}\mathrm{\;b}}\right\rbrack\) as well as causal quantum processes [KU19]. Other examples include open learners [FJ19] and open games [Hed17; Hed19] which formalise machine learning and game theory in terms of monoidal categories with some notion of bidirectionality.</p>
</li>
</ul><h2></h2>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_168.jpg?x=1287&#x26;y=691&#x26;w=169&#x26;h=211&#x26;r=0">
<!-- Media -->
<p>Quantum natural language processing</p>
<p>This chapter introduces quantum natural language processing (QNLP) models as monoidal functors from grammar to quantum circuits. Building on the previous chapter, we show how to implement QNLP models in DisCoPy and how to train them to solve NLP tasks such as classification and question answering.</p>
<h3>2.1 Formal grammars and quantum complexity</h3>
<p>The previous chapter has put much emphasis on string diagrams and its role at the intersection of mathematics and computer science. From the programming perspective, diagrams are a two-dimensional generalisation of lists which may describe the run of a Turing machine, the syntax of a first-order logic formula or the architecture of a neural network. In fact, we will see that string diagrams also play a key role in linguistics, where they allow to encode the grammatical structure of sentences. First, section 2.1.1 reviews formal grammars, the notion of ambiguity and the computational complexity of parsing. Then we discuss categorial grammars, from the Lambek calculus and Montague semantics to pregroup grammars and DisCoCat models. Finally, we summarise previous work on the Frobenius anatomy of anaphora and investigate the quantum complexity of DisCoCat models.</p>
<!-- Meanless: 169--><!-- Meanless: 170 2.1. Formal grammars and quantum complexity-->
<h4>2.1.1 Formal grammars, parsing and ambiguity</h4>
<p>The word "grammar" comes from the ancient Greek " \({\gamma \rho }\dot{\alpha }{\mu \mu \alpha }\) " (line of writing), it is cognate to the words "glamour" and "grimoire" [RT05; Dav10; Lam14]. The practice of grammar itself goes back to India somewhere between the 6th and 4th century BCE [BK93], where the Sanskrit philologist Pānini introduced what was later recognised as context-sensitive grammars. More than two thousand years later, Chomsky [Cho56; Cho57] gave grammars their modern definition. A formal grammar,also called unrestricted or type-0 grammar,is a tuple \(G = \left( {V,X,R,s}\right)\) where:</p>
<ul>
<li>
<p>\(V\) and \(X\) are finite sets called terminal and non-terminal symbols respectively, we will also call them the vocabulary and the basic types,</p>
</li>
<li>
<p>\(R\) is a finite set of production rules \(x \rightarrow  y\) where \(x,y \in  {\left( V + X\right) }^{ \star  }\) ,</p>
</li>
<li>
<p>\(s \in  X\) is called the start symbol or the sentence type.</p>
</li>
</ul>
<p>A string of words \(w = {w}_{1}\ldots {w}_{n} \in  {V}^{ \star  }\) is a grammatical sentence whenever \({}^{1}w{ \leq  }_{R}s\) for \(\left( { \leq  }_{R}\right)\) the reflexive transitive closure of the rewriting relation as defined in section 1.1.2. Thus,the grammar \(G\) generates a language \(L\left( G\right)  \subseteq  {V}^{ \star  }\) ,the set of all grammatical sentences. Although formal grammars are called unrestricted, the right-hand side of the rules in \(R\) is usually restricted to be non-empty. This makes no difference as to the classes of languages that can be generated, i.e. for every grammar with empty right-hand sides there is a grammar without that generates the same language.</p>
<p>Equivalently,a formal grammar is a finite monoidal signature \(G\) with an injection from the words in the vocabulary and the sentence type into the generating objects \(V + \{ s\}  \hookrightarrow  {G}_{0}\) . Indeed,we can define the non-terminal symbols as \(X = {G}_{0} - V\) then a rewrite rule is nothing but a box with lists of symbols as domain and codomain. The language of \(G\) may then be defined as \(L\left( G\right)  = \left\{  {w \in  {V}^{ \star  }\mid \exists f : w \rightarrow  s \in  \mathbf{G}}\right\}\) for \(\mathbf{G}\) the free monoidal category generated by \(G\) ,a diagram \(f : w \rightarrow  s\) to the sentence type \(s\) is proof that the string of words \(w\) is grammatical. We call the diagram \(f : w \rightarrow  s\) a grammatical structure for the sentence \(w\) ,we say a sentence is ambiguous whenever it has more than one grammatical structure. The parsing problem is to decide,given a grammar \(G\) and a string \(w \in  {V}^{ \star  }\) ,whether \(w \in  L\left( G\right)\) . It is easily shown to be equivalent to the word problem for monoids and the halting problem for Turing machines, thus it is undecidable. Moreover, there exists a universal grammar \(G\) such that the parsing problem with \(G\) fixed and only the string \(w \in  {V}^{ \star  }\) as input is undecidable. That is,for any other grammar \({G}^{\prime }\) and string \(w \in  V{\left( {G}^{\prime }\right) }^{ \star  }\) we can compute some other string \({w}^{\prime } \in  V{\left( G\right) }^{ \star  }\) such that \(w \in  L\left( {G}^{\prime }\right)\) if and only if \({w}^{\prime } \in  L\left( G\right)\) .</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Formal grammars are usually defined in the other direction,i.e. \(w \in  L\left( G\right)\) iff \(s{ \leq  }_{R}w\) . We choose the opposite convention so that we won't have to switch in the next section.</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 171-->
<p>If we are to build a parser, i.e. a machine that computes the grammatical structure of a given string, type-0 grammars are too general: their parsing problem is undecidable. Going one level up in Chomsky's hierarchy, a context-sensitive grammar (CSG,also called a type-1 grammar) is a formal grammar \(G\) where the rules have the form \({abc} \rightarrow  {axc}\) for a non-terminal symbol \(x \in  X\) and lists of symbols \(a,b,c \in  {G}_{0}^{ \star  }\) where \(\operatorname{len}\left( b\right)  \geq  {1}^{1}\) . The parsing problem for CSG was the first to be shown complete for the class NPSPACE of problems solvable in non-deterministic polynomial space [Kur64]. Savitch [Sav70] then proved NPSPACE = PSPACE, hence that parsing CSG is in fact complete for deterministic polynomial space. Another PSPACE-complete problem is the parsing problem for non-contracting grammars, where we have that \(\operatorname{len}\left( y\right)  \leq  \operatorname{len}\left( x\right)\) for every rule \(x \rightarrow  y\) . Indeed,every CSG is also non-contracting and for every non-contracting grammar \(G\) ,there is a CSG \({G}^{\prime }\) with \(L\left( G\right)  = L\left( {G}^{\prime }\right)\) [Cho63,Theorem 11].</p>
<p>Two grammars \(G\) and \({G}^{\prime }\) over the same vocabulary \(V\) are weakly equivalent whenever they generate the same language,i.e. \(L\left( G\right)  = L\left( {G}^{\prime }\right)  \subseteq  {V}^{ \star  }\) . For example, every non-contracting grammar is weakly-equivalent to a CSG. A strong equivalence preserves not only the generated languages but also the grammatical structure, i.e. it defines a bijection \({}^{2}\mathbf{G}\left( {w,s}\right)  \simeq  {\mathbf{G}}^{\prime }\left( {f\left( w\right) ,s}\right)\) for all strings \(w \in  {V}^{ \star  }\) . For example,every CSG is strongly equivalent to a non-contracting grammar (itself) in a trivial way.</p>
<p>For a less trivial example,every formal grammar \(G\) is strongly equivalent to a lexicalised one,where the rules are a union \(R = D \cup  {R}^{\prime }\) of dictionary entries \(D \subseteq  V \times  X\) assigning possible types to each word and production rules \({R}^{\prime } \subseteq  {X}^{ \star  } \times  {X}^{ \star  }\) not involving the vocabulary. Indeed,given a grammar \(G\) we can add a new basic type \({w}^{\prime }\) and a dictionary entry \(w \rightarrow  {w}^{\prime }\) for each word \(w \in  V\) to get a lexicalised grammar \({G}^{\prime }\) . Every grammatical structure \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) in \({\mathbf{G}}^{\prime }\) factorises as \(f = d\) , \({f}^{\prime }\) for a tensor of dictionary entries \(d : {w}_{1}\ldots {w}_{n} \rightarrow  {w}_{1}^{\prime }\ldots {w}_{n}^{\prime }\) and a diagram \({f}^{\prime } : {w}_{1}^{\prime }\ldots {w}_{n}^{\prime } \rightarrow  s\) with no dictionary entries,which is isomorphic to a grammatical structure in \(\mathbf{G}\) . Once the grammar is lexicalised,we usually draw dictionary entries as boxes labeled by the corresponding word and we omit the wires for terminal symbols. We also assume that any semantic functor \(F : \mathbf{G} \rightarrow  C\) from a lexicalised grammar \(\mathbf{G}\) to some concrete category \(C\) maps dictionary entries to states,i.e. \(F\left( w\right)  = 1\) for all words \(w \in  V\) ,which implies that the interpretation of any grammatical structure is a also state \(F\left( f\right)  : 1 \rightarrow  F\left( s\right)\) .</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) If we care about whether a language contains the empty string 1 or not,we also have to allow for the rule \(s \rightarrow  1\) .</p>
<p>\({}^{2}\) Chomsky [Cho63] defines two grammars to be strongly equivalent when they generate "the same set of structural descriptions" but he doesn't define sameness of structural descriptions. Our definition only asserts that the two grammars assign the same number of grammatical structures to any string, not that these structures are isomorphic themselves. Asking for an equivalence of monoidal categories \(\mathbf{G} \simeq  {\mathbf{G}}^{\prime }\) would be too strong: when two free categories are equivalent,they are automatically isomorphic.</p>
<!-- Footnote -->
<hr><!-- Meanless: 172 2.1. Formal grammars and quantum complexity-->
<p>Unless \(\mathrm{P} = \mathrm{{NP}} = \mathrm{{PSPACE}}\) ,there can be no efficient parser for context-sensitive grammars in general. This motivates the introduction of context-free grammars (CFGs, also called type-2 grammars) where the right-hand side of each rule has length one. We can assume that the grammar is lexicalised, so that the rules have the form either \(w \rightarrow  x\) or \({y}_{1}\ldots {y}_{n} \rightarrow  x\) for a basic type \(x \in  X\) ,a word \(w \in  V\) and a list of basic types \({y}_{1}\ldots {y}_{n} \in  {X}^{ \star  }\) . In this case,grammatical structures \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) have the shape of a syntax tree with the words \({w}_{1}\ldots {w}_{n}\) as leaves and the sentence type \(s\) as root. The interchanger normal form of a syntax tree is called its left-most derivation, when two rules apply in parallel the left-most is always applied first. A CFG is in Chomsky normal form \(\left( {\mathrm{{CNF}}}^{1}\right)\) when it is lexicalised and the rules are of the form either \(s \rightarrow  1\) or \({xy} \rightarrow  z\) for \(x,y \in  X - \{ s\}\) qnd \(z \in  X\) ,i.e. where all the syntax trees are binary and the sentence type appears only at the root. Every context-free grammar \(\mathbf{G}\) can be converted to some weakly equivalent \({\mathbf{G}}^{\prime }\) in CNF, with at most a quadratic blow-up in size. There is a monoidal functor \(\mathbf{G} \rightarrow  {\mathbf{G}}^{\prime }\) mapping every \(n\) -ary rule to a tree of \(n - 1\) binary rules when \(n \geq  2\) and to the identity when \(n &#x3C; 2\) . This means that nullable types,i.e. from which we can derive the empty string, are all sent to the monoidal unit. Thus in the presence of unary and nullary rules, the functor cannot be faithful and the equivalence cannot be strong.</p>
<p>The CYK (Cocke-Younger-Kasami) algorithm solves the parsing problem for CNF in cubic time using dynamic programming. Valiant [Val75] then reduced the problem to Boolean matrix multiplication,yielding a solution in time \(O\left( {n}^{{\log }_{2}7}\right)\) via Strassen's algorithm. Today, the fastest algorithm known for matrix multiplication, hence for parsing context-free grammars, is the galactic algorithm by Alman and Williams [AW21]. Parsing context-free grammars is in fact complete for P, the class of problems solvable in deterministic polynomial time [JL74]. Hence, whatever grammatical framework we may come up with, if its parsing problem is solvable in polynomial time then there exists a logarithmic-space reduction to CFG parsing: it takes a grammar and a string, returns a CFG and a new string such that the input is grammatical if and only if the output is. Crucially, the output CFG depends not only on the input grammar but also on the input string: P-completeness does not imply that there exists one fixed CFG that generates the same language. This opens the door to grammars that are more expressive than context-free but still efficiently-parsable.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) CNF is not a normal form in the sense that it computes representatives of equivalence classes, a given grammar may have many non-isomorphic CNFs. In fact, deciding whether two CFGs are weakly equivalent is undecidable [Cho63, Theorem 26].</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 173-->
<p>Indeed, there is evidence for some degree context-sensitivity in natural language [Huy84; Shi85]. The most studied examples are the cross-serial dependencies of Dutch and Swiss German, which have been abstracted as the formal language \(\left\{  {{w}^{k} \mid  w \in  {V}^{ \star  },k \leq  n}\right\}\) for some (low) constant threshold \(k \leq  n\) . Thus,several mildly context-sensitive grammar (MCSG) formalisms have been introduced, which generate all of the context-free languages as well as cross-serial dependencies, yet are still parsable in polynomial time. All MCSGs proposed so far have fallen into one of three classes of weak equivalence [Wei88]. Thus, there is reasonable consensus over the kind of computational power required to parse human language, at least up to weak equivalence, see Kallmeyer [Kal10] for a standard survey. However, there is no consensus yet on the syntactic way this computational power should be expressed: apart from some isolated results [SM21], there is no classification of MCSGs up to strong equivalence.</p>
<p>Whether two grammars are strongly equivalent matters when we want to define their semantics, i.e. we want to compute the interpretation of a sentence given its grammatical structure. Indeed, weakly equivalent grammars may assign different sets of possible parsing to the same ambiguous sentence, which will correspond to different interpretations. For example, we can apply a monoidal functor from a CFG to a category of neural networks, which yields a recursive neural network that computes the meaning of a sentence given its parse tree [Soc+11; Soc+13]. Different trees will result in different network architectures, so how do we know we have picked the right one? We can use a probabilistic grammar [Sal69] to compute the most likely grammatical structure given some training data, in some cases with theoretical guarantees that this is indeed learnable efficiently [Cla+06; SY16].</p>
<p>DisCoPy implements formal grammars with Parsing, a subclass of Diagram with Word and Production as boxes. It does not implement any parsing algorithm, however it is straightforward to encode the output of an existing parser e.g. that of NLTK [LB02] into a Parsing diagram so that we can compute the semantics of sentences by applying a Functor.</p>
<p>Listing 2.1.1. Implementation of the grammar module and its interface with NLTK.</p>
<hr>
<!-- Footnote -->
<p>class Parsing(monoidal.Diagram):</p>
<p>@staticmethod</p>
<!-- Footnote -->
<hr><!-- Meanless: 174 2.1. Formal grammars and quantum complexity-->
<!-- Media -->
<hr>
<pre><code>def fromtree(tree: nltk.Tree) -> Parsing:
	if len (tree) == 1 and isinstance(tree[0], str):
		return Word ( tree [0] , Ty ( tree .label (   )))
	subtrees = Parsing.tensor(*[Parsing.fromtree(t) for t in tree])
	return subtrees >> Production(dom=subtrees.cod, cod=Ty(tree.label(   )))
</code></pre>
<p>class Word (monoidal.Box, Parsing):
def <strong>init</strong>(self, name: str, cod: Ty, dom=Ty(   )):
monoidal.Box.<em>init</em>(self, name, dom, cod)
class Production (monoidal.Box, Parsing) :
def <strong>init</strong>(self, dom: Ty, cod: Ty):
name = "Production({}, {})".format(dom, cod)
monoidal.Box.<em>init</em>(self, name, dom, cod)
Word.cast = Production.cast = Parsing.cast</p>
<hr>
<!-- Media -->
<p>Example 2.1.2. We use the recursive descent parser from NLTK to parse an ambiguous expression and draw its possible parsings.</p>
<p>from nltk import CFG, BottomUpChartParser as Parser</p>
<hr>
<pre><code>grammar = """
\( \mathrm{n} \rightarrow  \mathrm{a}\mathrm{n} \)
</code></pre>
<p>\(\mathrm{n} \rightarrow  \mathrm{n}\mathrm{n}\)
a -> 'black'
a -> 'metal'
n -> 'metal'
n -> 'fan'
"""</p>
<hr>
<p>parser = Parser (CFG. fromstring (grammar)). parse</p>
<p>for tree in parser("black metal fan".split(   )): Parsing.fromtree(tree).draw(   )</p>
<!-- Media -->
<!-- figureText: black metal fan black metal fan black metal fan \( n \) \( a \) \( n \) \( n \) \( n \) \( n \) \( n \) \( a \) \( n \) \( n \) \( a \) \( n \) \( n \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_173.jpg?x=193&#x26;y=1703&#x26;w=1177&#x26;h=284&#x26;r=0">
<!-- Media -->
<p>If we fed these syntax trees as input to the recursive neural network of Socher et al. [Soc+11] (which was trained to generate images from text descriptions) we would expect to get the following images as output:</p><!-- Meanless: 2. Quantum natural language processing 175-->
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_174.jpg?x=338&#x26;y=287&#x26;w=1116&#x26;h=311&#x26;r=0">
<!-- Media -->
<p>In the framework of context-free grammars, ambiguity arises in at least two ways: 1) we have to choose from the many weakly equivalent grammars that generate the same language, 2) once the grammar is fixed we have to choose from the many syntax trees that generate the same sentence. The second type of ambiguity cannot be alleviated: Parikh [Par61; Par64] defined a context-free language that is inherently ambiguous in the sense that no unambiguous grammar can generate it [Cho63, Theorem 29]. In the same paper, Parikh unravels a deep connection between the theory of context-free grammars and that of free rigs: CFGs \(G\) with symbols \({G}_{0}\) are in one to one corresondance with endomorphisms of the free rig \({f}_{G} : \mathbb{N}\left\lbrack  {G}_{0}\right\rbrack   \rightarrow  \mathbb{N}\left\lbrack  {G}_{0}\right\rbrack\) which fix the vocabulary,i.e. \({f}_{G}\left( w\right)  = w\) for all words \(w \in  V\) [Par66,Section 3]. Indeed,the free rig \(\mathbb{N}\left\lbrack  X\right\rbrack\) generated by a set \(X\) has underlying set \({\mathbb{N}}^{{X}^{ \star  }}\) ,it can be thought of as the set of languages with multiplicities. Iterating the endomorphism \(n\) times then projecting on the vocabulary with \({\pi }_{V} : \mathbb{N}\left\lbrack  {G}_{0}\right\rbrack   \rightarrow  \mathbb{N}\left\lbrack  V\right\rbrack\) ,the formal sum \({\pi }_{V}\left( {{f}_{G}^{n}\left( s\right) }\right)  \in  \mathbb{N}\left\lbrack  {G}_{0}\right\rbrack\) has a term for each grammatical sentence that can be generated by a syntax tree of depth \(n\) and the coefficients given by the ambiguity of the sentence, i.e. the number of different syntax trees [MK97]. Thus we can define the language of a CFG as \(L\left( G\right)  = { \cup  }_{n \in  \mathbb{N}}\operatorname{sign}\left( {{\pi }_{V}\left( {{f}_{G}^{n}\left( s\right) }\right) }\right)\) for \(\operatorname{sign} : \mathbb{N}\left\lbrack  V\right\rbrack   \rightarrow  \mathbb{B}\left\lbrack  V\right\rbrack   \simeq  {\mathbb{B}}^{{V}^{ \star  }}\) the quotient map induced by \(1 + 1 = 1\) ,i.e. forgetting multiplicities.</p>
<p>Parikh [Par66,Theorem 2] states that if we define the map \(p : {V}^{ \star  } \rightarrow  {\mathbb{N}}^{V}\) which sends lists to bags by forgetting word order,then the direct image \(p\left( {L\left( G\right) }\right)  \subseteq  {\mathbb{N}}^{V}\) is indistinguishable from that of a regular grammar. Regular grammars (also called type-3) have rules of the form either \(x \rightarrow  1\) or \(x \rightarrow  {wy}\) for non-terminals \(x,y \in  X\) and word \(w \in  V\) ,they are the least expressive level in Chomsky’s hierarchy. The subsets \(p\left( {L\left( G\right) }\right)  \subseteq  {\mathbb{N}}^{V}\) generated by CFGs (or equivalently by regular grammars) are called semilinear,they are finite unions of affine subspaces \({}^{1}\) . Semilinearity is sometimes required as an extra condition for a grammar to be considered mildly context-sensitive, although there is evidence that some natural languages like Old Georgian are not semilinear [MK97]. Regular grammars can be be equivalently defined as regular expressions: elements of the free \(K\) leene algebra \(K\left( V\right)\) ,the free idempotent rig with a closure \({}^{1}{\left( -\right) }^{ \star  } : K\left( V\right)  \rightarrow  K\left( V\right)\) . Equality of regular expressions is decidable, hence so is the weak equivalence of regular grammars. Moreover, every regular language can be generated unambiguously. Thus, Parikh's theorem tells us intuitively that the hardness of natural language comes from its non-commutativity: if we forget about word order then everything is decidable and ambiguity disappears. From our applied category theory perspective, this also means that language cannot be fully \({}^{2}\) investigated in symmetric categories,we need a planar monoidal data structure such as DisCoPy's Diagram.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A subspace of \({\mathbb{N}}^{V}\) is affine if it has the form \(\left\{  {{u}_{0} + {t}_{1}{u}_{1} + \cdots  + {t}_{n}{u}_{n} \mid  {t}_{1},\ldots ,{t}_{n} \in  \mathbb{N}}\right\}\) for some \({u}_{0},\ldots {u}_{n} \in  {\mathbb{N}}^{V}\) . Confusingly,affine subspaces are called "linear" in the literature,hence "semilinear".</p>
<!-- Footnote -->
<hr><!-- Meanless: 176 2.1. Formal grammars and quantum complexity-->
<h4>2.1.2 From the Lambek calculus to DisCoCat models</h4>
<p>Even if we cannot get rid of the inherent ambiguity of natural language, we can still try to reduce the artificial ambiguity of our grammar formalism, i.e. the number of weakly equivalent grammars that generate the same language.</p>
<p>The categorial grammar tradition may be summed up in a slogan: all the grammar is in the dictionary [Pre07b]. Indeed, there is no need for language-specific production rules if the types of our grammar have enough structure, if we go from monoidal to closed categories. In the Lambek calculus [Lam58] \({}^{3}\) ,a categorial grammar is defined as a tuple \(G = \left( {V,X,D,s}\right)\) where:</p>
<ul>
<li>
<p>\(V\) and \(X\) are finite sets called the vocabulary and the basic types with \(s \in  X\) the sentence type,</p>
</li>
<li>
<p>\(D \subseteq  V \times  T\left( X\right)\) is a finite set of dictionary entries with \(T\left( X\right)  \supseteq  X\) the set of formal expressions with \(1,\left( {x \otimes  y}\right) ,\left( {x/y}\right) ,\left( {x \smallsetminus  y}\right)  \in  T\left( X\right)\) for all \(x,y \in  T\left( X\right)\) .</p>
</li>
</ul>
<p>Equivalently,the Lambek grammar \(G\) may be seen as a closed monoidal signature (as defined in section 1.4.6) with dictionary entries as boxes where the domain is a single word. In a basic categorial grammar, also called an AB grammar after Ajdukiewicz [Ajd35] and Bar-Hillel [Bar54], the dictionary is restricted to a closed signature, i.e. types are generated without the tensor product and unit. The language of a categorial grammar \(G\) is given by \(L\left( G\right)  = \left\{  {w \in  {V}^{ \star  }\mid \exists f : w \rightarrow  s \in  \mathbf{G}}\right\}\) for \(\mathbf{G}\) the free closed category generated by the dictionary.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A closure is an idempotent monad on a preorder,here given by \(a \leq  b\) iff \(\exists c \cdot  a + c = b\) .</p>
<p>\({}^{2}\) That is,faithful functors from non-regular CFGs to symmetric categories cannot be full.</p>
<p>\({}^{3}\) The original calculus did not include a unit for the tensor product,here we follow the presentation given by Lambek [Lam88] thirty years later. We only consider string languages, as opposed to the tree languages generated by the non-associative Lambek calculus of 1961 [Lam61].</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 177-->
<p>More explicitly,a grammatical structure \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) is given by a tensor of dictionary entries \(\left( {{w}_{i},{t}_{i}}\right)  \in  D\) followed by a closed diagram \({t}_{1}\ldots {t}_{n} \rightarrow  s\) composed only of evaluation and currying. Traditionally, these closed diagrams have been defined in terms of a sequent calculus à la Gentzen, see Lambek [Lam88] for a translation between the two definitions. If we uncurry the identity on exponential types \(x/y\) and \(y \smallsetminus  x\) then curry them back the other way,we get the type raising rules \(x \rightarrow  y/\left( {x \smallsetminus  y}\right)\) and \(x \rightarrow  \left( {y/x}\right)  \smallsetminus  y\) which are analogous to the continuation-passing style in functional programming [De 01]. Although it does not affect the expressive power of the Lambek calculus, type raising allows incremental parsing where sequences of words are processed strictly from left to right [Dow88; Ste91], a feature which is well-motivated from a cognitive perspective. In previous work, Shiebler, Sadrzadeh and the present author [STS20] investigate incrementality in terms of a functor from grammars to automata.</p>
<!-- Media -->
<p>Listing 2.1.3. Implementation of categorial grammars as closed categories.</p>
<hr>
<p>class Parsing(closed.Diagram, grammar.Parsing):
def type_raise(x: closed.Ty, y: closed.Ty, left=True) -> Parsing:
return Parsing.id(x >> y).uncurry(   ).curry(left=False) if left\\
else Parsing.id(y &#x3C;&#x3C; x).uncurry(left=False).curry(   )
class Ev (closed.Ev, Parsing): pass
class Word (grammar. Word, Parsing): pass
Ev. cast = Word.cast = Parsing.cast</p>
<hr>
<!-- Media -->
<p>Example 2.1.4. We can take \(X = \{ s,n,{np}\}\) and assign common noun the type \(n\) , determiners \(\left( {{np}/n}\right)\) and transitive verbs \(\left( {\left( {{np} \smallsetminus  s}\right) /{np}}\right)\) .</p>
<!-- Media -->
<hr>
<p>n, np, s = map(closed.Ty, ('n', 'np', 's'))
man, island = (Word(noun, n) for noun in ("man", "island"))
no, an = (Word(determinant, np &#x3C;&#x3C; n) for determinant in ("no", "an"))
_is = Word("is", (np >> s) &#x3C;&#x3C; np)
no_man_is_an_island = no @ man @_is @ an @ island\
>> Ev(np &#x3C;&#x3C; n) @ ((np >> s) &#x3C;&#x3C; np) @ Ev(np &#x3C;&#x3C; n)\
>> Parsing.type_raise(np, s) @Ev((np >> s) &#x3C;&#x3C; np)\
\(\mathrel{\text{>>}} \mathrm{{Ev}}\left( {\mathrm{s} &#x3C;  &#x3C; \left( {\mathrm{{np}} >  > \mathrm{s}}\right) }\right)\)
no_man_is_an_island.draw(   )</p>
<hr><!-- Meanless: 178 2.1. Formal grammars and quantum complexity-->
<!-- figureText: no man is an island \( n{p}^{l} \) \( {np} \) \( {n}^{l} \) \( {np} \) \( {n}^{l} \) \( n \) \( n{p}^{r} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_177.jpg?x=406&#x26;y=283&#x26;w=746&#x26;h=745&#x26;r=0">
<!-- Media -->
<p>Bar-Hillel et al. [Bar+60] showed that basic categorial grammars are strongly equivalent to context-free grammars in Greibach normal form [Gre65], where every production has the form \(x \rightarrow  {wy}\) for a non-terminal \(x \in  X\) ,a word \(w \in  V\) and a string of non-terminals \(y \in  {X}^{ \star  }\) . Thus,their parsing problem can be solved in polynomial time. Pentus [Pen93] then showed that Lambek grammars are weakly equivalent to CFGs as well, although their parsing problem is NP-complete [Pen06]. This means that unless \(\mathrm{P} = \mathrm{{NP}}\) there are Lambek grammars for which the smallest weakly equivalent CFG will have exponential size. Many extensions of the Lambek calculus have been introduced to go beyond its context-free limitation and give a more fine-grained description of syntactic phenomena, see Moortgat [Moo14] for a survey. Additional unary operators called modalities allow to break away from the planarity and linearity of closed diagrams, introducing rules for swaps and comonoids in a controlled way to model phenomena such as parasitic gaps, ellipsis and anaphora. See Moortgat [Moo97, p. 4.2] for a survey of modalities in linguistics and McPheat et al. [McP+21] where the author and collaborators introduce a diagrammatic syntax and functorial semantics for such modalities. The combinatory categorial grammars (CCGs) of Steedman [Ste87; Ste00] take a different approach inspired by the combinatory logic of Schönfinkel [Sch24] and Curry [Cur30], a variable-free predecessor to the lambda-calculus. In particular, CCGs include crossed composition rules which make them mildly context-sensitive, see Kartsaklis and Yeung [YK21] for their implementation in DisCoPy. Another extension is the abstract categorial grammar (ACG) framework of de Groote [Groote01] defined in terms of a homomorphism from abstract to concrete syntax. This allows to obtain a refinement of the Chomsky hierarchy which characterises mild context-sensitivity in terms of two parameters: the order of the abstract syntax and the complexity of the homomorphism [DP04].</p><!-- Meanless: 2. Quantum natural language processing 179-->
<p>A key feature of categorial grammars as free closed categories, is that we can define their semantics as functors into any closed category: once the image of dictionary entries is defined, the image of any grammatical structure is fixed. Montague [Mon70; Mon74; Mon73] introduced the idea of semantics as a homomorphism from syntax to logic,i.e. as a closed functor \(F : \mathbf{G} \rightarrow  {F}^{CC}\left( \sum \right)\) from a categorial grammar into a free cartesian closed category with logical connectives and predicates as boxes. Although Montague himself did not care much about syntax \({}^{1}\) , his method provides a general recipe to interpret any categorial grammar in terms of lambda expressions. From a computational perspective however, Montague semantics is too expressive: as we mentioned in section 1.4.6, the word problem for free cartesian closed categories, or equivalently the normalisation of simply-typed lambda terms, is not elementary recursive. The Entscheidungsproblem of Hilbert and Ackermann [HA28] is to decide, given a first-order logic formula, whether it is valid (i.e. true in every interpretation). Church [Chu36] proved this is undecidable, thus even if we manage to translate sentences as first-order logic formulae (which could take non-elementary time) checking if a given sentence is valid (or if two sentences are equivalent) is also undecidable. Intuitively, we can reduce Turing's halting problem to the validity of the sentence "the machine halts". The model checking problem is to decide whether a formula is valid in a given finite model, it is PSPACE-complete in the size of the formula [Grã02, Theorem 4.3] and in L (logarithmic space) if the formula is fixed [Grä02, Corollary 4.5].</p>
<p>Example 2.1.5. We can interpret natural language as arbitrary Python code by applying a closed functor \(\mathbf{G} \rightarrow  \mathbf{{Pyth}}\) .</p>
<hr>
<p>\(\mathrm{x},\mathrm{y} = \operatorname{map}\left( {\mathrm{{Ty}},\text{"xy"}}\right)\)
program, runs = Word("program", x), Word("runs", x >> y)
program_runs = program @ runs >> Ev(x >> y)
F = closed.Functor(   )
dom = Category (Ty, Parsing), cod = Category (tuple [type, ...], Function),
ob={x: int, y: int},
ar={program: lambda: 42, runs: lambda: lambda n: n * 10})
assert F(program_runs)(   ) == 420</p>
<hr>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) "I fail to see any great interest in syntax except as a preliminary to semantics." [Mon70]</p>
<!-- Footnote -->
<hr><!-- Meanless: 180 2.1. Formal grammars and quantum complexity-->
<p>Example 2.1.6. We can implement Montague semantics as a closed functor \(\mathbf{G} \rightarrow\) Pyth which sends the sentence type to Formula,the implementation of diagrammatic first-order logic à la Peirce given in example 1.2.37. Montague [Mon73] defines common nouns and intransitive verb phrases as functions from terms to formulae, in diagrammatic logic the same role is played by states and effects, i.e. open formulae with one open wire \(\mathrm{x}\) in the codomain and domain respectively. Montague's noun phrases are functions from intransitive verb phrase to sentence, in our setting they are given by functions from open to closed formulae. The transitive verb "is" must take two such functions \(\mathrm{P}\) and \(\mathrm{Q}\) as input and return a closed formula, the only thing we can do is apply \(\mathrm{P}\) to the identity diagram on \(\mathrm{x}\) to get a state,before feeding the dagger of the result to \(\mathbb{Q}\) .</p>
<!-- Media -->
<p>\(\mathrm{x} = \mathrm{{Ty}}\left( {1{\mathrm{x}}^{\prime }}\right)\)</p>
<hr>
<p>Montague = closed.Functor(   )
dom = Category (Ty, Parsing), cod = Category (tuple [type, ...], Function),
ob={s: Formula, n: Formula, np: exp(Formula, Formula)},
ar={no: lambda: lambda state: lambda effect: (state >> effect).bubble(   ),
man: lambda: Predicate("man", x),
_is: lambda: lambda P: lambda Q: Q(P(Formula.id(x)).dagger(   )),
an: lambda: lambda state: lambda effect: state >> effect,
island: lambda: Predicate("island", x)})
Montague(no_man_is_an_island)(   ).draw(   )</p>
<hr>
<!-- figureText: man island -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_179.jpg?x=692&#x26;y=1463&#x26;w=179&#x26;h=260&#x26;r=0">
<!-- Media -->
<p>size = \(\{ \mathrm{x} : 2\}\)</p>
<hr>
<p>for mans,islands in itertools.product \(( * 2 * \lbrack\)
itertools.product(*size[x] * [[0, 1]])]):
F = model(size, {Predicate("man", x): mans, Predicate("island", x): islands})
assert F (Montague (no_man_is_an_island) (   )) == not any (   )
F(Predicate("man", x))[i] and F(Predicate("island", x))[i]
for i in range ( size [x] ) )</p>
<hr><!-- Meanless: 2. Quantum natural language processing 181-->
<p>Returning to linguistics half a century after his seminal Mathematics of sentence structure, Lambek [Lam99b; Lam01; Lam08] introduced pregroup grammars as a simplification of his original calculus replacing closed categories by rigid categories. That is,the dictionary of a pregroup grammar \(G = \left( {V,X,D,s}\right)\) has the shape \(D \subseteq  V \times  {\left( X \times  \mathbb{Z}\right) }^{ \star  }\) ,it assigns words to lists of iterated adjoints of basic types. Again,the language of \(G\) is defined as \(L\left( G\right)  = \left\{  {w \in  {V}^{ \star  }\mid \exists f : w \rightarrow  s \in  \mathbf{G}}\right\}\) where now \(\mathbf{G}\) is the free rigid category generated by the dictionary. Equivalently,a sentence \(w = {w}_{1}\ldots {w}_{n} \in  {V}^{ \star  }\) is grammatical if there are dictionary entries \(\left( {{w}_{i},{t}_{i}}\right)  \in  D\) such that \({t}_{1}\ldots {t}_{n} \leq  s\) holds in the free pregroup,i.e. the preorder collapse of \(\mathbf{G}\) . In fact, Lambek first defined his pregroup grammars in terms of partial orders (i.e. preorders with antisymmetry) then Preller and he [PL07] reformulated them in terms of free compact 2-categories (i.e. rigid categories with colours) so that they could account for ambiguity. Moving from preorders to free categories also allows to define pregroup semantics as functors, indeed a functor with a preorder as domain is required to map all the parsings of an ambiguous sentence to the same meaning. Even worse, a monoidal functor with a pregroup as domain has to obey the equation \(F\left( x\right)  = F\left( {x \otimes  {x}^{l} \otimes  x}\right)\) for all types \(x \in  X\) ,which makes the functor trivial in categories of interest such as \(\mathbf{{Set}}\) or \({\mathbf{{Mat}}}_{\mathbb{S}}\) .</p>
<p>Every rigid category is also closed,thus for any Lambek grammar \(G\) we can construct a pregroup grammar \({G}^{\prime }\) and a closed functor \(\mathbf{G} \rightarrow  {\mathbf{G}}^{\prime }\) which sends categorial types \(x \smallsetminus  y\) and \(x/y\) to pregroup types \({x}^{r}y\) and \(x{y}^{l}\) . In general this functor need not be faithful: it maps both \(\left( {x \otimes  y}\right) /z\) and \(x \otimes  \left( {y/z}\right)\) to the same pregroup type \({xy}{z}^{l}\) . Although they cannot be strongly equivalent to Lambek grammars, Buszkowski [Bus01] proved that pregroup grammars are context-free, hence they are still weakly-equivalent. As for the complexity of their parsing problem, Lambek [Lam99b] first showed it was decidable with the following switching lemma: any pregroup inequality \(x \leq  z\) can be factored into \(x \leq  y \leq  z\) where \(x \leq  y\) using only cups then \(y \leq  z\) using only caps. The proof is essentially given by the snake removal algorithm of listing 1.4.8 applied to rigid diagrams with only cups and caps: the resulting normal form can be shown to have all cups preceding the caps. As a corollary,if there is a grammatical structure \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) then there is one using only dictionary entries and cups which we can find by brute force search, Oehrle [Oeh04] showed that pregroup parsing can in fact be solved in cubic time. Preller [Pre07a] gave sufficient conditions on the dictionary for unambiguous pregroup grammars to be parsed in linear time, the algorithm was later improved and implemented in DisCoPy by Rizzo [Riz21]. Multiple extensions of pregroup grammars have been proposed to go beyond context-free languages including taking products of free pregroups [Lam08, Section 28], grammars with infinite dictionaries [Pre10] or a notion of buffer [GFK10].</p><!-- Meanless: 182 2.1. Formal grammars and quantum complexity-->
<p>One can define the semantics of a pregroup grammar \(G\) as a monoidal functor \(F : \mathbf{G} \rightarrow  C\) into any rigid category \(C\) ,in the categorical compositional distributional (DisCoCat) models of Clark, Coecke and Sadrzadeh [CCS08; CCS10] one takes \(C = {\mathbf{{Mat}}}_{\mathbb{S}}\) the category of matrices. More explicitly,a DisCoCat model \(F : \mathbf{G} \rightarrow\) \({\mathbf{{Mat}}}_{\mathbb{S}}\) is defined by a dimension \(F\left( x\right)  \in  \mathbb{N}\) for every basic type \(x \in  X\) and a vector \(F\left( {w,t}\right)  : 1 \rightarrow  F\left( t\right)\) for every dictionary entry \(\left( {w,t}\right)  \in  D\) . It then defines the semantics of a grammatical sentence \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) as the contraction of a tensor network where the nodes are dictionary entries and the edges are given by the cups. Note that the two seminal articles [CCS08; CCS10] do not mention rigid categories and stick with the definition of pregroup grammars in terms of partial orders. Unable to define non-trivial functors \(P \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) for \(P\) the free pregroup generated by \(G\) ,i.e. the preorder collapse of \(\mathbf{G}\) ,they resort to defining DisCoCat in terms of a product category \({\mathbf{{Mat}}}_{\mathbb{S}} \times  P\) . Although they do not say it explicitly,they in fact worked with a subcategory of \(\mathbf{G} \times  {\mathbf{{Mat}}}_{\mathbb{S}}\) called the Grothendieck construction on a monoidal functor \(F : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) ,see Bradley et al. \(\left\lbrack  {\mathrm{{Bra}} + {18}}\right\rbrack\) for an application of this observation to model translation and language evolution in DisCoCat.</p>
<p>DisCoCat models came out of a quest to accommodate the compositional approach to NLP which focused on grammatical structure and the distributional approach that represented words as vectors extracted from text data. A key feature of this approach compared to its predecessor is that DisCoCat models define a similarity measure between any two expressions of the same type, even though they do not have the same grammatical structure. Indeed, any two pregroup diagrams \(f,g : {w}_{1}\ldots {w}_{n} \rightarrow  x\) will be mapped to vectors of dimension \(n = F\left( x\right)\) such that the inner product \(\langle F\left( f\right)  \mid  F\left( g\right) \rangle\) yields a measure of their similarity. We can then use standard machine learning techniques to solve problems such as classification, an approach that has received some empirical support on small-scale datasets [GS11]. The name of DisCoPy stands for Distributional Compositional Python, indeed it was first meant as an implementation of DisCoCat models before it turned into an implementation of monoidal functors in general.</p>
<!-- Media -->
<p>Listing 2.1.7. Implementation of pregroup grammars as rigid categories.</p>
<hr>
<p>class Parsing(rigid.Diagram, categorial.Parsing): pass
class Cup (rigid. Cup, Parsing): pass
class Word (categorial.Word, Parsing): pass
Cup.cast = Word.cast = Parsing.cast</p>
<hr>
<!-- Media --><!-- Meanless: 2. Quantum natural language processing 183-->
<p>Example 2.1.8. Computing the meaning of "Alice loves Bob" was the first example in DisCoPy's documentation.</p>
<hr>
<p>s, n = rigid.Ty('s'), rigid.Ty('n')
Alice, loves, Bob =\
Word('Alice', n), Word('loves', n.r @ s @ n.l), Word('Bob', n)
sentence = Alice @ loves @ Bob >> Cup(n, n.r) @ s @ Cup(n.1, n)
sentence.draw(   )</p>
<hr>
<!-- Media -->
<!-- figureText: Alice loves Bob \( {n}^{l} \) \( n \) \( n \) \( {n}^{r} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_182.jpg?x=612&#x26;y=697&#x26;w=495&#x26;h=180&#x26;r=0">
<!-- Media -->
<hr>
<p>F = rigid.Functor(   )
dom = Category (rigid. Ty, Parsing), cod = Category (tuple [ int , ... ] , Tensor ) ,
ob={s: 1, n: 2},
ar={Alice: [[1, 0]], loves: [[0, 1], [1, 0]], Bob: [[0, 1]]})</p>
<hr>
<p>assert F(sentence)</p>
<h4>2.1.3 Anaphora and the quantum complexity of language</h4>
<p>While the meaning of lexical words (also called content words) such as nouns and verbs are extracted from text data, DisCoCat models allow to encode functional words such as pronouns and conjunctions in terms of the Frobenius algebras, a.k.a. spiders, we discussed in section 1.4.3. This Frobenius anatomy of word meanings was first applied to relative pronouns [SCC13; SCC14], then to coordination [Kar16] as well as intonation [KS15]. In previous work with Coecke, de Felice and Marsden \(\left\lbrack  {\mathrm{{Coe}} + {18}}\right\rbrack\) as well as in a subsequent dissertation \(\left\lbrack  {\mathrm{{Tou}}{18}}\right\rbrack\) ,we proposed the use of spiders to model anaphora, expressions such as personal pronouns whose meaning depends on another expression in context, connecting the diagrams for sentences together into a diagram for discourse. This proposal came with an algorithm for constructing a relational database from any such discourse diagram and for translating the diagrams of questions into database queries.</p>
<p>This discourse-to-database translation was refined in later work with de Felice and Meichanetzidis [FMT19] where we defined the functorial question answering problem as the application of a given DisCoCat model to a question diagram. In the case of Boolean-valued models \(F : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) ,we proved that this question-answering problem is in fact equivalent to conjunctive query evaluation, which is NP-complete by a celebrated theorem of Chandra and Merlin [CM77]. Conjunctive queries can be defined as Peircean diagrams with no bubbles, i.e. only spiders and predicate boxes, or equivalently as the first-order logic formulae with existentials and conjunction but no negation, see Bonchi et. al for a diagrammatic treatment [BSS18]. The Chandra-Merlin theorem is based on the construction of a canonical model for the given query, i.e. a canonical functor given a diagram, then reducing evaluation to the problem of graph homomorphism between models. Once translated in terms of Boolean DisCoCat models, the same result implies that question-answering (i.e. the application of a functor to a diagram) is equivalent to the entailment problem: given two sentences, does the truth of one imply that of the other?</p><!-- Meanless: 184 2.1. Formal grammars and quantum complexity-->
<p>DisCoCat models with anaphoric spiders are unsatisfying in two opposite ways: they are not expressive enough to encode negation \({}^{1}\) but if we allow arbitrary anaphora, they are already too expressive to be computed efficiently. The first point cannot be avoided if we want our models to be tractable: adding negation to conjunctive queries will generate all of first-order logic, for which question-answering (i.e. model checking) is PSPACE-complete and entailment (i.e. the Entscheidungsproblem) undecidable. We may get around the second dissatisfaction by adding restrictions on anaphoric expressions. For example, requiring that the corresponding query has bounded tree-width [CR00] ensures that question answering is solvable in polynomial time. This restriction may be motivated in terms of bounded short-term memory: a query with tree-width \(k\) corresponds to a first-order logic with \(k\) variables,each of which may be bound and reused multiple times. We refer to Abramsky and Shah [AS21] for a comonadic approach to such resource bounds.</p>
<p>If we go from Booleans to natural numbers, we get a counting problem: we want to know not only whether but how many answers a question has in a given model. This answer-counting problem is complete for \(\# \mathrm{P}\) ,the generalisation of \(\mathrm{{NP}}\) from decision to counting problems. By extension, evaluating DisCoCat models over the real or complex numbers (with finite precision) is also #P-complete. The closest decision complexity class is PP, also called Majority-P, the class of problems solvable in probabilistic polynomial time with no error bounds, which amounts to computing the most significant digit of a \(\# \mathrm{P}\) problem. If we write \({\mathrm{P}}^{\mathrm{X}}\) for the class of problems solvable in polynomial time with access to an oracle solving any problem of \(\mathrm{X}\) in one step,we can use a binary search to prove \({\mathrm{P}}^{\mathrm{{PP}}} = {\mathrm{P}}^{\# \mathrm{P}}\) . One indication for how much harder counting is compared to decision problems is Toda’s theorem [Tod91]. It states that \(\mathrm{{PH}} \subseteq  {\mathrm{P}}^{\# \mathrm{P}}\) where \(\mathrm{{PH}}\) is the polynomial hierarchy,the union of all towers of NP-oracles,i.e. \(\mathrm{{PH}} = { \cup  }_{n \in  \mathbb{N}}{\sum }_{n}\) where \({\sum }_{0} = \mathrm{P}\) and \({\sum }_{n + 1} = {\mathrm{{NP}}}^{{\sum }_{n}}\) . Intuitively,a PP-oracle for counting problems is at least as powerful as any tower of NP-oracles for decision problems.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Note that the results of [FMT19] assume that the sentence type is mapped to the unit,i.e. the meaning of a sentence is a scalar in \(\mathbb{B}\) . Preller [Pre14a; Pre14b] takes an alternative,four-valued approach to first-order logic with pregroups where the sentence type is given dimension 2: a sentence is either true, false, neither or both.</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 185-->
<p>In a beautifully simple theorem,Aaronson [Aar05] shows that PP \(=\) PostBQP, the class of problems solvable in polynomial time by a quantum computer given post-selection, the ability to make the possible necessary and to choose what outcome we get from a quantum measurement \({}^{1}\) . In one direction,this equality says that the evaluation of a post-selected quantum circuit can be reduced to tensor contraction: quantum gates, bras and kets are nodes, the qubits connecting them are edges. In the other, it means that we can use post-selected quantum computation to contract any tensor network, or equivalently to evaluate any monoidal functor from a free compact closed category into \({\mathbf{{Mat}}}_{\mathbb{C}}\) . The related counting class \(\# \mathrm{P}\) was originally introduced by Valiant [Val79] to show the completeness the matrix permanent. Aaronson and Arkhipov [AA11] then related it to the complexity of boson sampling, a restricted model of quantum computation which they prove cannot be simulated classically unless the polynomial hierarchy collapses to the third level. Although this is less unlikely than \(\mathrm{P} = \mathrm{{NP}}\) ,i.e. a collapse at level zero,this is still believed to be a strong indication that quantum computers cannot be efficiently classically simulated.</p>
<p>Removing post-selection from PostBQP we get BQP, bounded-error quantum polynomial time, arguably the largest class of decision problems that a physical machine \({}^{2}\) can solve efficiently. Its classical analog BPP (bounded-error probabilistic polynomial time) is contained in BQP because quantum computers can simulate classical ones efficiently, but whether the containment is strict is an open question. The best we can do is define BQP-complete problems with circuit approximation as the canonical example: given the description of a quantum circuit, decide whether measuring the first qubit yields a one, with the promise that the probability for this is bounded away from a half. Arad and Landau [AL10] reformulate this in terms of the additive approximation of tensor networks, i.e. the additive approximation of a monoidal functor into \({\mathbf{{Mat}}}_{\mathbb{C}}\) . In one direction,their reduction tells us that we can approximate tensor networks efficiently with a quantum computer. In the other, it means that if we could approximate such functors with a classical computer then we could also simulate any quantum circuit efficiently.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Assuming the many-world hypothesis,Aaronson [Aar05] gives a simple method to achieve post-selection: committing suicide if we do not get the desired outcome. A less brutal method is to keep on trying until we do, in exponential time on average.</p>
<p>\({}^{2}\) By a physical machine we mean a machine that obeys the laws of quantum mechanics. This excludes machines exploiting features of general relativity such as closed time-like curves (CTCs). Using the CTCs of Deutsch [Deu91] a quantum computer can solve all of PSPACE in polynomial time, while the more restricted CTCs of Lloyd et al. [Llo+11b; Llo+11a] solve all of PostBQP in polynomial time. See Pinzani, Gogioso and Coecke [PGC19] for a diagrammatic treatment of time-travel in terms of traced categories.</p>
<!-- Footnote -->
<hr><!-- Meanless: 186 2.2. DisCoCat models on quantum hardware-->
<p>What do these complexity results imply for evaluating DisCoCat models on quantum computers? First, that we cannot hope to evaluate them exactly unless we discover (safe and efficient) time travel and prove PostBQP = BQP. Second, that we can evaluate them efficiently with a quantum computer, up to additive approximation. Third, that if we could do the same with classical computers then they would turn out to be as powerful as quantum computers after all. We would automatically get a classical Shor algorithm that can outperform the best number sieves mathematicans have come up with, and a classical Grover algorithm that can find a needle in a haystack. Thus, by interpreting pregroup grammars in terms of tensor networks, DisCoCat models provide a way to reformulate quantum computing in terms of natural language processing. In short,if BPP \(\neq\) BQP then quantum computers would allow us to (approximately) answer exponentially bigger natural language questions than classical computers can. The idea of using quantum circuits to evaluate DisCoCat models was first introduced by Zeng and Coecke [ZC16], where they show a quadratic advantage on a more restricted classification task using Grover's algorithm as subroutine. Given the size of classical NLP models today, empirical evidence of quantum advantage for natural language processing will most probably require fault-tolerant quantum computers with millions of qubits, if not billions. In the meantime, we are left to explore the possibilities offered by the small noisy quantum computers of today.</p>
<h3>2.2 DisCoCat models on quantum hardware</h3>
<p>We get to the main definition of this thesis: by a QNLP model we mean a monoidal functor \(F : \mathbf{G} \rightarrow\) Circ from the category generated by a grammar \(\mathbf{G}\) to a category Circ of quantum circuits. Chapter 1 has already given several definitions of Circ:</p>
<ul>
<li>
<p>as a category (example 1.1.17),</p>
</li>
<li>
<p>as a monoidal category (example 1.2.26),</p>
</li>
<li>
<p>as a pivotal category (example 1.4.11),</p>
</li>
<li>
<p>as a category with biproducts (example 1.4.44). So far, these definitions have only covered pure quantum circuits with post-selected measurements. Pure quantum gates are interpreted as unitary matrices, preparation (kets) and measurement (bras) as basis vectors. The evaluation of a closed pure circuit is a complex scalar and the Born rule says its squared amplitude is the probability of a measurement outcome for a given preparation. We can use a quantum computer to approximate this probability by executing our circuit many times or in quantum computing parlance, taking many shots. At each execution, we measure all the qubits then we divide the number of times the post-selected outcome occurs by the number of shots. With the interface from the Circuit class of DisCoPy to that of the \(\mathrm{t}|\mathrm{{ket}}\rangle\) compiler \(\left\lbrack  {\mathrm{{Siv}} + {20}}\right\rbrack\) ,going from numerical simulation to quantum hardware is as easy as providing an extra argument backend: pytket.Backend to the method Circuit.eval.</p>
</li>
</ul><!-- Meanless: 2. Quantum natural language processing 187-->
<p>Example 2.2.1. Executing the circuit for "Alice loves Bob" was the first NLP experiment on a quantum computer, as documented in Coecke et al. [Coe+20b].</p>
<hr>
<p>F = rigid.Functor(   )
dom=Category(Ty, Parsing), cod=Category(Qubits, Circuit),
ob={s: qubit ** 0, n: qubit ** 1},
ar={Alice: Ket(0), loves: Ket(0, 0) >> H @ sqrt2 @ X >> CX, Bob: Ket(1)})</p>
<hr>
<p>drawing.equation (sentence, F(sentence), symbol="$\\mapsto$")</p>
<!-- Media -->
<!-- figureText: Alice loves Bob 0 X CX CX CX H \( \mathrm{H} \) \( n \) \( {n}^{r} \) \( S \) \( {n}^{l} \) \( n \) \( \mapsto \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_186.jpg?x=274&#x26;y=1332&#x26;w=1178&#x26;h=472&#x26;r=0">
<p>from pytket.backends.ibm import IBMQBackend</p>
<p>assert F(sentence).eval(   )</p>
<p>backend=IBMQBackend('ibmq_singapore', hub='ibmq'), n_shots=2 ** 10) > .5</p>
<!-- Media -->
<p>Let's unpack what happened when we executed the last line of the example above. We apply a monoidal functor \(\mathrm{F}\) to the diagram for a sentence to get a circuit diagram. DisCoPy then translates it into a pytket. Circuit which gets executed \({2}^{10}\) times on the ’ibmq_singapore’ backend (a 20-qubit quantum device). We then assert that the probability of measuring all zeros is bigger than a \(\frac{1}{2}\) threshold,once multiplied by \({\left( {\left| \sqrt{2}\right| }^{2}\right) }^{3} = 8\) to account for the three scalars. What did we achieve? We have evaluated (the squared amplitude of) the DisCoCat model of example 2.1.8 on a quantum computer! Indeed, we have chosen our QNLP model so that the quantum states for words encode their interpretation, e.g. we have sent loves to an (anti-correlated) Bell state scaled by \(\sqrt{2}\) so that \(\mathrm{F}\) (loves).eval(   ).inside \(= \left\lbrack  {\left\lbrack  {0,1}\right\rbrack  ,\left\lbrack  {1,0}\right\rbrack  }\right\rbrack\) . Assuming a universal gate set,every complex vector \(u \in  {\mathbb{C}}^{{2}^{n}}\) can be encoded as a pure quantum circuit \(c : {\text{qubit}}^{0} \rightarrow  {\text{qubit}}^{n}\) scaled by a positive real scalar to account for the normalisation, which we can represent as a quantum gate on zero qubits.</p><!-- Meanless: 188 2.2. DisCoCat models on quantum hardware-->
<p>In fact, every choice of encoding will define a faithful monoidal functor load : \({\text{Tensor}}_{\mathbb{C}} \rightarrow\) Circ from complex tensors to pure quantum circuits with real scalars (up to equality of their interpretation) which is an inverse to evaluation,i.e. load \({}_{9}^{6}\) eval \(= \operatorname{id}\left( {\operatorname{Tensor}}_{\mathbb{C}}\right)\) . On objects,it sends a dimension \(d \in  \mathbb{N}\) to a qudit,i.e. a \(d\) -dimensional quantum system. From the rigid structure of \({\mathbf{{Tensor}}}_{\mathbb{C}}\) ,every arrow \(f : x \rightarrow  y\) can be written as \(f = x \otimes  u\) ? \(\operatorname{cup}\left( x\right)  \otimes  y\) for the state \(u : 1 \rightarrow  {xy}\) given by \(u = \operatorname{cap}\left( x\right) §x \otimes  f\) . Thus,every tensor can be encoded as a scaled circuit followed by a post-selected Bell measurement. From this isomorphism we can extract an abstract proof of PostBQP = PP: simulating a post-selected quantum circuit is equivalent to evaluating a monoidal functor into tensors, i.e. contracting a tensor network.</p>
<p>In particular,for any DisCocat model \(F : \mathbf{G} \rightarrow  {\operatorname{Tensor}}_{\mathbb{C}}\) we get a QNLP model \({F}_{Q} = F\) ’ load : \(\mathbf{G} \rightarrow\) Circ such that \(F = {F}_{Q}\) ’ eval. Evaluating the circuit \({F}_{Q}\left( f\right)  = c\) for a grammatical sentence \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) yields a quantum state that encodes its interpretation \(\operatorname{eval}\left( c\right)  = F\left( f\right)\) . When the interpretation is a scalar,i.e. \(F\left( s\right)  = 1\) ,we can directly evaluate the circuit to compute the squared amplitude \({\left| F\left( f\right) \right| }^{2}\) . If furthermore we know that the evaluation must be a positive real scalar, e.g. because the vectors for all dictionary entries are positive reals as in our example, we can simply take the square root of this probability to get a truth value for the sentence. However, we are measuring the probability of an exponentially unlikely event (measuring all qubits to zero) thus in general we will need an exponential number of shots to approximate the result. If the truth value is an arbitrary complex scalar, we can use a Hadamard test to compute the real and imaginary part of the complex scalar eval \(\left( c\right)  \in  \mathbb{C}\) . When the interpretation is an \(F\left( s\right)  = n\) -dimensional state for \(n \geq  2\) ,we can perform a swap test with the quantum state for another grammatical expression of the same type, which will compute their inner product, i.e. measure their similarity. From the characterisation of BQP by Arad and Landau [AL10], we know we can get an additive approximation using a polynomial number of shots. However, in general we have no guarantee that this additive error will be no larger than the value we want to approximate.</p><!-- Meanless: 2. Quantum natural language processing 189-->
<p>Thus, this naive definition of QNLP models is unsatisfactory from a computational point of view: if we post-select on all the qubits we'll have to wait an exponentially long time even to approximate an answer. It is also unsatisfactory from a category theoretic point of view. Indeed, so far we have defined the evaluation of pure quantum circuits as a functor into tensor, but what we can actually execute on a quantum device is the Born rule of the result, which is not a functor: the squared amplitude of a composition is not necessarily the composition of the squared amplitudes. Killing two birds with one stone, we can overcome both limitations (computational and theoretical) if we extend our definition of Circ from pure to mixed quantum circuits. In practice, what our QNLP algorithm is missing is the ability to do nothing, i.e. not to measure a qubit. In theory, our category Circ is missing a box for discard. As soon as we leave the realm of pure quantum circuits, quantum states cannot be represented as complex vectors anymore, we need density matrices. Similarly, we cannot interpret quantum circuits as unitary matrices anymore, we need completely-positive trace-preserving (CPTP) maps, also called quantum channels. As a bonus, going from pure to mixed and from unitaries to channels gives us enough room to talk about both classical and quantum processes in the same concrete category Channel.</p>
<h4>2.2.1 Quantum channels and mixed quantum circuits</h4>
<p>DisCoPy implements a variant of the definition of classical-quantum maps (cq-maps) from Coecke and Kissinger [CK17, Chapter 8]. Abstractly, it is a simplification of the \({\mathbf{{CP}}}^{ \star  }\) construction from Coecke,Heunen and Kissinger [CHK12],which itself generalises the notion of finite-dimensional \({\mathrm{C}}^{ \star  }\) -algebra to arbitrary dagger compact closed categories. Concretly, we first define the category CQMap with objects given by pairs of natural numbers \({}^{1}\left( {a,b}\right)  \in  \mathbb{N} \times  \mathbb{N}\) for the classical and quantum dimensions of the system. The arrows \(f : \left( {a,b}\right)  \rightarrow  \left( {c,d}\right)\) are given by \(\left( {a{b}^{2}}\right)  \times  \left( {c{d}^{2}}\right)\) complex matrices,with composition given by matrix multiplication and tensor given by the following diagram:</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) We actually implement an equivalent category where objects are pairs of lists of natural numbers and the arrows are tensors rather than matrices.</p>
<!-- Footnote -->
<hr><!-- Meanless: 190 2.2. DisCoCat models on quantum hardware-->
<!-- Media -->
<!-- figureText: \( a{a}^{\prime } \) \( b{b}^{\prime } \) \( b{b}^{\prime } \) \( {a}^{\prime } \) \( {b}^{\prime } \) \( {b}^{\prime } \) \( a \) \( {b}^{\prime } \) \( d \) \( {d}^{\prime } \) \( C \) \( {d}^{\prime } \) \( d \) \( {d}^{\prime } \) \( f \otimes  {f}^{\prime } \) \( c{c}^{\prime } \) \( d{d}^{\prime } \) \( d{d}^{\prime } \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_189.jpg?x=442&#x26;y=286&#x26;w=672&#x26;h=405&#x26;r=0">
<p>A quantum channel is a cq-map subject to the following two conditions:</p>
<!-- Media -->
<ul>
<li>complete positivity(CP),there is a dimension \(n \in  \mathbb{N}\) and an \(\left( {ab}\right)  \times  \left( {cdn}\right)\) matrix \(g\) with element-wise conjugate \({g}^{ \star  }\) such that:</li>
</ul>
<!-- Media -->
<!-- figureText: \( b \) \( b \) \( a \) \( b \) \( a \) \( b \) \( g \) \( {g}^{ \star  } \) \( d \) \( n \) \( C \) \( d \) \( n \) \( C \) \( d \) \( d \) \( a \) - \( d \) \( C \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_189.jpg?x=407&#x26;y=886&#x26;w=827&#x26;h=560&#x26;r=0">
<!-- Media -->
<ul>
<li>trace preservation (TP) also called causality:</li>
</ul>
<!-- Media -->
<!-- figureText: \( a \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_189.jpg?x=539&#x26;y=1616&#x26;w=567&#x26;h=163&#x26;r=0">
<!-- Media -->
<p>Note that we take the convention to use the algebraic conjugate which is the identity on objects, rather than the diagrammatic conjugate which reverses the order of wires. This makes the implementation easier at the cost of breaking the symmetry of the diagram for complete positivity. We also note that Picturing quantum processes [CK17] does not distinguish between diagrams and their evaluation as matrices. Moreover, their definition of cq-map includes the complete positivity condition, thus they do not give a name to the matrices that we call cq-maps.</p><!-- Meanless: 2. Quantum natural language processing 191-->
<p>There is a functor double : \({\mathbf{{Mat}}}_{\mathbb{C}} \rightarrow  \mathbf{{CQMap}}\) which sends a dimension \(n\) to the pair(1,n)and a complex matrix \(f\) to its double \(\widehat{f}\) ,the cq-map given by tensoring with its conjugate \(\widehat{f} = f \otimes  {f}^{ \star  }\) . The double of a scalar \(s : 1 \rightarrow  1\) gives the same result as the Born rule \(\widehat{s} = s\bar{s} = {\left| s\right| }^{2}\) . The double of any matrix \(f : m \rightarrow  n\) automatically satisfies the complete-positivity condition; it satisfies causality iff \(f\) is an isometry,i.e. \({f}^{ \dagger  }{}_{9}f = \operatorname{id}\left( n\right)\) . Furthermore the functor double is faithful up to a global phase [CK17, Proposition 6.6]. A cq-map is called pure if it is in the image of double and mixed otherwise.</p>
<p>There is also a functor single : \({\mathbf{{Mat}}}_{\mathbb{R}} \rightarrow  \mathbf{{CQMap}}\) which sends a dimension \(n\) to the pair(1,n)and a real matrix \(f : m \rightarrow  n\) to itself. Again,this is always completely positive and it satisfies causality iff \(f\) is a stochastic matrix,i.e. all its columns sum to one. For every dimension \(x \in  \mathbb{N}\) ,there are channels measure(x): \(\left( {1,x}\right)  \rightarrow  \left( {x,1}\right)\) and encode \(\left( x\right)  : \left( {x,1}\right)  \rightarrow  \left( {1,x}\right)\) with underlying matrix given by \({\operatorname{spider}}_{2,1}\left( x\right)\) and \({\operatorname{spider}}_{2,1}\left( x\right)\) . For every pair of dimensions \(a,b \in  \mathbb{N}\) ,we can also define \(\operatorname{discard}\left( {a,b}\right)  : \left( {a,b}\right)  \rightarrow  \left( {1,1}\right)\) and mixed_state \(\left( {a,b}\right)  : \left( {1,1}\right)  \rightarrow  \left( {a,b}\right)\) with underlying matrix given by \({\operatorname{spider}}_{1,0}\left( a\right)  \otimes  \operatorname{cup}\left( b\right)\) and its dagger. Thus,the intuition for the causality condition is that the future cannot signal to the past: if we apply a quantum process then discard the output, we might as well have discarded the input. Abstractly, causality makes the category Channel semicartesian, i.e. the monoidal unit is a terminal object, discarding is the unique arrow from any object into it.</p>
<p>Listing 2.2.2. Implementation of the category CQMap with CQ as objects and Channel as arrows.</p>
<!-- Media -->
<hr>
<p>@dataclass
class CQ:
classical: tuple[int, ...] = (   )
quantum: tuple[int, ...] = (   )
def tensor(self,other: \(\mathrm{{CQ}}\) ) \(\rightarrow  \mathrm{{CQ}}\) :
return CQ(self.classical + other.classical, self.quantum + other.quantum)
def downgrade(self) -> tuple[int] :
return self.classical + 2 * self.quantum
<em><strong><strong>matmul</strong></strong></em> = tensor
\(\mathrm{C},\mathrm{Q} =\) lambda x: \(\mathrm{{CQ}}\) (classical=x),lambda x: \(\mathrm{{CQ}}\) (quantum=x)
@dataclass
class Channel (Composable, Tensorable):</p>
<hr>
<!-- Media --><!-- Meanless: 192 2.2. DisCoCat models on quantum hardware-->
<hr>
<p>inside: Tensor [complex]
dom: \(\mathrm{{CQ}}\)
cod: CQ
@staticmethod
def id(x: CQ) -> Channel:
return Channel ( x , x , Tensor [complex] . id ( x . downgrade (   )))
def dagger(self) -> Channel:
return Channel(self.inside.dagger(   ), self.cod, self.dom)
@inductive
def then(self, other: Channel) -> Channel:
assert self.cod == other.dom
return Channel(self.inside >> other.inside, self.dom, other.cod)
@inductive
def tensor(self, other: Channel) -> Channel:
inside = ... # Given by the diagram above.
return Channel(inside, self.dom @ other.dom, self.cod @ other.cod)
@staticmethod
def double ( \(\mathrm{f}\) : Tensor[complex]) -> Channel:
return Channel(f @ f.map(lambda x: x.conjugate))) Q(f.com), Q(f.cod))
@staticmethod
def single(f: Tensor[float]) -> Channel:
inside = Tensor[complex] (f.inside, f.dom, f.cod)
return Channel ( inside, C(f.dom), C(f.cod))
@staticmethod
def measure ( x : tuple [ int , ...] ) -> Channel :
return Channel (Tensor [complex].spider (2, 1, x), Q(x), C(x))
@staticmethod
def encode(x: tuple[int, ...]) -> Channel:
return Channel (Tensor [complex].spider \(\left( {1,2,x}\right) ,C\left( x\right) ,Q\left( x\right)\) )
@staticmethod
def discard \(\left( {\mathrm{x} : \mathrm{{CQ}}}\right)  \rightarrow\) Channel:
inside = Tensor[complex].spider ( 1 , 0, x.classical ) \\
@ Tensor [complex].cups ( x.quantum, x.quantum [::-1 ] )
return Channel ( inside, x, CQ(   ))</p>
<hr><!-- Meanless: 2. Quantum natural language processing 193-->
<p>The category CQMap inherits a dagger compact closed structure from that of \({\mathbf{{Mat}}}_{\mathbb{C}}\) . The swaps (cups,caps) for classical-quantum systems \(\left( {a,b}\right)  \in  \mathbb{N} \times  \mathbb{N}\) are given by tensoring a single swap (cup,cap) for \(a\) and a double swap (cup,cap) for \(b\) . It is also commutative-monoid-enriched with element-wise addition, note however that the functor double is not CM-enriched,i.e. \(\widehat{f + {f}^{\prime }} \neq  \widehat{f} + \widehat{{f}^{\prime }}\) in general. In quantum mechanical terms, this corresponds to the distinction between quantum superposition and probabilistic mixing. Crucially, the subcategory Channel of CPTP maps is not compact-closed because caps are not causal. It is not commutative-monoid-enriched: the sum of two channels is not causal (although any convex combination is).</p>
<p>Listing 2.2.3. Implementation of CQMap as a CM-enriched compact closed</p>
<!-- Media -->
<p>category.</p>
<hr>
<p>CQ.1 = CQ.r = property (lambda self: self)
for attr in ("swap", "cups", "caps"):
def channel_method(left: CQ, right: CQ) -> Channel:
tensor_method = getattr(Tensor, attr)
return Channel.single(tensor_method(left.classical, right.classical))\
@ Channel.double(tensor_method(left.quantum, right.quantum))
setattr (Channel, attr, channel_method)
def <strong>add</strong>(self, other: Channel) -> Channel:
assert self.dom \(=  =\) other.dom and self.cod \(=  =\) other.cod
return Channel (self.inside + other.inside, self.dom, self.cod)
@staticmethod
def zero(dom: CQ, cod: CQ) -> Channel:
return Channel(Tensor.zero(dom.dowgrade(   ), cod.downgrade(   )), dom, cod)
Channel. <em>add</em>, Channel.zero = <em>add</em>, zero</p>
<hr>
<!-- Media -->
<p>We're now ready to define Circ as a free symmetric monoidal category with a monoidal functor \(\mathbf{{Circ}} \rightarrow  \mathbf{{CQMap}}\) . The definition of circuits depends on a choice of gateset,i.e. a monoidal signature \(\sum\) together with a functor \(\llbracket  - \rrbracket  : {F}^{S}\left( \sum \right)  \rightarrow\) \({\mathbf{{Mat}}}_{\mathbb{C}}\) from the free symmetric category of pure circuits as complex matrices. We assume there is a generating object for each finite-dimensional quantum system \({\sum }_{0} = \{ \operatorname{qudit}\left( n\right) {\} }_{n > 1}\) and a box \(g \in  {\sum }_{1}\) for each pure quantum process,e.g. unitary gates, preparations (kets) and post-selected measurements (bras). We say the gateset is universal when the interpretation \(\llbracket  - \rrbracket  : {F}^{S}\left( \sum \right)  \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) is full,i.e. every complex matrix is the interpretation of some pure circuit.</p><!-- Meanless: 194 2.2. DisCoCat models on quantum hardware-->
<p>We then define an extended signature \({cq}\left( \sum \right)  \supset  \sum\) with objects:</p>
<p></p>\[{cq}{\left( \sum \right) }_{0} = \{ \operatorname{digit}\left( n\right) {\} }_{n > 1} + \{ \operatorname{qudit}\left( n\right) {\} }_{n > 1}\]<p></p>
<p>for classical and quantum systems of each dimension, and boxes given by:</p>
<p></p>\[{cq}{\left( \sum \right) }_{1} = \{ \widehat{g}{\} }_{g \in  {\sum }_{1}} + \{ \text{ measure }\left( n\right)  : \text{ qudit }\left( n\right)  \rightarrow  \operatorname{digit}\left( n\right) {\} }_{n > 1}\]<p></p>
<p></p>\[+ \{ \text{encode}\left( n\right)  : \text{digit}\left( n\right)  \rightarrow  \text{qudit}\left( n\right) {\} }_{n > 1}\]<p></p>
<p>Let \(\mathbf{{Circ}} = {F}^{S}\left( {{cq}\left( \sum \right) }\right)\) be the free symmetric category it generates,where the diagrams are called mixed quantum circuits. The evaluation \(\left\lbrack  -\right\rbrack   :\) Circ \(\rightarrow\) CQMap is given by \(\llbracket \operatorname{digit}\left( n\right) \rrbracket  = \left( {n,1}\right) ,\llbracket \operatorname{qudit}\left( n\right) \rrbracket  = \left( {1,n}\right)\) and \(\llbracket \widehat{g}\rrbracket  = \operatorname{double}\left( {\llbracket g\rrbracket }\right)\) . The evaluation of any mixed circuit is always completely-positive [CK17, Corollary 8.6]. Let CausalCirc \(\hookrightarrow\) Circ be the subcategory of causal processes,i.e. CausalCirc \(=\) \({F}^{S}\left( {\operatorname{cq}\left( {\sum }^{\prime }\right) }\right)\) for \({\sum }^{\prime } \subseteq  \sum\) the set of boxes that are interpreted as isometries. If the gateset is universal,then the interpretation CausalCirc \(\rightarrow\) Channel is full [CK17, Theorem 8.96]. More explicitly,every quantum channel \(f : \left( {a,b}\right)  \rightarrow  \left( {c,d}\right)\) can be written as:</p>
<p>\(f = \operatorname{encode}\left( a\right)  \otimes  b \otimes  \operatorname{double}\left( {|0{\rangle }_{n}}\right)\) " \(\operatorname{double}\left( g\right)\) " \(\operatorname{measure}\left( c\right)  \otimes  d \otimes  \operatorname{discard}\left( n\right)\)</p>
<p>for some \(n\) -dimensional ancilla \(|0{\rangle }_{n}\) and an \(\left( {nab}\right)  \times  \left( {ncd}\right)\) unitary matrix \(g\) . This gives us a general intuition for what it means to take a shot at a quantum circuit: 1) we prepare some qubits in the zero state, 2) we perform classically-controlled unitary gates, 3) we measure some of the qubits and discard the others. Drawing digits and qudits as thin and thick wires, encode and measure as spiders, discard as three horizontal lines, we get the following diagram for a generic circuit:</p>
<!-- Media -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_193.jpg?x=546&#x26;y=1619&#x26;w=467&#x26;h=261&#x26;r=0">
<!-- Media -->
<p>DisCoPy implements Circuit as a subclass of Diagram with objects generated by two families of objects Digit (n) and Qudit (n) indexed by natural numbers n > 1, where bit = Ty(Digit(2)) and qubit = Ty(Qudit(2)). The class Gate is a subclass of Box and Circuit with an attribute array which will define its interpretation as a pure circuit, i.e. a unitary matrix. We also have boxes for Ket and its dagger Bra, Measure and its dagger Encode, Discard and its dagger MixedState.</p><!-- Meanless: 2. Quantum natural language processing 195-->
<p>Listing 2.2.4. Implementation of the category Circ with Digit and Qudit as generating objects and Circuit as arrows.</p>
<hr>
<p>class Digit (Ob):
def <strong>init</strong>(self, n: int):
self.n = n
super(   ).<em>init</em>(name="bit" if n == 2 else "Digit({})".format(n))
class Qudit(Ob):
def <strong>init</strong>(self, n: int):
self.n = n
super(   ).<em>init</em>(name="qubit" if n == 2 else "Qudit({})".format(n))
bit, qubit = Ty(Digit(2)), Ty(Qudit(2))
class Circuit (Diagram): pass
class Gate (Box, Circuit) :
def <strong>init</strong>(self, name: str, dom: Ty, cod: Ty,
array: list[list[complex]], is_dagger=False):
self.array = array
Box. _ init_(self, name, dom, cod, is_dagger=is_dagger)
def dagger(self) -> Gate: return Gate(   )
self.name, self.cod, self.dom, self.array, is_dagger=not self.is_dagger)
class Bra (Box, Circuit) :
def <strong>init</strong>(self, *digits: int, base=2):
self.digits, self.base = digits, base
name = "Bra({}, base={})".format(', '.join(map(str, digits)), base)
Box.<em>init</em>(self, name, qubit ** len(digits), qubit ** 0)
def dagger(self) -> Ket: return Ket(*self.digits, base=self.base)
class Ket (Box, Circuit) :
def <strong>init</strong>(self, *digits: int, base=2):
self.digits, self.base, name = digits, base
name = "Ket({}, base={})".format(', '.join(map(str, digits)), base)
Box.<em>init</em>(self, name, qubit ** 0, qubit ** len(digits))</p>
<hr><!-- Meanless: 196 2.2. DisCoCat models on quantum hardware-->
<!-- Media -->
<hr>
<pre><code>def dagger(self) -> Bra: return Bra(*self.digits, base=self.base)
</code></pre>
<p>class Encode (Box, Circuit) :
def <strong>init</strong>(self, dom=bit):
obj, = dom.inside
assert isinstance(obj, Digit)
Box.<em>init</em>("Encode({})".format(n), dom, Ty(Qudit(obj.n)))
def dagger(self) -> Measure: return Measure(self.cod)
class Measure (Box, Circuit):
def _<em>init</em>(self, dom=qubit):
obj, = dom.inside
assert isinstance(obj, Qudit)
Box.<em>init</em>("Measure({})".format(n), dom, Ty(Digit(obj.n)))
def dagger(self) \(\rightarrow\) Encode: return Encode(self.cod)
class Discard(Box, Circuit):
def <strong>init</strong>(self, x: Ty):
Box.<em>init</em>("Discard({})".format(x), x, Ty(   ))
def dagger(self) -> MixedState: return MixedState(self.dom)
class MixedState (Box, Circuit):
def <strong>init</strong>(self, x: Ty):
Box.<em>init</em>("MixedState({})".format(x), Ty(   ), x)
def dagger(self) -> Discard: return Discard(self.cod)</p>
<hr>
<!-- Media -->
<p>As discussed in example 1.4.11, the category Circ also has a dagger compact closed structure where the cups and caps for qudits are given by scaled Bell states and post-selected Bell measurements respectively. The cups for digits are given by the result of measuring a scaled Bell state, or equivalently as an (unnormalised) correlated probability distributions, the caps can be thought of as classical post-selection on two digits being equal. We can freely enrich Circ in commutative monoids and execute (simulate) a formal sum of circuits by executing (simulating) each circuit and adding up the results. If we can take formal sums, there's no reason not to also take linear combinations of circuits. Via the Born rule, we can already define positive real scalars as the evaluation of pure quantum gates on zero qubits,such as the \(\sqrt{2}\) scalars of our first example 2.2.1. What we’re missing are mixed scalars which get applied after the Born rule.</p><!-- Meanless: 2. Quantum natural language processing 197-->
<!-- Media -->
<p>Listing 2.2.5. Implementation of pure and mixed scalars in Circ.</p>
<hr>
<p>class Sqrt (Gate):
def <strong>init</strong>(self, x: float):
super(   ).<strong>init</strong>(   )
"$\\sqrt {}$".format(x), Ty(   ), Ty(   ), array=[[math.sqrt(x)]])
class Scalar ( Box , Circuit ) :
def <strong>init</strong>(self, z: complex, is_pure=False):
self.z, self.is_pure = z, is_pure
Box.___<strong>init</strong>(   )
self, "Scalar({}, is_pure={})".format(z, is_pure), Ty(   ), Ty(   ))</p>
<hr>
<!-- Media -->
<p>Listing 2.2.6. Implementation of the subcategory of Circ spanned by qubits as a compact closed category.</p>
<!-- Media -->
<hr>
<p>Digit.l = Digit.r = Qudit.l = Qudit.r = property(lambda self: self)
\(X,Y,Z,H =\) (Gate(name,qubit,qubit,array) for name,array in zip("XYZH", [
\(\left\lbrack  {\left\lbrack  {0,1}\right\rbrack  ,\left\lbrack  {1,0}\right\rbrack  }\right\rbrack  ,\left\lbrack  {\left\lbrack  {0, - {1j}}\right\rbrack  ,\left\lbrack  {{1j},0}\right\rbrack  }\right\rbrack  ,\left\lbrack  {\left\lbrack  {1,0}\right\rbrack  ,\left\lbrack  {0, - 1}\right\rbrack  }\right\rbrack  ,\)
[[1 / sqrt(2), 1 / sqrt(2)], [1 / sqrt(2)]]]))
CX = Gate('CX', qubit ** 2, qubit ** 2, [[1, 0, 0, 0],
\(\left\lbrack  {0,1,0,0}\right\rbrack\) ,
\(\left\lbrack  {0,0,0,1}\right\rbrack\) ,
[0, 0, 1, 0]])
@staticmethod
@nesting
def cups(left: Ty, right: Ty):
if left == right == qubit: return Sqrt ( 2 @ Ket \(\left( {0,0}\right)  >  > \mathrm{H}\) @ qubit \(>  > \mathrm{{CX}}\)
raise NotImplementedError
Circuit.cups, Circuit.caps = cups, lambda left, right: cups(left, right).dagger(   )</p>
<hr>
<!-- Media -->
<p>Circuit comes with a Boolean property is_pure which defines the subcategory of pure circuits, i.e. that we can interpret as Tensor. The eval method now comes with an optional Boolean argument mixed: if not mixed and is_pure we apply a Tensor-valued functor, otherwise a Channel-valued functor. The optional backend argument allows to go from numerical simulation to quantum hardware: it translates a circuit diagram with only Digit outputs (i.e. all qudits have been measured or discarded) into a pytket. Circuit before executing it on a quantum device. As of today, DisCoPy does not implement the execution of Encode on quantum hardware yet, this would require to decide which quantum gate to perform depending on the result of a previous measurement. Although simulating qudit circuits is no harder than qubit simulation, standard quantum hardware can only execute qubit circuits so far.</p><!-- Meanless: 198 2.2. DisCoCat models on quantum hardware-->
<!-- Media -->
<p>Listing 2.2.7. Implementation of the Circuit.eval method.</p>
<hr>
<p>for cls in (Gate, Bra, Ket): setattr(cls, "is_pure", True)
for cls in (Encode, Measure, Discard, Mixed): setattr(cls, "is_pure", False)
Circuit.is_pure = property (lambda self:
all (box. is_pure for box in self. boxes)
and all (isinstance (obj, Qudit) for obj in (self.dom @ self.cod).inside))
class PureEval (Functor) :
ob = ar = {}
dom, cod = Category(Ty, Circuit), Category(tuple[int, ...], Tensor[complex])
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Qudit): return [other.n]
if isinstance(other, Gate) and not other.is_dagger:
return Tensor[complex] (other.array, self(other.dom), self(other.cod))
if isinstance(other, Bra): return self(other.dagger(   )).dagger(   )
if isinstance(other, Ket):
if not other.digits: return Tensor.id([])
if len (other.digits) == 1:
inside = [[i == other.digits[0] for i in range(other.base)]]
return Tensor[complex] (inside, [], [other.base])
head, *tail = other.digits
return self(Ket(head, base=other.base))\
( gelf (Ket (*tail, base=other.base))
return super(   ). _call (other)
class MixedEval (Functor) :
ob = ar = {}
dom, cod = Category(Ty, Circuit), Category(CQ, Channel)
def <em><strong><strong>call</strong></strong></em> (self, other) :
if isinstance(other, Qudit): return Q([other.n])
if isinstance(other, Digit): return C([other.n])
if isinstance(other, Scalar): return Channel([[
abs(other.z) ** 2 if other.is_pure else other.z]], CQ(   ), CQ(   ))
if isinstance(box, (Gate, Bra, Ket)):
return Channel.double(PureEval(   )(box))
if isinstance(box, Encode): return Channel.encode(self(box.dom))
if isinstance(box, Measure): return Channel.measure(self(box.dom))</p>
<hr>
<!-- Media --><!-- Meanless: 2. Quantum natural language processing 199-->
<hr>
<pre><code>	if isinstance(box, Discard): return Channel.discard(self(box.dom))
	if isinstance(box, MixtedState): return self(box.dagger(   )).dagger(   )
	return super(   ).__call__(other)
</code></pre>
<p>def eval(self, mixed=True, backend=None) -> Tensor | Channel:
if backend is not None: ... # Interface with pytket.
return PureEval(   ) (self) if not mixed and self.is_pure else MixedEval(   ) (self)</p>
<hr>
<p>Example 2.2.8. We can simulate a Bell test experiment by applying the evaluation functor \(\mathbf{{Circ}} \rightarrow  \mathbf{{Channel}}\) .</p>
<hr>
<p>circuit = Ket \(\left( {0,0}\right)  >  >\) H @ qubit \(>  >\) CX \(>  >\) Measure(   ) @ Measure(   )
circuit.draw(   )</p>
<hr>
<!-- Media -->
<!-- figureText: CX -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_198.jpg?x=785&#x26;y=874&#x26;w=147&#x26;h=296&#x26;r=0">
<p>assert circuit.eval(   ) == Channel([[.5, 0, 0, .5]], CQ(   ), C([2, 2]))</p>
<!-- Media -->
<h4>2.2.2 Simplifying QNLP models with snake removal</h4>
<p>Previous sections have spelled out a first definition of QNLP models as monoidal functors \(F : \mathbf{G} \rightarrow\) Circ. The main limitation of this approach is the need for post-selection: for each cup in our pregroup reduction we need to post-select on the result of a Bell measurement, which requires to double the number of shots in order to measure accurately. Another related problem is that we need to load all the word vectors on the quantum device at once, requiring a number of qubits proportional to the length of the sentence. We may solve both issues at once using the snake removal algorithm described in listing 1.4.8. Instead of mapping the grammatical structure of the sentence directly onto the architecture of a quantum circuit, we will first rewrite the pregroup diagram to remove unnecessary snakes. Indeed, from the rigid structure of Circ we have that the three-qubit circuit for a snake can be simplified to a one-qubit identity circuit. This is an abstract way to reformulate the correctness of the post-selected teleportation protocol. Thus, for each snake removed we are effectively reducing the number of required qubits by two, with half the amount of required post-selection.</p><!-- Meanless: 200 2.2. DisCoCat models on quantum hardware-->
<p>Pregroup diagrams themselves have no snakes, only boxes for the dictionary entries followed by cups. The autonomisation procedure of Delpeuch [Del19] allows to make the snakes manifest by opening up the boxes and filling them with caps. Abstractly, it is based on the construction of the free rigid category generated by a given monoidal category,i.e. an autonomisation \({}^{1}\) functor \(A : \mathbf{{MonCat}} \rightarrow\) RigidCat which is left adjoint to the functor \(U :\) RigidCat \(\rightarrow\) MonCat which forgets adjoints,cups and caps. The action of the functor \(A\) on objects is simple: given a monoidal category \(C \simeq  {F}^{M}\left( \sum \right) /R\) presented by a monoidal signature \(\sum\) and relations \(R\) ,we take the quotient \(A\left( C\right)  = {F}^{R}\left( \sum \right) /R\) of the free rigid category generated by \(\sum\) ,seen as a rigid signature with no adjoints. More explicitly,we start from a monoidal category \(C\) that has no adjoints,cups or caps,we end up with a larger category \(A\left( C\right)\) where we have added them freely: the arrows of \(A\left( C\right)\) are rigid diagrams with boxes and equations coming from \(C\) .</p>
<p>The embedding functor \(E : C \rightarrow  A\left( C\right)\) ,which maps every arrow in \(C\) to itself in this larger context,is monoidal and faithful [Del19,Theorem 1]: if \(E\left( f\right)  = E\left( g\right)\) for two arrows \(f,g : x \rightarrow  y\) in \(C\) ,then we must have \(f = g\) to begin with,we cannot prove more equalities by introducing snakes. In fact, this embedding functor is also full [Del19,Theorem 2],the map \(E : C\left( {x,y}\right)  \rightarrow  A\left( C\right) \left( {x,y}\right)\) is an isomorphism for all objects \(x,y\) in \(C\) ,its inverse is computed by snake removal. In particular for a free monoidal category \(C = {F}^{M}\left( \sum \right)\) ,we get the following corollary: for a rigid diagram where the domain and codomain of each box, and of the diagram itself, contain no adjoints, the normal form contains no cups or caps, i.e. all snakes have been removed. Thus, autonomisation allows to define the semantics of a pregroup grammar \(\mathbf{G}\) in a monoidal category \(C\) that is not rigid,for example in cartesian or semicartesian categories like Pyth and CausalCirc. Indeed, we can now define a rigid functor \(F : \mathbf{G} \rightarrow  A\left( C\right)\) ,apply it to a grammatical sentence \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s\) to get a rigid diagram \(F\left( f\right)  : 1 \rightarrow  F\left( s\right)\) in \(A\left( C\right)\) . From fullness we know all snakes can be removed until we get a concrete arrow normal_form \(\left( {F\left( f\right) }\right)\) in \(C\) : the meaning of the sentence \(f\) . This autonomisation procedure is implemented in three steps:</p>
<ol>
<li>
<p>we define a rigid functor wiring : \(\mathbf{G} \rightarrow  A\left( {{F}^{M}\left( \sum \right) }\right)\) from our pregroup grammar to the free rigid category generated by a monoidal signature \(\sum\) ,</p>
</li>
<li>
<p>we apply this functor to a sentence: pregroup.Parsing then take the normal form to get a monoidal diagram, i.e. without cups, caps or adjoints,</p>
</li>
</ol>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) Autonomous is a synonym of rigid,thus autonomisation could have been called rigidification but this would be counterintuitive, since it makes a monoidal category more flexible.</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 201-->
<ol start="3">
<li>we apply a monoidal functor \(\mathrm{G} : {F}^{M}\left( \sum \right)  \rightarrow  C\) into our semantic category \(C\) to get the meaning of the sentence \(G\) (wiring(sentence).normal_form(   )).</li>
</ol>
<p>Example 2.2.9. Let's remove the snakes from "Alice loves Bob" by applying a functor wiring : \(\mathbf{G} \rightarrow  A\left( {{F}^{M}\left( \sum \right) }\right)\) for the monoidal signature \(\sum\) given by boxes \(1 \rightarrow  n\) for "Alice" and "Bob" and \(n \otimes  n \rightarrow  s\) for "loves".</p>
<hr>
<p>wiring = rigid.Functor(   )
dom = Category (rigid. Ty, pregroup. Parsing) ,
cod=Category (rigid.Ty, rigid.Diagram) ,
ob=lambda x: x,
ar={Alice: Box ("Alice", Ty (   ), n), Bob: Box ("Bob", Ty (   ), n),
loves: Cap(n.r, n) @ Cap(n, n.1) >> n.r @ Box("loves", n @ n, s) @ n.1})
steps = sentence, wiring(sentence), wiring(sentence).normal_form(   )
drawing.equation (*steps, symbol='$\\mapsto$')</p>
<hr>
<!-- Media -->
<!-- figureText: Alice loves Bob Alice Alice Bob \( n \) \( {n}^{r} \) \( n \) loves Bob loves \( S \) \( n \) \( n \) \( {n}^{l} \) \( n \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_200.jpg?x=278&#x26;y=1014&#x26;w=1164&#x26;h=245&#x26;r=0">
<!-- Media -->
<p>The resulting diagram is indeed a monoidal diagram, i.e. we have removed the two snakes. This means we can apply any monoidal functor to it. For example, the following functor \(G : {F}^{M}\left( \sum \right)  \rightarrow\) Pyth was introduced in [Fel+20] in order to define functorial language games, it sends pregroup diagrams to Python functions that evaluate to themselves.</p>
<hr>
<p>G = monoidal.Functor(   )
dom = Category (rigid. Ty, rigid. Diagram) ,
cod=Category (tuple [type, ...], Function),
ob={s: pregroup.Parsing, n: pregroup.Parsing},
ar={Box("Alice", Ty(   ), n): lambda: Alice,
Box("Bob", Ty(   ), n): lambda: Bob,
Box ("loves", n @ n, s): lambda f, g:
f @ loves @ g >> Cup(n, n.r) @ s @ Cup(n.1, n) })
assert G(wiring(sentence).normal_form(   ))(   ) == sentence</p>
<hr>
<p>We can also apply a functor \(G : {F}^{M}\left( \sum \right)  \rightarrow\) Circ to simplify the circuit of example 2.2.1.</p><!-- Meanless: 202 2.2. DisCoCat models on quantum hardware-->
<!-- Media -->
<hr>
<p>G = monoidal.Functor(   )
dom = Category (rigid. Ty, rigid. Diagram) ,
cod=Category (circuit.Ty, Circuit) ,
ob={s: qubit ** 0, n: qubit},
ar={Box("Alice", Ty(   ), n): Ket(0), Box("Bob", Ty(   ), n): Ket(1),
Box("loves", n @ n, s): CX >> H @ sqrt2 @ X >> Bra(0, 0)})
drawing.equation (F(sentence), G(wiring(sentence).normal_form(   )))</p>
<hr>
<!-- figureText: 0 0 1 0 CX X 0 0 0 H X CX CX CX H 0 0 0 -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_201.jpg?x=327&#x26;y=710&#x26;w=908&#x26;h=462&#x26;r=0">
<p>assert F(sentence).eval(   ) == G(wiring(sentence).normal_form(   )).eval(   )</p>
<!-- Media -->
<p>Example 2.2.10. We can rewrite noun phrases with subject relative pronouns such as "Alice who loves Bob" using the following factorisation for "who". We can then use the Frobenius anatomy of subject relative pronouns as given by Sadrzadeh et al. [SCC13] to get a simplified quantum circuit.</p>
<!-- Media -->
<hr>
<p>who = Word("who", n.r @ n @ s.l @ n)
phrase = Alice @ who @ loves @ Bob\
>> Cup(n, n.r) @ n @ s.l @ Cup(n, n.r) @ s @ Cup(n.1, n) >> n @ Cup(s.1, s)
wiring.ar[who] = Cap(n.r, n)\
>> n.r @ Box("who_1", n, x @ n)\
>> n.r @ x @ Cap(s, s.l) @ n
>> n.r @ Box("who_2", x @ s, n) @ s.l @ n
G.ob \(\left\lbrack  x\right\rbrack   =\) qubit
G. ar [Box ("who_1", n, x @ n)] = H @ sqrt2 @ Ket(0) >> CX
G. ar [Box ("who_2", x @ s, n)] = Circuit.id(qubit)
rewrite_steps = (   )
phrase,</p>
<hr>
<!-- Media --><!-- Meanless: 2. Quantum natural language processing 203-->
<hr>
<pre><code>wiring (phrase),
wiring(phrase).normal_form(   ),
G(wiring(phrase).normal_form(   )))
</code></pre>
<p>drawing.equation ( rewrite_steps, symbol='$\\mapsto$' )</p>
<hr>
<!-- Media -->
<!-- figureText: Alice who loves Bob \( S \) \( {n}^{l} \) \( n \) \( n \) loves \( S \) Bob \( n \) 0 1 H CX CX 0 0 \( {n}^{r} \) \( n{n}^{r} \) I \( n \) \( {\mathrm{{who}}}_{1} \) \( x \) \( n \) Alice who2 \( n \) \( n \) I Alice Bob \( n \) \( n \) who \( {\mathrm{{hO}}}_{1} \) \( x \) \( n \) \( \mapsto \) loves \( S \) who \( {}_{2} \) \( n \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_202.jpg?x=387&#x26;y=513&#x26;w=951&#x26;h=1109&#x26;r=0">
<!-- Media -->
<p>Example 2.2.11. We can always construct a trivial wiring functor which sends a dictionary entry to the disconnected diagram given by tensoring the iterated transpose of boxes with one wire.</p>
<hr>
<p>def trivial_ar(word: Word) -> rigid.Diagram:
if len (word.cod) == 1:
obj, = word.cod.inside
if obj.z == 0 : return
return Box (word.name, word.cod) if obj.z == 0 else
trivial_ar(Word(word.name, word.cod.r)).transpose(left=True)\\
if obj.z &#x3C; 0 else
trivial_ar(Word(word.name, word.cod.l)).transpose(left=False)</p><!-- Meanless: 204 2.2. DisCoCat models on quantum hardware-->
<pre><code>return rigid.Diagram.tensor(*[
	trivial_ar(Word(" \( \{ \} \) _ \( \{ \} \) ".format(word.name,i),x))
	for i, x in enumerate(word.cod)])
</code></pre>
<p>trivial = rigid.Functor (   )
dom = Category (rigid. Ty, pregroup. Parsing),
cod=Category (rigid.Ty, rigid.Diagram) ,
ob=lambda x: x, ar=trivial_ar)
steps = sentence, trivial(sentence), trivial(sentence).normal_form(   )
drawing.equation (*steps, symbol='$\\mapsto$')</p>
<hr>
<!-- Media -->
<!-- figureText: Alice loves Bob \( {n}^{l} \) \( n \) I \( n \) \( {n}^{l} \) loves \( {}_{2} \) Bob \( S \) \( n \) J Bob \( n \) loves \( {}_{2} \) \( n \) \( {n}^{r} \) \( {n}^{r} \) \( n \) Alice loves0 love \( {\mathrm{s}}_{1} \) \( n \) Alice loves \( {}_{1} \) \( n \) loves0 -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_203.jpg?x=411&#x26;y=789&#x26;w=738&#x26;h=750&#x26;r=0">
<!-- Media -->
<p>The wiring functor is the key ingredient of the autonomisation recipe as given by Delpeuch [Del19]. For each dictionary entry we need to find some monoidal boxes (i.e. without adjoints) from which we can bend the wires to get the desired pregroup type. We do not know if a non-trivial autonomisation is possible for arbitrary pregroup types,for example object relative pronouns of type \({n}^{r}n{n}^{ll}{s}^{l}\) . In example 2.2.9,wiring was straightforward because all types had the shape \(\left( {x}^{r}\right) y\left( {z}^{l}\right)\) for a generating object \(y \in  X\) and some types \(x,z \in  {X}^{ \star  }\) which do not contain adjoints. Let us call types of this shape dependency types,we claim \({}^{1}\) that a pregroup grammar with only dependency types is in fact a dependency grammar (DG) as defined by Gaifman [Gai65]. From such a dependency grammar \(G = \left( {V,X,D,s}\right)\) with dictionary entries \(e = \left( {w,\left( {x}^{r}\right) y\left( {z}^{l}\right) }\right)  \in  D\) ,we construct a monoidal signature \({\sum }_{G}\) with generating objects \(X\) and boxes \({f}_{e} : {xz} \rightarrow  y\) together with a rigid functor wiring : \(\mathbf{G} \rightarrow  A\left( {{F}^{M}\left( {\sum }_{G}\right) }\right)\) which acts as \(e \mapsto  \operatorname{cap}\left( {x}^{r}\right)  \otimes  \operatorname{cap}\left( z\right)\) , \({x}^{r} \otimes  {f}_{e} \otimes  {z}^{l}\) . The resulting normal form is a monoidal diagram where all boxes have exactly one output, thus it is isomorphic to a tree which is called a dependency tree.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) A sketch of this statement is available on the nLab [Tn21],a detailed proof will appear in de Felice's thesis [Fel22].</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 205-->
<p>Dependency grammars are weakly equivalent to context-free grammars [Gai65, Theorem 3.11] and they are in fact strongly equivalent to a subclass of CFGs characterised by a notion of finite degree [Gai65, Theorem 3.10]. This strong equivalence can be computed in logarithmic space, thus the parsing problem for DGs reduces to that of CFGs, it can be solved in polynomial time. Hence, DGs generate the same languages as CFGs and pregroup grammars but they sit somewhere at the intersection of the two frameworks in terms of the grammatical structures they can generate. We conjecture that a PG is strongly equivalent to a CFG if and only if its dictionary entries all have dependency types, i.e. DGs would be precisely characterised as the intersection of CFGs and PGs. In addition to their theoretical interest, DGs have also been applied in practice for natural language processing at industrial scale with the spaCy library [HM17]. Going from pregroup grammars to the more restricted dependency grammars, all grammatical structures become tree-shaped and can be interpreted in arbitrary monoidal categories. In particular, we can now define causal QNLP models as functors \(F : \mathbf{G} \rightarrow  A\) (CausalCirc) where the meaning of grammatical sentences is given by quantum circuits without post-selection. Giving experimental support to this approach is an ongoing research project.</p>
<h4>2.2.3 DisCoCat models via knowledge graph embedding</h4>
<p>In the previous section, we have showed how to evaluate a given DisCoCat model on a quantum computer. But where do we get this model from in the first place? The first two DisCoCat papers [CCS08; CCS10] focused on the mathematical foundations for their models. Assuming that the meaning for words was given, they showed how to compute the meaning for grammatical sentences. Grefenstette and Sadrzadeh [GS11] gave a first implementation of a DisCoCat model for a simple pregroup grammar \(G = \left( {V,X,D,s}\right)\) made of common nouns and transitive verbs. Concretely,their vocabulary is given \(V = E + R\) for some finite sets \(E\) and \(R\) which we may call entities and (binary) relations. They take basic types \(X = \{ s,n\}\) and dictionary \(D = \{ \left( {e,n}\right) {\} }_{e \in  E} \cup  {\left\{  \left( r,{n}^{r}s{n}^{l}\right) \right\}  }_{r \in  R}\) . Thus,every grammatical sentence is of the form \(f : {xry} \rightarrow  s\) for what we may call a triple of subject-verb-object \(\left( {x,r,y}\right)  \in  L\left( G\right)  \simeq  E \times  R \times  E\) . They define a DisCoCat model \(F : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{R}}\) with \(F\left( s\right)  = 1\) and a hyper-parameter \(F\left( n\right)  = d \in  \mathbb{N}\) using the following recipe:</p><!-- Meanless: 206 2.2. DisCoCat models on quantum hardware-->
<ol>
<li>
<p>extract a co-occurrence matrix from a corpus of text and compute a \(d\) - dimensional word vector \(F\left( e\right)  \in  {\mathbb{R}}^{d}\) for each noun \(e \in  E\) ,</p>
</li>
<li>
<p>for each transitive verb \(r \in  R\) ,find the set \({K}_{r} \subseteq  E \times  E\) of all pairs of nouns \(\left( {x,y}\right)  \in  {K}_{r}\) such that the sentence \({xry} \in  E \times  R \times  E\) occurs in the corpus, then define</p>
</li>
</ol>
<p></p>\[F\left( r\right)  = \mathop{\sum }\limits_{{\left( {x,y}\right)  \in  {K}_{r}}}F\left( x\right)  \otimes  F\left( y\right)\]<p></p>
<p>The meaning of a sentence \(f : {xry} \rightarrow  s\) would then be given by the inner product \(F\left( f\right)  = \langle F\left( x\right)  \otimes  F\left( y\right)  \mid  F\left( r\right) \rangle\) which we can rewrite as</p>
<p></p>\[F\left( f\right)  = \mathop{\sum }\limits_{{\left( {{x}^{\prime },{y}^{\prime }}\right)  \in  {K}_{r}}}\left\langle  {F\left( x\right)  \mid  F\left( {x}^{\prime }\right) }\right\rangle  \left\langle  {F\left( y\right)  \mid  F\left( {y}^{\prime }\right) }\right\rangle\]<p></p>
<p>i.e. we take the sum of the similarities between our subject-object pair(x,y)and the pairs \(\left( {{x}^{\prime },{y}^{\prime }}\right)\) that appeared in the corpus. However,the task they aim to solve is word sense disambiguation which they cast in terms of sentence similarity, but if the meaning of sentences are given by scalars there is no meaningful way compare them. For example, the verb "draw" can be synonymous to "sketch" but also to "pull". Thus, they want their model to predict that "Bob draws diagrams" is more similar to "Bob sketches diagrams" than to "Bob pulls diagrams". Using a spider trick that has been later formalised by Kartsaklis et al. [KSP12], they decide to replace inner product by element-wise multiplication. This amounts to defining a new functor \({F}^{\prime } : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{R}}\) by post-composing verb meanings with spiders,i.e.</p>
<p></p>\[{F}^{\prime }\left( n\right)  = F\left( n\right)  = d,\;{F}^{\prime }\left( s\right)  = {d}^{2},\;{F}^{\prime }\left( e\right)  = F\left( e\right)\]<p></p>
<p></p>\[\text{and}{F}^{\prime }\left( r\right)  = F\left( r\right) \text{,}{\operatorname{spider}}_{1,2}\left( d\right)  \otimes  {\operatorname{spider}}_{1,2}\left( d\right)\]<p></p>
<p>Indeed,the element-wise multiplication of two vectors \(u,v \in  {\mathbb{R}}^{d}\) can be defined as \(u \odot  v = u \otimes  v\) spider \({}_{2,1}\left( d\right)\) ,from which we get the desired meaning for the sentence: Now that sentence meanings are given by \({d}^{2}\) -dimensional vectors rather than scalars, we can compute their similarity with inner products and use this to solve the disambiguation task.</p>
<!-- Media -->
<!-- figureText: \( F\left( x\right) \) \( F\left( r\right) \) \( F\left( y\right) \) \( F\left( x\right) \) \( F\left( r\right) \) \( F\left( y\right) \) \( F\left( x\right) \) \( F\left( y\right) \) \( F\left( r\right) \) \( d \) \( d \) \( d \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_205.jpg?x=234&#x26;y=1889&#x26;w=1091&#x26;h=225&#x26;r=0">
<!-- Media --><!-- Meanless: 2. Quantum natural language processing 207-->
<p>The key observation which motivated our previous dissertation [Tou18] as well as the subsequent articles [Coe+18] and [FMT19] is that a corpus \(K \subseteq  E \times  R \times  E\) of such subject-verb-object sentences can be seen as the data for a knowledge graph. In this simplified setting, a DisCoCat model can be seen as an instance of knowledge graph embedding (KGE) where we want to find a low-dimensional representation of entities and relations. The interpretation of a sentence can be used for link prediction, where we want generalising the corpus to unseen sentences. By extending the grammar with the words "who" and "whom", we can use the same model to solve simple instances of question answering. As discussed in section 2.1.3, extending the grammar with anaphora which we interpret as spiders then allows to answer any conjunctive query.</p>
<p>Taking this DisCoCat-KGE analogy in the other direction, we can interpret knowledge graph embeddings as DisCoCat models. Take for example \({}^{1}\) the ComplEx model of Trouillon et al. [Tro+16; Tro+17],it is defined by a dimension \(d \in  \mathbb{N}\) , a (normalised) complex vector \({u}_{e} \in  {\mathbb{C}}^{d}\) for each entity \(e \in  E\) and a complex vector \({v}_{r} \in  {\mathbb{C}}^{d}\) for each relation \(r \in  R\) . Let us pack this into a dependent pair \(\theta  \in  \Theta  = \mathop{\coprod }\limits_{{d \in  \mathbb{N}}}{\mathbb{C}}^{d\left( {\left| E\right|  + \left| R\right| }\right) }\) . The interpretation of a triple \(f : {xry} \rightarrow  s\) is given by the scoring function \({T}_{\theta }\left( f\right)  = 2\operatorname{Re}\left( \left\langle  {{u}_{x},{v}_{r},{u}_{y}^{ \star  }}\right\rangle  \right)\) ,where \(\langle u,v,w\rangle  = \mathop{\sum }\limits_{{i \leq  d}}{u}_{i}{v}_{i}{w}_{i}\) is the tri-linear dot product, \({u}_{y}^{ \star  }\) is the element-wise conjugate,and 2Re takes twice \({}^{2}\) the real part of a complex number. We can reformulate this as the complex-valued DisCoCat model \({T}_{\theta } : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) given by \({T}_{\theta }\left( s\right)  = 1,{T}_{\theta }\left( n\right)  = {d}^{2}\) and:</p>
<!-- Media -->
<!-- figureText: \( \left| {{T}_{\theta }\left( e\right) }\right| \) \( {u}_{e} \) \( {u}_{e} \) \( {T}_{\theta }\left( r\right) \) and -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_206.jpg?x=277&#x26;y=1512&#x26;w=1170&#x26;h=146&#x26;r=0">
<!-- Media -->
<p>where we draw the conjugate of a vector as the horizontal reflection of its box. We can use the same spider trick as above to rewrite the trilinear product \(\left\langle  {{u}_{x},{v}_{r},{u}_{y}^{ \star  }}\right\rangle\) in terms of post-composition with a three-legged spider. We can also rewrite the real part of a scalar as half the sum with its conjugate \(2\operatorname{Re}\left( z\right)  = z + \bar{z}\) ,from which we get the desired meaning for sentences:</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) We focus on ComplEx,other examples of KGE as functors are treated in [Fel22,Section 2.6].</p>
<p>\({}^{2}\) We scale the original definition by 2 in order to avoid cluttering the diagrams with \(\frac{1}{2}\) scalars.</p>
<!-- Footnote -->
<hr><!-- Meanless: 208 2.2. DisCoCat models on quantum hardware-->
<!-- Media -->
<!-- figureText: \( {T}_{\theta }\left( x\right) \) \( {T}_{\theta }\left( r\right) \) \( \left| {{T}_{\theta }\left( y\right) }\right| \) \( {u}_{x} \) \( {u}_{x} \) \( {v}_{r} \) \( {u}_{y} \) \( {u}_{x} \) \( {u}_{x} \) \( {v}_{r} \) \( /\overline{{u}_{y}} \) \( {u}_{y} \) \( {u}_{y} \) \( {u}_{x} \) \( {v}_{r} \) - \( {u}_{x} \) \( {v}_{r} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_207.jpg?x=198&#x26;y=284&#x26;w=1164&#x26;h=401&#x26;r=0">
<!-- Media -->
<p>The meaning of a sentence \(f : {xry} \rightarrow  s\) is given by a real scalar which we interpret as true when \({T}_{\theta }\left( f\right)  \geq  0\) . In fact,any knowledge graph \(K : E \times  R \times  E \rightarrow  \{  \pm  1\}\) can be written as \(K = {T}_{\theta }\) ’s ign for the function sign : \(\mathbb{R} \rightarrow  \{  \pm  1\}\) [Tro+17,Theorem 4]. Furthermore,the dimension \(d \in  \mathbb{N}\) of the model can be bounded by the sign-rank of the matrices for each relation [Fel22, Proposition 2.5.17], with theoretical guarantees that \(d \ll  \left| E\right|\) if the problem is learnable efficiently [AMY16].</p>
<p>Hence, the knowledge graph embedding can be defined as a space of parameters \(\Theta\) together with a function \({T}_{ - } : \Theta  \rightarrow  \left\lbrack  {\mathbf{G},{\mathbf{{Mat}}}_{\mathbb{C}}}\right\rbrack\) which sends parameters \(\theta  \in  \Theta\) to functors \({T}_{\theta } : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) . Now if we are given a training set \(\Omega  \subseteq  E \times  R \times  E\) annotated by \(Y : \Omega  \rightarrow  \{  \pm  1\}\) for whether each triple belongs to the knowledge \({\mathrm{{graph}}}^{1}\) ,we want to find the parameters that best approximate the data:</p>
<p></p>\[{\theta }^{ \star  } = \underset{\theta  \in  \Theta }{\arg \min }\lambda \parallel \theta \parallel  + \mathop{\sum }\limits_{{f \in  \Omega }}\operatorname{loss}\left( {{T}_{\theta }\left( f\right) ,Y\left( f\right) }\right)\]<p></p>
<p>where \(\parallel \theta \parallel\) is a choice of norm (usually \({L}^{2}\) ) scaled by some regularisation hyper-parameter \(\lambda  \geq  0\) and loss \(: \mathbb{R} \times  \mathbb{R} \rightarrow  {\mathbb{R}}^{ + }\) is a choice of loss function,usually the negative log-likelihood of the logistic model \(\operatorname{loss}\left( {y,{y}^{\prime }}\right)  = \log \left( {1 + \exp \left( {-y{y}^{\prime }}\right) }\right)\) . If we fix the dimension \(d \in  \mathbb{N}\) (i.e. we take it as a hyper-parameter) we can use stochastic gradient descent to compute \({\theta }^{ \star  }\) and hence the optimal model \({T}_{{\theta }^{ \star  }} : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) . Using \({T}_{{\theta }^{ \star  }}\) to predict the value of triples \(f \in  \left( {E \times  R \times  E}\right)  - \Omega\) not seen during training, Trouillon et al. [Tro+16] obtained state-of-the-art results on standard benchmarks with both fewer parameters and a lower time complexity than competing models. Again if we extend the grammar with question words and anaphora, we can answer not only Boolean questions but any conjunctive query.</p>
<p>In the Grefenstette-Sadrzadeh implementation of DisCoCat models, we had to compute the meanings for nouns by some other means (e.g. from a co-occurrence matrix) then use a knowledge graph to lift these to the meaning for verbs. On the other hand, our KGE approach computes the meanings for all words simultaneously, using only samples from the knowledge graph as training data. Indeed, once reformulated as a DisCoCat model, training a knowledge graph embedding amounts to learning a functor \(F : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) given only access to pairs(f,a)such that \(F\left( f\right)  = a\) . Generalising this from subject-verb-object sentences to arbitrary grammars, Koziell-Pipe and the author [TK21] coined the term functorial learning for this approach to structured machine learning where we want to learn structure-preserving functors from data. We show how the approach can be extended, from a supervised learning task such as link prediction and question answering to unsupervised functorial language models, where we use a functor together with a probabilistic grammar to compute the probability of a missing word given its context. Together with Clark's recent progress in using transformer models for parsing [Cla21], functorial language models open the door to training large scale DisCoCat models end-to-end, i.e. from raw text to functor.</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) When the dataset contains only positive triples,it is common use the local closed world assumption where we randomly change either the subject or object to generate negative triples. This can be improved by adversarial sampling methods [CW18], akin to generative adversarial networks where we train a model to generate hard negative examples. In [Fel+20] we investigate how this can be formalised in terms of functorial language games.</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 209-->
<p>Functorial learning is part of the blooming field at the intersection of machine learning and category theory which is surveyed by Shiebler et al. [SGW21]. A starting point was the work of Fong et al. [FST19] on characterising backpropagation as functor into a category of learners, which was later formalised in terms of parameterised lenses [Cru+21, Lemma 2.13]. The idea of learning functors via gradient descent first appeared in the work of Gavranović [Gav19a; Gav19b], where the cyclic generative adversarial networks (cycleGAN) of Zhu et al. [Zhu+20] are reformulated as functors from a finitely presented category into a category of neural networks. However, there is some ambiguity in what it means exactly to learn a functor: in our approach, arrows in the domain category (i.e. diagrams generated by the grammar) encode the training data, whereas for Gavranović they encode the architecture of a neural network. In both cases however, we start from existing machine learning algorithms (ComplEx or cycleGAN), reformulate them in terms of functors before we can generalise them. In some cases, category theory does provide genuinely new learning algorithms, one example is the reverse derivative ascent of Wilson and Zanasi [WZ20] where the notion of reverse derivative category is used to generalise gradient descent to Boolean functions.</p><!-- Meanless: 210 2.2. DisCoCat models on quantum hardware-->
<h4>2.2.4 Variational quantum question answering</h4>
<p>The previous section introduced the idea of using gradient descent to learn DisCoCat models \(F : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) from data,we now discuss how to apply the same functorial learning approach in order to learn QNLP models \(F : \mathbf{G} \rightarrow\) Circ. There are two main challenges: 1) we need a way to load our model onto a quantum machine, i.e. encode word embeddings as parameterised quantum circuits, 2) we need a way to train the model, i.e. to compute the optimal parameters in some data-driven task. As we mentioned in section 2.2, we could solve the first challenge by post-composing a classical model \(F : \mathbf{G} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) with any choice of encoding load : \({\mathbf{{Mat}}}_{\mathbb{C}} \rightarrow\) Circ to get a QNLP model \({F}_{9}\) load : \(\mathbf{G} \rightarrow\) Circ. However,this would require circuits with depth exponential in the number of qubits, which are out of reach for the NISQ computers available today. Instead of learning classical vectors of parameters that we then encode as circuits, we introduce a variational quantum algorithm where we learn the parameters of quantum circuits directly. As for the second challenge, we cannot hope to backpropagate gradients through a quantum circuit in the same way as for classical neural networks. In this section we pick the easiest alternative: we treat our QNLP model as a black box and use a noisy optimisation algorithm such as the stochastic perturbation stochastic approximation (SPSA) of Spall [Spa98]. In the next section, we will open the black box and introduce diagrammatic differentiation in order to use the quantum circuits to compute their own gradients.</p>
<p>Our variational algorithm may be summarised in the following recipe for a parameterised circuit-valued functor.</p>
<ol>
<li>
<p>Fix a pregroup grammar \(G = \left( {V,X,D,s}\right)\) and use it to parse a dataset \(\Omega  \subseteq  \mathop{\coprod }\limits_{{{w}_{1}\ldots {w}_{n} \in  {V}^{ \star  }}}\mathbf{G}\left( {{w}_{1}\ldots {w}_{n},s}\right)\) of sentences then annotate them with truth values \(Y : \Omega  \rightarrow  \mathbb{R}\) .</p>
</li>
<li>
<p>Fix a hyper-parameter \(F\left( x\right)  \in  \mathbb{N}\) for the number of qubits representing each basic type \(x \in  X\) . For simplicity,we will assume that \(F\left( s\right)  = 0\) so that sentences are represented as closed circuits.</p>
</li>
<li>
<p>Choose an ansatz for each dictionary entry \(\left( {w,t}\right)  \in  D\) ,i.e. a function \({F}_{ - }\left( {w,t}\right)  : {\Theta }_{\left( w,t\right) } \rightarrow  \operatorname{Circ}\left( {0,F\left( t\right) }\right)\) from some space of parameters \({\Theta }_{\left( w,t\right) }\) to the set of \(F\left( t\right)\) -qubit circuits. Ideally,we want an ansatz that is shallow enough to run on NISQ machines but still hard to approximate classically, such as the instantaneous quantum polynomials (IQP) of Shepherd and Bremner [SB09]. A more practical choice is to use a hardware-efficient ansatz such as that of</p>
</li>
</ol><!-- Meanless: 2. Quantum natural language processing 211-->
<p>Kandala et al. [Kan+17], where we essentially squeeze as many parameters as possible out of whatever hardware we can get our hands on.</p>
<p>As in the previous section, we can abstract these choices away into one big parameter space \(\Theta  = \mathop{\prod }\limits_{{\left( {w,t}\right)  \in  D}}{\Theta }_{\left( w,t\right) }\) and a function \({F}_{ - } : \Theta  \rightarrow  \left\lbrack  {\mathbf{G},\mathbf{{Circ}}}\right\rbrack\) from parameters to functors. We can now use SPSA (or any noisy optimisation algorithm of our choice) to approximate the optimal parameters:</p>
<p></p>\[{\theta }^{ \star  } = \underset{\theta  \in  \Theta }{\arg \min }\lambda \parallel \theta \parallel  + \mathop{\sum }\limits_{{f \in  \Omega }}\operatorname{loss}\left( {\operatorname{eval}\left( {F\left( f\right) }\right) ,Y\left( f\right) }\right)\]<p></p>
<p>where eval : \(\operatorname{Circ}\left( {0,0}\right)  \rightarrow  \mathbb{R}\) takes closed circuits and returns the result of evaluating them either using a classical simulation or a quantum device.</p>
<p>We can now evaluate the optimal functor \({F}_{{\theta }^{ \star  }} : \mathbf{G} \rightarrow  \mathbf{{Circ}}\) on unseen sentences, or equivalently answer Boolean questions. This variational approach to question answering was first demonstrated in a classical simulation by \(\mathrm{{Ma}}\) et al. \(\left\lbrack  {\mathrm{{Ma}} + {19}}\right\rbrack\) in the restricted case of knowledge graphs, i.e. subject-verb-object sentences. Because the circuits were simulated classically it was possible to use standard gradient descent, with results comparable to the state-of-the-art. The first NLP experiment on quantum hardware to appear in print was \(\left\lbrack  {\mathrm{{Mei}} + {20}\mathrm{\;b}}\right\rbrack\) ,where we used functorial learning to solve a toy question-answering task on a Shakespeare-inspired dataset. We used SPSA for the optimisation and the snake removal functor defined in example 2.2.10 to simplify the circuits of sentences with relative pronouns like "Romeo who loves Juliet dies". Although this first experiment answered only yes-no questions,the same framework can be applied to \({wh}\) -questions,with Grover’s algorithm yielding a quadratic speedup [CMS22]. This functorial learning pipeline was then applied on a larger dataset by Lorenz et al. [Lor+21], demonstrating the convergence of the model and its statistical significance over a random baseline. The pipeline was packaged into its own Python library, lambeq [Kar+21], which builds upon DisCoPy and state-of-the art parsers. It has also been adapted from question-answering to machine translation [Abb+21; Vic21], word-sense disambiguation [Hof21] and even to generative music [Mir+21].</p>
<h3>2.3 Diagrammatic differentiation</h3>
<p>In this section, we introduce diagrammatic differentiation: a graphical notation for computing the derivatives of parameterised diagrams. On the theoretical side, we generalise the dual number construction from rigs to monoidal categories (section 2.3.1). We then apply this construction to the category of ZX diagrams (section 2.3.2) and of quantum circuits (section 2.3.3). In section 2.3.4 we define the gradient of diagrams with bubbles in terms of the chain rule. We use this to differentiate quantum circuits with neural networks as classical post-processing. The theory comes with a DisCoPy implementation, gradients of classical-quantum circuits can then be simplified using the PyZX library [KvdW19], compiled and executed on quantum hardware with \(\mathrm{t} \mid  \mathrm{{ket}}\rangle\) [Siv+20].</p><!-- Meanless: 212 2.3. Diagrammatic differentiation-->
<h2>Related Work</h2>
<p>Penrose and Rindler [PR84] used string diagrams to describe the geometry of space-time and an extra piece of notation is introduced: the covariant derivative is represented as a bubble around the tensor to be differentiated. The same bubble notation for vector calculus has been proposed by Kim et al. [KOK20], but they have mainly pedagogical motivations and restrict themselves to the case of three-dimensional Euclidean space. To the best of our knowledge, our definition is the first formal account of string diagrams with bubbles for derivatives.</p>
<p>Blute et al. [BCS06] axiomatised the notion of derivative with differential categories. More recently Cockett et al. [Coc+19] generalised the notion of back-propagation with reverse derivative categories, which have been proposed as a categorical foundation for gradient-based learning [Cru+21]. These frameworks all define the derivative of a morphism with respect to its domain. In our setup however, we define the derivative of parametrised morphisms with respect to parameters that are in some sense external to the category. Investigating the relationship between these two definitions is left to future work.</p>
<p>The work presented in this section has its origin in Yeung's dissertation [Yeu20], which focused on the diagrammatic differentiation of ansätze used in quantum machine learning. In joint work with Yeung and de Felice [TYF21], we gave this approach both its theoretical basis and its first implementation. Wang and Yeung [WY22] later generalised it from differentiation to the integration of ZX diagrams. They also resolve a technical limitation of our approach: they show how to express any formal sum of ZX diagrams in terms of one diagram. The same idea appeared independently in Jeandel et al. [JPV22], who also show how to apply our diagrammatic differentiation method to the Ising Hamiltonian, a key ingredient to many variational quantum algorithms [Had21].</p><!-- Meanless: 2. Quantum natural language processing 213-->
<h4>2.3.1 Dual diagrams</h4>
<p>Dual numbers were first introduced by Clifford [Cli73], they are a fundamental tool for automatic differentiation [Hof16], i.e. they allow to compute the derivative of a function automatically from its definition.</p>
<p>Given a commutative rig \(\mathbb{S}\) ,the rig of dual numbers \(\mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack\) extends \(\mathbb{S}\) by adjoining a new element \(\epsilon\) such that \({\epsilon }^{2} = 0\) . Abstractly, \(\mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack   = \mathbb{S}\left\lbrack  x\right\rbrack  /{x}^{2}\) is a quotient of the rig of polynomials with coefficients in \(\mathbb{S}\) . Concretely,elements of \(\mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack\) are formal sums \(s + {s}^{\prime }\epsilon\) where \(s\) and \({s}^{\prime }\) are scalars in \(\mathbb{S}\) . We write \({\pi }_{0},{\pi }_{1} : \mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack   \rightarrow  \mathbb{S}\) for the projection on the real and epsilon component respectively. Addition and multiplication of dual numbers are given by:</p>
<p></p>\[\left( {a + {a}^{\prime }\epsilon }\right)  + \left( {b + {b}^{\prime }\epsilon }\right)  = \left( {a + b}\right)  + \left( {a + {b}^{\prime }}\right) \epsilon  \tag{2.1}\]<p></p>
<p></p>\[\left( {a + {a}^{\prime }\epsilon }\right)  \times  \left( {b + {b}^{\prime }\epsilon }\right)  = \left( {a \times  b}\right)  + \left( {a \times  {b}^{\prime } + {a}^{\prime } \times  b}\right) \epsilon  \tag{2.2}\]<p></p>
<p>A related notion is that of differential rig: a rig \(\mathbb{S}\) equipped with a derivation, i.e. a map \(\partial  : \mathbb{S} \rightarrow  \mathbb{S}\) which preserves sums and satisfies the Leibniz product rule \(\partial \left( {f \times  g}\right)  = f \times  \partial \left( g\right)  + \partial \left( f\right)  \times  g\) for all \(f,g \in  \mathbb{S}\) . An equivalent condition is that the map \(f \mapsto  f + \left( {\partial f}\right) \epsilon\) is a homomorphism of rigs \(\mathbb{S} \rightarrow  \mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack\) . The correspondance also works the other way around: given a homorphism \(\partial  : \mathbb{S} \rightarrow  \mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack\) such that \({\pi }_{0} \circ  \partial  = {\operatorname{id}}_{\mathbb{S}}\) ,projecting on the epsilon component is a derivation \({\pi }_{1} \circ  \partial  : \mathbb{S} \rightarrow  \mathbb{S}\) . The motivating example is the rig of smooth functions \(\mathbb{S} = \mathbb{R} \rightarrow  \mathbb{R}\) ,where differentiation is a derivation. Concretely,we can extend any smooth function \(f : \mathbb{R} \rightarrow  \mathbb{R}\) to a function \(f : \mathbb{D}\left\lbrack  \mathbb{R}\right\rbrack   \rightarrow  \mathbb{D}\left\lbrack  \mathbb{R}\right\rbrack\) over the dual numbers defined by:</p>
<p></p>\[f\left( {a + {a}^{\prime }\epsilon }\right)  = f\left( a\right)  + {a}^{\prime } \times  \left( {\partial f}\right) \left( a\right) \epsilon  \tag{2.3}\]<p></p>
<p>We can use equations 2.1, 2.2 and 2.3 to derive the usual rules for gradients in terms of dual numbers. For the identity function we have \(\operatorname{id}\left( {a + {a}^{\prime }\epsilon }\right)  = \operatorname{id}\left( a\right)  + {a}^{\prime }\epsilon\) , i.e. \(\partial \mathrm{{id}} = 1\) . For the constant functions we have \(c\left( {a + {a}^{\prime }\epsilon }\right)  = c\left( a\right)  + {0\epsilon }\) ,i.e. \(\partial c = 0\) . For addition,multiplication and composition of functions,we can derive the following linearity, product and chain rules:</p>
<p></p>\[\left( {f + g}\right) \left( {a + {a}^{\prime }\epsilon }\right)  = \left( {f + g}\right) \left( a\right)  + {a}^{\prime } \times  \left( {\partial f + \partial g}\right) \left( a\right) \epsilon  \tag{2.4}\]<p></p>
<p></p>\[\left( {f \times  g}\right) \left( {a + {a}^{\prime }\epsilon }\right)  = \left( {f \times  g}\right) \left( a\right)  + {a}^{\prime } \times  \left( {f \times  \partial g + \partial f \times  g}\right) \left( a\right) \epsilon  \tag{2.5}\]<p></p>
<p></p>\[\left( {f \circ  g}\right) \left( {a + {a}^{\prime }\epsilon }\right)  = \left( {f \circ  g}\right) \left( a\right)  + {a}^{\prime } \times  \left( {\partial g \times  \partial f \circ  g}\right) \left( a\right) \epsilon  \tag{2.6}\]<p></p><!-- Meanless: 214 2.3. Diagrammatic differentiation-->
<p>This generalises to smooth functions \({\mathbb{R}}^{n} \rightarrow  {\mathbb{R}}^{m}\) ,where the partial derivative \({\partial }_{i}\) is a derivation for each \(i &#x3C; n\) . The functions \({\mathbb{F}}_{2}^{n} \rightarrow  {\mathbb{F}}_{2}^{m}\) on the two-element field \({\mathbb{F}}_{2}\) with elementwise XOR as sum and conjunction as product also forms a differential rig. The partial derivative is given by \(\left( {{\partial }_{i}f}\right) \left( \overrightarrow{x}\right)  = f\left( {\overrightarrow{x}}_{\left\lbrack  {x}_{i} \mapsto  0\right\rbrack  }\right)  \oplus  f\left( {\overrightarrow{x}}_{\left\lbrack  {x}_{i} \mapsto  1\right\rbrack  }\right)\) . Intuitively,the \({\mathbb{F}}_{2}\) gradient \({\partial }_{i}f\left( \overrightarrow{x}\right)  \in  {\mathbb{F}}_{2}^{m}\) encodes which coordinates of \(f\left( \overrightarrow{x}\right)\) actually depend on the input \({x}_{i}\) . An example of differential rig that isn’t also a ring is given by the set \(\mathbb{N}\left\lbrack  X\right\rbrack\) of polynomials with natural number coefficients,again each partial derivative is a derivation.</p>
<p>A more exotic example is the rig of Boolean functions with elementwise disjunction as sum and conjunction as product. Boolean functions \({\mathbb{B}}^{n} \rightarrow  {\mathbb{B}}^{m}\) can be represented as tuples of \(m\) propositional formulae over \(n\) variables. The partial derivative \({\partial }_{i}\) for \(i &#x3C; n\) is defined by induction over the formulae: for variables we have \({\partial }_{i}{x}_{j} = {\delta }_{ij}\) ,for constants \({\partial }_{i}0 = {\partial }_{i}1 = 0\) and for negation \({\partial }_{i}\neg \phi  = \neg {\partial }_{i}\phi\) . The derivative of disjunctions and conjunctions are given by the linerarity and product rules. Equivalently, the gradient of a propositional formula can be given by \({\partial }_{i}\phi  = \neg {\phi }_{\left\lbrack  {x}_{i} \mapsto  0\right\rbrack  } \land  {\phi }_{\left\lbrack  {x}_{i} \mapsto  1\right\rbrack  }\) . Concretely,a model satisfies \({\partial }_{i}\phi\) if and only if it satisfies \(\phi  \leftrightarrow  {x}_{i}\) : the derivative is true when the variable and the formula are positively correlated. Substituting \({x}_{i}\) with its negation,we get that a model satisfies \({\partial }_{i}{\phi }_{\left\lbrack  {x}_{i} \mapsto  \neg {x}_{i}\right\rbrack  }\) if and only if it satisfies \(\phi  \leftrightarrow  \neg {x}_{i}\) ,i.e. iff variable and formula are anti-correlated. Note that although \(\mathbb{B}\) and \({\mathbb{F}}_{2}\) are isomorphic as sets,they are distinct rigs. Their derivations are related however by \({\partial }_{i}^{{\mathbb{F}}_{2}}f \mapsto  {\partial }_{i}^{\mathbb{B}}\phi  \vee  {\partial }_{i}^{\mathbb{B}}{\phi }_{\left\lbrack  {x}_{i} \mapsto  \neg {x}_{i}\right\rbrack  }\) for \(\phi  : {\mathbb{B}}^{n} \rightarrow  \mathbb{B}\) the formula corresponding to the function \(f : {\mathbb{F}}_{2}^{n} \rightarrow  {\mathbb{F}}_{2}\) . That is,a Boolean function depends on an input variable precisely when either the corresponding formula is positively correlated or anti-correlated.</p>
<p>Our main technical contribution is to generalise dual numbers and derivations from rigs to monoidal categories with sums. Given a monoidal category \(C\) with sums (i.e. enriched in commutative monoids),we define the category \(\mathbb{D}\left\lbrack  C\right\rbrack\) by adjoining a scalar (i.e. an endomorphism of the monoidal unit) \(\epsilon\) and quotienting \({\text{by}}^{1}\epsilon  \otimes  \epsilon  = 0\) . Concretely,the objects of \(\mathbb{D}\left\lbrack  C\right\rbrack\) are the same as those of \(C\) ,the arrows are given by formal sums \(f + {f}^{\prime }\epsilon\) of parallel arrows \(f,{f}^{\prime } \in  C\) . Composition and tensor are both given by the product rule:</p>
<p></p>\[\left( {f + {f}^{\prime }\epsilon }\right) \mathring{} \left( {g + {g}^{\prime }\epsilon }\right)  = f\mathring{} g + \left( {{f}^{\prime }\mathring{} g + f\mathring{} {g}^{\prime }}\right) \epsilon  \tag{2.7}\]<p></p>
<p></p>\[\left( {f + {f}^{\prime }\epsilon }\right)  \otimes  \left( {g + {g}^{\prime }\epsilon }\right)  = f \otimes  g + \left( {{f}^{\prime } \otimes  g + f \otimes  {g}^{\prime }}\right) \epsilon  \tag{2.8}\]<p></p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) In the case when \(C\) is not braided we also require the axiom \(\epsilon  \otimes  f = f \otimes  \epsilon\) .</p>
<!-- Footnote -->
<hr><!-- Meanless: 2. Quantum natural language processing 215-->
<p>We say that a unary operator on homsets \(\partial  : { \coprod  }_{x,y}C\left( {x,y}\right)  \rightarrow  C\left( {x,y}\right)\) is a derivation whenever it satisfies the product rules for both composition \(\partial \left( {f,g}\right)  =\) \(\left( {\partial f}\right) \mathring{} g + f\mathring{} \left( {\partial g}\right)\) and tensor \(\partial \left( {f \otimes  g}\right)  = \left( {\partial f}\right)  \otimes  g + f \otimes  \left( {\partial g}\right)\) . An equivalent condition is that the map \(f \mapsto  f + \left( {\partial f}\right) \epsilon\) is a sum-preserving monoidal functor \(C \rightarrow  \mathbb{D}\left\lbrack  C\right\rbrack\) . Again,the correspondance between dual numbers and derivations works the other way around: given a sum-preserving monoidal functor \(\partial  : C \rightarrow  \mathbb{D}\left\lbrack  C\right\rbrack\) such that \({\pi }_{0} \circ  \partial  = {\operatorname{id}}_{C}\) ,projecting on the epsilon component gives a derivation \({\pi }_{1} \circ  \partial\) : \({ \coprod  }_{x,y}C\left( {x,y}\right)  \rightarrow  C\left( {x,y}\right)\) . The following propositions characterise the derivations on the category of matrices valued in a commutative rig \(\mathbb{S}\) .</p>
<p>Proposition 2.3.1. Dual matrices are matrices of dual numbers, i.e. we have \(\mathbb{D}\left\lbrack  {\mathbf{{Mat}}}_{\mathbb{S}}\right\rbrack   \simeq  {\mathbf{{Mat}}}_{\mathbb{D}\left\lbrack  \mathbb{S}\right\rbrack  }\) for all commutative rigs \(\mathbb{S}\) .</p>
<p>Proof. The isomorphism is given by</p>
<p></p>\[\left( {\mathop{\sum }\limits_{{ij}}{f}_{ij}\left| {j\rangle \langle i}\right| }\right)  + \left( {{f}_{ij}^{\prime }\mathop{\sum }\limits_{{ij}}\left| {j\rangle \langle i}\right| }\right) \epsilon  \leftrightarrow  \mathop{\sum }\limits_{{ij}}\left( {{f}_{ij} + {f}_{ij}^{\prime }\epsilon }\right) \left| {j\rangle \langle i}\right|\]<p></p>
<p>Proposition 2.3.2. Derivations on \({\mathbf{{Mat}}}_{\mathbb{S}}\) are in one-to-one correspondance with derivations on \(\mathbb{S}\) .</p>
<p>Proof. A derivation on \({\mathbf{{Mat}}}_{\mathbb{S}}\) is uniquely determined by its action on scalars in \(\mathbb{S}\) . Conversely,applying a derivation \(\partial  : \mathbb{S} \rightarrow  \mathbb{S}\) entrywise on matrices yields a derivation on \({\mathbf{{Mat}}}_{\mathbb{S}}\) .</p>
<p>DisCoPy implements parameterised matrices with SymPy [Meu+17] expressions as entries. The method Tensor. grad takes a SymPy variable and applies element-wise symbolic differentiation. Tensor.grad \(=\) grad</p>
<!-- Media -->
<p>Listing 2.3.3. Implementation of gradients of parameterised tensors with SymPy.</p>
<hr>
<p>def grad(self: Tensor[sympy.Expr], var: sympy.Symbol):
return self.map(lambda x: x.diff(var))</p>
<hr>
<!-- Media -->
<p>Example 2.3.4. We can check the product rule for tensor and composition of matrices.</p>
<hr>
<pre><code>x = sympy. Symbol \( \left( {{}^{\prime }{x}^{\prime }}\right) \)
</code></pre>
<p>f = Tensor([[x + 1, 2 * x], [x ** 2, 1 / x ]], [2], [2])</p><!-- Meanless: 216 2.3. Diagrammatic differentiation-->
<p>g = Tensor([[1, 2], [2 * x, -1 / x ** 2]], [2], [2])
assert f.grad \(\left( \mathrm{x}\right)  =  = \mathrm{g}\)
assert (f @ g).grad(x) == f.grad(x) @ g + f @ g.grad(x)
assert (f >> g).grad(x) == f.grad(x) >> g + f >> g.grad(x)</p>
<hr>
<p>Fix a monoidal signature \(\sum\) and let \({C}_{\sum }^{ + }\) be the free monoidal category with sums that it generates, i.e. arrows are formal sums of diagrams as defined in sections 1.1.3 and 1.2.4. We assume our diagrams are interpreted as matrices, i.e. we fix a sum-preserving monoidal functor \(\llbracket  - \rrbracket  : {C}_{\sum }^{ + } \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) for \(\mathbb{S}\) a commutative rig with a derivation \(\partial  : \mathbb{S} \rightarrow  \mathbb{S}\) . Our main two examples are the ZX-calculus of Coecke and Duncan [CD08] with smooth functions \({\mathbb{R}}^{n} \rightarrow  \mathbb{R}\) as phases and the algebraic ZX-calculus over \(\mathbb{S}\) ,introduced by Wang [Wan20]. Applying the dual number construction to \({C}_{\sum }^{ + }\) ,we get the category of dual diagrams \(\mathbb{D}\left\lbrack  {C}_{\sum }^{ + }\right\rbrack\) which is where diagrammatic differentiation happens. By the universal property of \({C}_{\sum }^{ + }\) ,every derivation \(\partial  : {C}_{\sum }^{ + } \rightarrow  \mathbb{D}\left\lbrack  {C}_{\sum }^{ + }\right\rbrack\) is uniquely determined by its image on the generating boxes in \({\sum }_{1}\) . Intuitively,if we’re given the derivative for each box,we can compute the derivative for every sum of diagram using the product rule.</p>
<p>We say that the interpretation \(\llbracket  - \rrbracket  : {C}_{\sum }^{ + } \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) admits diagrammatic differentiation if there is a derivation \(\partial\) on \({C}_{\sum }^{ + }\) such that \(\llbracket  - \rrbracket  \circ  \partial  = \partial  \circ  \llbracket  - \rrbracket\) . That is,the interpretation of the gradient \(\llbracket \partial d\rrbracket\) coincides with the gradient of the interpretation \(\partial \llbracket d\rrbracket\) for all sums of diagrams \(d \in  {C}_{\sum }^{ + }\) . We depict the gradient \(\partial d\) as a bubble surrounding the diagram \(d\) ,as discussed in sections 1.1.3 and 1.2.4. Once translated to string diagrams, the axioms for derivations on monoidal categories with sums become:</p>
<!-- Media -->
<!-- figureText: 0 0 \( f \) \( g \) 0 \( f \) \( g \) \( f \) \( f \) \( f \) \( g \) 0 0 \( g \) \( f \) \( g \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_215.jpg?x=247&#x26;y=1501&#x26;w=1070&#x26;h=660&#x26;r=0">
<!-- Media --><!-- Meanless: 2. Quantum natural language processing 217-->
<p>We implement dual diagrams with a method Diagram. grad which takes SymPy variables and returns formal sums of diagrams by applying the product rules for tensor and composition. By default, we assume that boxes are constant, i.e. their gradient is the empty sum.</p>
<!-- Media -->
<p>Listing 2.3.5. Implementation of dual diagrams.</p>
<hr>
<p>Box.grad = lambda self, var: Sum ([], self.dom, self.cod)
def grad(self: Diagram, var: sympy.Symbol):
if len ( self ) == 0: return Sum ( [ ] , self.dom, self.cod)
left, box, right = self.layers[0]
return left @ box.grad(var) @ right >> self[1:] \
+ left @ box @ right >> self[1:].grad(var)
Diagram.grad = grad</p>
<hr>
<!-- Media -->
<p>Example 2.3.6. We can override the default grad method and check the product rule for diagrams.</p>
<!-- Media -->
<hr>
<p>class DataBox (Box):
def <em><strong><strong>init</strong></strong></em>(self, name: str, dom: Ty, cod: Ty, data: sympy.Expr) :
self.data = data
super(   ).<strong>init</strong>(name, dom, cod)
def <em><strong><strong>eq</strong></strong></em> (self, other):
if not isinstance(other, DataBox): return super(   ).<em>eq</em>____(other)
return super(   ).<em><strong><strong>eq</strong></strong></em>(other) and self.data == other.data
def grad(self, var):
return DataBox ( self.name, self.dom, self.cod, self.data.diff(var ) )
phi = sympy. Symbol ( '\\phi ' )
\(\mathrm{x},\mathrm{y},\mathrm{z} = \operatorname{map}\left( {\mathrm{{Ty}},\text{"xyz"}}\right)\)
f, g = DataBox('f', x, y, phi ** 2), DataBox('g', y, z, 1 / phi)
assert (f @ g).grad(phi) == f.grad(phi) @ g + f @ g.grad(phi)
assert (f >> g).grad(phi) == f.grad(phi) >> g + f >> g.grad(phi)</p>
<hr>
<!-- Media -->
<h4>2.3.2 Differentiating the ZX-calculus</h4>
<p>This section applies the dual number construction to the diagrams of the ZX-calculus with smooth functions \(\alpha  : {\mathbb{R}}^{n} \rightarrow  \mathbb{R}\) as phases. For each number of variables \(n \in  \mathbb{N}\) , we define \({\mathbf{{ZX}}}_{n}\) as the free symmetric category generated by the signature:</p><!-- Meanless: 218 2.3. Diagrammatic differentiation-->
<p>\({\sum }_{0} = \{ x\}\) and \({\sum }_{1} = \{ H : x \rightarrow  x\}  + \left\{  {{Z}^{m,n}\left( \alpha \right)  : {x}^{\otimes m} \rightarrow  {x}^{\otimes n} \mid  m,n \in  \mathbb{N},\alpha  : {\mathbb{R}}^{n} \rightarrow  \mathbb{R}}\right\}\)</p>
<p>where \(H\) is depicted as a yellow box and \({Z}^{m,n}\left( \alpha \right)\) as a green spider. The red spider is syntactic sugar for a green spider with yellow boxes connected to each leg. The interpretation \(\left\lbrack  -\right\rbrack   : {\mathbf{{ZX}}}_{n} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) in matrices over \(\mathbb{S} = {\mathbb{R}}^{n} \rightarrow  \mathbb{C}\) is given by on objects by \(\llbracket x\rrbracket  = 2\) and on arrows by \(\llbracket H\rrbracket  = \frac{1}{\sqrt{2}}\left( {\left| {0\rangle \langle 0}\right|  + \left| {0\rangle \langle 1}\right|  + \left| {1\rangle \langle 0}\right|  - \left| {1\rangle \langle 1}\right| }\right)\) and \(\llbracket {Z}^{m,n}\left( \alpha \right) \rrbracket  = {e}^{-{i\alpha }/2}\left| {0{\rangle }^{\otimes n}\langle 0{\left| {}^{\otimes m} + {e}^{{i\alpha }/2} \mid  1{\rangle }^{\otimes n}\langle 1\right| }^{\otimes m}}\right|\) . Note that we’ve scaled the standard interpretation of the green spider by a global phase to match the usual definition of rotation gates in quantum circuits. For \(n = 0\) we get \({\mathbf{{ZX}}}_{0} = \mathbf{{ZX}}\) the ZX-calculus with no parameters. By currying,any ZX diagram \(d \in  {\mathbf{{ZX}}}_{n}\) can be seen as a function \(d : {\mathbb{R}}^{n} \rightarrow  \operatorname{Ar}\left( \mathbf{{ZX}}\right)\) such that \(\llbracket  - \rrbracket  \circ  d : {\mathbb{R}}^{n} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{C}}\) is smooth.</p>
<p>Lemma 2.3.7. A function \(s : {\mathbb{R}}^{n} \rightarrow  \mathbb{C}\) can be drawn as a scalar diagram in \({\mathbf{{ZX}}}_{n}\) if and only if it is bounded.</p>
<p>Proof. Generalising [CK17,P. 8.101] to parametrised scalars,if there is a \(k \in  \mathbb{N}\) with \(\left| {s\left( \theta \right) }\right|  \leq  {2}^{k}\) for all \(\theta  \in  {\mathbb{R}}^{n}\) then there are parametrised phases \(\alpha ,\beta  : {\mathbb{R}}^{n} \rightarrow  \mathbb{R}\) such that</p>
<!-- Media -->
<!-- figureText: \( \mathop{\prod }\limits_{\left( \alpha \right) }\overset{⏜}{\left( -\beta \right) }\overset{⏜}{\left( \beta \right) } ○ \underset{k}{\ldots } ○  = s \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_217.jpg?x=498&#x26;y=1242&#x26;w=569&#x26;h=140&#x26;r=0">
<!-- Media -->
<p>In the other direction,take any scalar diagram \(d\) in \({\mathbf{{ZX}}}_{n}\) . Let \(k\) be the number of spider in the diagram and \(l\) the maximum number of legs. By decomposing each spider as a sum of two disconnected diagrams,we can write \(d\) as a sum of \({2}^{k}\) diagrams. Each term of the sum is a product of at most \(\frac{1}{2} \times  k \times  l\) bone-shaped scalars. Each bone is bounded by 2,thus \(\llbracket d\rrbracket  : {\mathbb{R}}^{n} \rightarrow  \mathbb{C}\) is bounded by \({2}^{k \times  l}\) .</p>
<p>Lemma 2.3.8. In \({\mathbf{{ZX}}}_{n}\) ,we have \(\left( \alpha \right)  = \frac{\partial \alpha }{2}\left( {\alpha  + \pi }\right)\) for all affine \(\alpha  : {\mathbb{R}}^{n} \rightarrow  \mathbb{R}\) .</p>
<p>Proof. Because \(\alpha\) is affine we have that \(\partial \alpha\) is constant,hence bounded and from lemma 2.3.7 we know it can be drawn in \({\mathbf{{ZX}}}_{n}\) .</p>
<p></p>\[\partial \llbracket Z\left( \alpha \right) \rrbracket  = \partial \left( {{e}^{-{i\alpha }/2}\left| {0\rangle  + {e}^{{i\alpha }/2}}\right| 1\rangle }\right)\]<p></p>
<p></p>\[= \frac{i\partial \alpha }{2}\left( {-{e}^{-{i\alpha }/2}\left| {0\rangle  + {e}^{{i\alpha }/2}}\right| 1\rangle }\right)\]<p></p>
<p></p>\[= \frac{\partial \alpha }{2}\left( {{e}^{-i\frac{\alpha  + \pi }{2}}\left| {0\rangle  + {e}^{i\frac{\alpha  + \pi }{2}}}\right| 1\rangle }\right)\]<p></p><!-- Meanless: 2. Quantum natural language processing 219-->
<p>Theorem 2.3.9. The ZX-calculus with affine maps \({\mathbb{R}}^{n} \rightarrow  \mathbb{R}\) as phases admits diagrammatic differentiation.</p>
<p>Proof. The Hadamard \(H\) has derivative zero. For the green spiders,we can extend lemma 2.3.8 from single qubit rotations to arbitrary many legs using spider fusion:</p>
<!-- Media -->
<!-- figureText: \( \alpha \) \( \alpha \) \( \alpha  + \pi \) \( \alpha  + \pi \) \( \frac{\partial \alpha }{2} \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_218.jpg?x=283&#x26;y=604&#x26;w=1150&#x26;h=261&#x26;r=0">
<!-- Media -->
<p>Note that there is no diagrammatic differentiation for the ZX-calculus with smooth maps as phases, even when restricted to bounded functions. Take for example \(\alpha  : \mathbb{R} \rightarrow  \mathbb{R}\) with \(\alpha \left( \theta \right)  = \sin {\theta }^{2}\) ,it is smooth and bounded by 1 but its derivative \(\partial \alpha\) is unbounded. Thus,from lemma 2.3.7 we know it cannot be represented as a scalar diagram in \({\mathbf{{ZX}}}_{1}\) : there can be no diagrammatic differentiation \(\partial  : {\mathbf{{ZX}}}_{1} \rightarrow  \mathbb{D}\left\lbrack  {\mathbf{{ZX}}}_{1}\right\rbrack\) . In such cases,we can always extend the signature by adjoining a new box for each derivative.</p>
<p>Proposition 2.3.10. For every interpretation \(\llbracket  - \rrbracket  : {C}_{\sum }^{ + } \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) ,there is an extended signature \({\sum }^{\prime } \supset  \sum\) and interpretation \(\llbracket  - \rrbracket  : {C}_{{\sum }^{\prime }}^{ + } \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) such that \({C}_{{\sum }^{\prime }}^{ + }\) admits digrammatic differentiation.</p>
<p>Proof. Let \({\sum }^{\prime } = { \cup  }_{n \in  \mathbb{N}}{\sum }^{n}\) where \({\sum }^{0} = \sum\) and \({\sum }^{n + 1} = {\sum }^{n} \cup  \left\{  {\partial f \mid  f \in  {\sum }^{n}}\right\}\) with \(\left\lbrack  {\partial f}\right\rbrack   = \partial \left\lbrack  f\right\rbrack  .\)</p>
<p>The issue of being able to represent arbitrary scalars disappears if we work with the algebraic ZX-calculus instead. Furthermore, we can generalise from \(\mathbb{S} = {\mathbb{R}}^{n} \rightarrow  \mathbb{C}\) to any commutative rig. We define the category \({\mathbf{{ZX}}}_{\mathbb{S}}\) as the free symmetric category generated by the signature given in [Wan20, Table 2] and the interpretation \(\left\lbrack  -\right\rbrack   : {\mathbf{{ZX}}}_{\mathbb{S}} \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\) given in \(\left\lbrack  {\text{Wan20,}\$ 6}\right\rbrack\) . In particular,there is a green square \({R}_{Z}^{m,n}\left( a\right)  \in  {\sum }_{1}\) for each \(a \in  \mathbb{S}\) and \(m,n \in  \mathbb{N}\) with interpretation</p>
<p></p>\[\left\lbrack  {{R}_{Z}^{m,n}\left( a\right) }\right\rbrack   = {\left| 0{\rangle }^{\otimes n}\langle 0\right| }^{\otimes m} + a{\left| 1{\rangle }^{\otimes n}\langle 1\right| }^{\otimes m}\]<p></p>
<p>Let \({\mathbf{{ZX}}}_{\mathbb{S}}^{ + }\) be the category of formal sums of algebraic \(\mathrm{{ZX}}\) diagrams over \(\mathbb{S}\) .</p><!-- Meanless: 220 2.3. Diagrammatic differentiation-->
<p>Theorem 2.3.11. Diagrammatic derivations for the interpretation \(\llbracket  - \rrbracket  : {\mathbf{{ZX}}}_{\mathrm{S}}^{ + } \rightarrow\) \({\mathbf{{Mat}}}_{\mathbb{S}}\) are in one-to-one correspondance with rig derivations \(\partial  : \mathbb{S} \rightarrow  \mathbb{S}\) .</p>
<p>Proof. Given a derivation \(\partial\) on \(\mathbb{S}\) ,we have \(\partial \llbracket {R}_{Z}^{m,n}\left( a\right) \rrbracket  = \left( {\partial a}\right) |1{\rangle }^{\otimes n}\langle 1{|}^{\otimes m}\) and \(\partial a\) can be represented by the scalar diagram \({R}_{Z}^{1,0}\left( {\partial a}\right) |1\rangle\) . In the other direction,a diagrammatic derivation \(\partial\) on \({\mathbf{{ZX}}}_{\mathbb{S}}^{ + }\) is uniquely determined by its action on scalars \({R}_{Z}^{1,0}\left( a\right) |1\rangle\) for \(a \in  \mathbb{S}\) .</p>
<p>One application of diagrammatic differentiation is to solve differential equations between diagrams. As a first step, we apply Stone's theorem [Sto32] on one-parameter unitary groups to the ZX-calculus.</p>
<p>Definition 2.3.12. A one-parameter unitary group is a unitary matrix \(U : n \rightarrow  n\) in \({\mathbf{{Mat}}}_{\mathbb{R} \rightarrow  \mathbb{C}}\) with \(U\left( 0\right)  = {\mathrm{{id}}}_{n}\) and \(U\left( \theta \right) U\left( {\theta }^{\prime }\right)  = U\left( {\theta  + {\theta }^{\prime }}\right)\) for all \(\theta ,{\theta }^{\prime } \in  \mathbb{R}\) . It is strongly continuous when \(\mathop{\lim }\limits_{{\theta  \rightarrow  {\theta }_{0}}}U\left( \theta \right)  = U\left( {\theta }_{0}\right)\) for all \({\theta }_{0} \in  \mathbb{R}\) .</p>
<p>We say a one-parameter diagram \(d : {x}^{\otimes n} \rightarrow  {x}^{\otimes n}\) is a unitary group if its interpretation \(\llbracket d\rrbracket\) is.</p>
<p>Remark 2.3.13. The interpretation of diagrams with smooth maps as phases are necessarily strongly continuous.</p>
<p>Theorem 2.3.14 (Stone). There is a one-to-one correspondance between strongly continuous one-parameter unitary groups \(U : n \rightarrow  n\) in \({\mathbf{{Mat}}}_{\mathbb{R} \rightarrow  \mathbb{C}}\) and self-adjoint matrices \(H : n \rightarrow  n\) in \({\mathbf{{Mat}}}_{\mathbb{C}}\) . The bijection is given explicitly by \(U\left( \theta \right)  = \exp \left( {i\theta H}\right)\) and \(H =  - i\left( {\partial U}\right) \left( 0\right)\) ,translated in terms of diagrams with bubbles we get:</p>
<!-- Media -->
<!-- figureText: \( U\left( \theta \right) \) exp \( H \) \( {i\theta } \) \( \left\lbrack  {\theta  \mapsto  0}\right\rbrack \) \( - i \) \( U\left( \theta \right) \) \( H \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_219.jpg?x=546&#x26;y=1402&#x26;w=467&#x26;h=470&#x26;r=0">
<!-- Media -->
<p>Corollary 2.3.15. A one-parameter diagram \(d : {x}^{\otimes n} \rightarrow  {x}^{\otimes n}\) in \({\mathbf{{ZX}}}_{1}\) is a unitary group iff there is a constant self-adjoint diagram \(h : {x}^{\otimes n} \rightarrow  {x}^{\otimes n}\) such that \(\partial d = i{h}_{\partial }d\) .</p>
<p>Proof. Given the diagram for a unitary group \(d\) ,we compute its diagrammatic differentiation \(\partial d\) and get \(h\) by pattern matching. Conversely given a self-adjoint \(h\) , the diagram \(d = \exp \left( {i\theta h}\right)\) is a unitary group.</p><!-- Meanless: 2. Quantum natural language processing 221-->
<p>Example 2.3.16. Let \(d = {R}_{z}\left( \alpha \right)  \otimes  {R}_{x}\left( \alpha \right)\) for a smooth \(\alpha  : \mathbb{R} \rightarrow  \mathbb{R}\) ,then the following implies \(d\left( \theta \right)  = \exp \left( {i\theta h}\right)\) for \(h =  - i\frac{\partial \alpha }{2}\left( {Z \otimes  I + I \otimes  X}\right)\) .</p>
<!-- Media -->
<!-- figureText: \( \alpha \) \( \alpha \) \( \pi \) \( \alpha \) \( \alpha \) \( \alpha \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_220.jpg?x=432&#x26;y=413&#x26;w=852&#x26;h=223&#x26;r=0">
<!-- Media -->
<p>Example 2.3.17. Let \(d = P\left( {\alpha ,{ZX}}\right)\) be a Pauli gadget as in [Cow+20,Defni-tion 4.1] then the following implies \(d\left( \theta \right)  = \exp \left( {i\theta h}\right)\) for \(h =  - i\frac{\partial \alpha }{2}Z \otimes  X\) .</p>
<!-- Media -->
<!-- figureText: 0 \( \pi \) \( \pi \) \( \left( {\alpha  + \pi }\right) \) \( \frac{\partial \alpha }{2} \) \( \alpha \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_220.jpg?x=444&#x26;y=760&#x26;w=829&#x26;h=295&#x26;r=0">
<!-- Media -->
<h4>2.3.3 Differentiating quantum circuits</h4>
<p>In this section, we extend diagrammatic differentiation to the category Circ of mixed quantum circuits as defined in section 2.2.1. Recall that the definition of Circ depends on a choice of gateset, here we assume that this gateset is interpreted as complex matrices parameterised by some number \(n \in  \mathbb{N}\) of real variables. That is,we fix an interpretation \(\llbracket  - \rrbracket  : {\mathbf{{Circ}}}_{ \rightarrow  }{\mathbf{{Mat}}}_{\mathbb{S}}\) for \(\mathbb{S} = {\mathbb{R}}^{n} \rightarrow  \mathbb{C}\) . In this context, diagrammatic derivations correspond to the notion of gradient recipe for parametrised quantum gates introduced by Schuld et al. [Sch+19].</p>
<p>Let \({\mathbf{{Circ}}}^{ + }\) be the category with formal sums of mixed quantum circuits as arrows, i.e. the free commutative-monoid-enrichment of Circ. Again, we want to find a diagrammatic derivation \(\partial  : {\mathbf{{Circ}}}^{ + } \rightarrow  \mathbb{D}\left\lbrack  {\mathbf{{Circ}}}^{ + }\right\rbrack\) which commutes with the interpretation,i.e. such that \(\left\lbrack  {\partial \widehat{f}}\right\rbrack   = \partial \left\lbrack  \widehat{f}\right\rbrack   = \partial \left( {\overline{\left\lbrack  f\right\rbrack  } \otimes  \left\lbrack  f\right\rbrack  }\right)\) for all circuits \(f \in\) Circ. Note that a diagrammatic derivation for the interpretation of pure quantum circuits does not in general lift to one for mixed quantum circuits. Indeed, using the product rule we get \(\partial \left( {\overline{\lbrack f\rbrack } \otimes  \left\lbrack  f\right\rbrack  }\right)  = \partial \overline{\lbrack f\rbrack } \otimes  \left\lbrack  f\right\rbrack   + \overline{\left\lbrack  f\right\rbrack  } \otimes  \partial \left\lbrack  f\right\rbrack   \neq  \overline{\left\lbrack  \partial f\right\rbrack  } \otimes  \left\lbrack  {\partial f}\right\rbrack\) .</p>
<p>Hence we need equations, called gradient recipes, to rewrite the gradient of a pure map \(\partial \llbracket \widehat{f}\rrbracket\) as the pure map of a gradient \(\llbracket \partial \widehat{f}\rrbracket\) . In the special case of Hermitian operators with at most two unique eigenvalues, gradient recipes are given by the parameter-shift rule. In the general case where the parameter-shift rule does not apply, gradient recipes require the introduction of an ancilla qubit.</p><!-- Meanless: 222 2.3. Diagrammatic differentiation-->
<p>Theorem 2.3.18 ([Sch+19]). For a one-parameter unitary group \(f\) with \(\llbracket f\left( \theta \right) \rrbracket  =\) \(\exp \left( {i\theta H}\right)\) ,if \(H\) has at most two eigenvalues \(\pm  r\) ,then there is a shift \(s \in  \lbrack 0,{2\pi })\) such that \(\llbracket r\left( {f\left( {\theta  + s}\right)  - f\left( {\theta  - s}\right) }\right) \rrbracket  = \partial \llbracket f\left( \theta \right) \rrbracket\) .</p>
<p>Corollary 2.3.19. Mixed quantum circuits with parametrised \({ZX}\) diagrams as gateset admit diagrammatic differentiation.</p>
<p>Proof. The \(Z\) rotation has eigenvalues \(\pm  1\) ,hence the spiders with two legs have diagrammatic differentiation given by the parameter-shift rule:</p>
<!-- Media -->
<!-- figureText: 0 \( - \alpha  + \) \( \alpha \) \( - \alpha \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_221.jpg?x=357&#x26;y=713&#x26;w=849&#x26;h=218&#x26;r=0">
<!-- Media -->
<p>As for theorem 2.3.9, this extends to arbitrary-many legs using spider fusion.</p>
<p>Remark 2.3.20. In order to encode the subtraction of the parameter shift-rule diagrammatically, we need either to consider formal sums with minus signs (a.k.a. enrichment in abelian groups) or simply to extend the signature with the -1 scalar. Such mixed scalars are implemented in listing 2.2.5.</p>
<hr>
<p>Circuit. <em><strong><strong>sub</strong></strong></em> = lambda self, other: self + Scalar(-1) @ other</p>
<hr>
<p>Example 2.3.21. The quantum enhanced feature spaces of Havlicek et al. [Hav+19] are parametrised classical-quantum circuits. The quantum classifier can be drawn as a diagram:</p>
<!-- Media -->
<!-- figureText: \( U\left( \overrightarrow{x}\right) \) \( f \) \( U\left( \overrightarrow{x}\right) \) ... \( W\left( \overrightarrow{\theta }\right) \) ... -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_221.jpg?x=689&#x26;y=1506&#x26;w=181&#x26;h=630&#x26;r=0">
<!-- Media --><!-- Meanless: 2. Quantum natural language processing 223-->
<p>where \(U\left( \overrightarrow{x}\right)\) depends on the input, \(W\left( \overrightarrow{\theta }\right)\) depends on the trainable parameters and \(f\) is a fixed Boolean function encoded as a linear map.</p>
<p>Example 2.3.22. We can define a class for a parameterised quantum gate and override the default grad with its gradient recipe.</p>
<!-- Media -->
<hr>
<p>class Rz (Gate):
def <em>init</em>(self, phase: sympy.Expr) :
self.phase = phase
half_theta = sympy.pi * phase
array = [[sympy.exp(-1j * half_theta), 0],
[0, sympy.exp(1j * half_theta)]]
super(   ).<em>init</em>("Rz({})".format(phase), qubit, qubit, array)
def grad(self):
s = Scalar(sympy.pi * self.phase.diff(var))
return s @ Rz(self.phase + .25) - s @ Rz(self.phase - .25))
phi = sympy. Symbol ( '\\phi ' )
circuit = Ket \(\left( {0,0}\right)  >  >\) Rz \(\left( \text{phi + 1}\right)\) @ Rz \(\left( {2 * \text{phi - .5}}\right)  >  >\) Measure(   ) @ Measure(   )
assert circuit.grad(phi).eval(   ) == circuit.eval(   ).grad(phi)</p>
<hr>
<!-- Media -->
<h4>2.3.4 Bubbles and the chain rule</h4>
<p>Sections 1.1.3 and 1.2.4 have introduced bubbles, diagrammatic gadgets for representing arbitrary operators on the homsets of a monoidal category. In particular, the element-wise application of any rig-valued function \(\beta  : \mathbb{S} \rightarrow  \mathbb{S}\) yields a bubble on the category of matrices \(\beta  : {\mathbf{{Mat}}}_{\mathbb{S}}\left( {m,n}\right)  \rightarrow  {\mathbf{{Mat}}}_{\mathbb{S}}\left( {m,n}\right)\) . When the bubble has a derivative \(\partial \beta\) ,we may define the gradient of bubbled diagrams with the chain rule \(\partial \left( {\beta \left( f\right) }\right)  = \left( {\partial \beta }\right) \left( f\right)  \times  \partial f\) . In order to make sense of the multiplication,we assume that the homsets of our category have a product on homsets which is compatible with the \({\mathrm{{sum}}}^{1}\) and which commutes with the tensor. For example,each homset \({\operatorname{Mat}}_{\mathbb{S}}\left( {m,n}\right)\) is a rig with entrywise sums and products. More generally,the homsets of any hypergraph category with sums form a rig, where the product is given by pre/post-composition with the co/monoid structure. We get the following equation:</p>
<hr>
<!-- Footnote -->
<p>\({}^{1}\) That is,each homset forms a rig. Note that we do not assume that products are compatible with composition,in other words \(\mathbf{C}\) need not be rig-enriched.</p>
<!-- Footnote -->
<hr><!-- Meanless: 224 2.4. Conclusion-->
<!-- Media -->
<!-- figureText: 0 0 ∂β \( f \) \( f \) \( \beta \) \( f \) -->
<img src="https://cdn.noedgeai.com/bo_d16lkkbef24c73d1osig_223.jpg?x=351&#x26;y=373&#x26;w=870&#x26;h=418&#x26;r=0">
<!-- Media -->
<p>For scalar diagrams, spiders are empty diagrams and the equation simplifies to the usual chain rule.</p>
<p>As we have seen in example 1.1.34, we can encode the architecture of any neural network as a diagram with sums and bubbles for the non-linearity. Thus, we can draw both a parametrised quantum circuit and its classical post-processing as one bubbled diagram. By applying the product rule to the quantum circuit and the chain rule to its post-processing, we can compute a diagram for the overall gradient. This applies to parametrised quantum circuits seen as machine learning models [BLS19], to the patterns of measurement-based quantum computing seen as ZX-diagrams [DP10] as well as quantum natural language processing.</p>
<p>For now, we have only defined gradients of diagrams with respect to one parameter at a time. In future work, we plan to extend our definition to compute the Jacobian of a tensor with respect to a vector of variables. Other promising directions for research include the study of diagrammatic differential equations, opening the door to studying e.g. the Schrödinger equation with diagrams.</p>
<h3>2.4 Conclusion</h3>
<p>This chapter built on the category theory of chapter 1 to lay the mathemetical foundations of quantum natural language processing (QNLP). We defined QNLP models as parameterised monoidal functors \({F}_{\theta } : \mathbf{G} \rightarrow\) Circ from a category \(\mathbf{G}\) of grammatical derivations to a category Circ of quantum circuits. Given the grammatical structure \(f : {w}_{1}\ldots {w}_{n} \rightarrow  s \in  \mathbf{G}\) for a sentence,the QNLP model produces a parameterised quantum circuit \({F}_{\theta }\left( f\right)\) which computes the meaning of that sentence. Using a hybrid classical-quantum algorithm, we computed the optimal parameters \(\theta  \in  \Theta\) in a simple supervised learning task: answering yes-no questions from a toy dataset based on Shakespeare's Romeo and Juliet. In short, we performed the first NLP experiment on quantum hardware.</p><!-- Meanless: 2. Quantum natural language processing 225-->
<p>Our QNLP models can be understood as a quantum implementation of Categorical Compositional Distributional (DisCoCat) models [CCS08]. While the fields of NLP and artificial intelligence are torn apart between the symbolic approach of logic-based expert systems and the connectionist approach of black-box neural networks, DisCoCat models offer the best of worlds. Indeed, they bring together formal grammar and distributional semantics into one NLP model in the form of a monoidal functor from syntax to meaning. However, the conceptual advantage of DisCoCat models comes at a price: they can be exponentially hard to evaluate on a classical computer. This is where QNLP comes in: quantum computers may allow to compute approximations of DisCoCat models exponentially faster than any classical computer. We demonstrated that our framework applies both to the large-scale fault-tolerant regime where we can load our data onto a qRAM, and to the NISQ era where we have only a few noisy qubits.</p>
<p>The field of QNLP is still in its infancy and there remains much work to be done both on the theoretical side (can we prove that QNLP models offer a significant advantage compared to their classical counterpart?) and on the experimental side (can we demonstrate this advantage on real-world data?). We argue that the biggest challenge is not so much how to evaluate NLP models on quantum hardware, but how to train them. Indeed, if the architecture of our parameterised quantum circuit is random then the probability of non-zero gradients is exponentially small in the number of qubits and training our model may take an exponential time: this is the so-called barren plateau phenomenon. Thankfully the quantum circuits for QNLP models are not random: we can exploit their internal structure, which comes from the grammatical structure of sentences. As a first step in that direction, we introduced diagrammatic differentiation as a graphical notation for computing the gradient of QNLP models and parameterised diagrams in general.</p>
<p>We conclude with some directions for future work. An obvious direction would be to generalise QNLP models either in their domain or their codomain, i.e. syntax or semantics. On the syntax side, we may consider grammatical frameworks other than the pregroup grammars used in this thesis. Promising candidates include the Lambek calculus with a relevant modality that we used in previous work \(\left\lbrack  {\mathrm{{McP}} + {21}}\right\rbrack\) to model anaphora, and the related text grammar proposed by Coecke [Coe21] and Wang [CW21]. On the semantics side, we may generalise our definition of QNLP models beyond the standard quantum circuit model, experimenting with different kinds of quantum hardware such as linear optical quantum computers \(\left\lbrack  {\mathrm{{Kok}} + {07}}\right\rbrack\) or analog quantum computers based on neutral atoms [Hen+20].</p><!-- Meanless: 226 2.4. Conclusion-->
<p>After syntax and semantics, it is natural to explore the pragmatics of QNLP: how do we train our models and what kind of tasks do we solve? An important direction would be to remove the need for labeled data with a form of self-supervised learning such as functorial language models [TK21]. This requires our models to predict missing words rather than binary labels, a subroutine that will also be necessary for language generation and automated translation. Our framework would also be suitable to generative adversarial modeling, where we train a pair of models against each other in what can be formalised as a functorial language game \(\left\lbrack  {\mathrm{{Fel}} + {20}}\right\rbrack\) . In this game-theoretic setup,it becomes possible to imagine the two players, i.e. the QNLP models for generator and discriminator, sharing an entangled quantum state and communicating with quantum pseudo-telepathy [BBT05]. While most of this thesis focused on the computational advantage of QNLP models, these quantum language games would exhibit a form of communication advantage: quantum players can solve distributed problems beyond what is possible with classical means. Hence we may expect quantum machines to have conversations incomprehensible to classical minds.</p><!-- Meanless: Acknowledgements-->
<p>My first words of gratitude go to my supervisor Bob Coecke. He was the mentor who guided me through to the perks of academia, the architect of the Oxford quantum group in which I learnt so much as well as the guru who indoctrinated me in the science of string diagrams. After he quit his academic position in the middle of my thesis, he also became the most relaxed and enthusiastic boss in all of quantum industry, creating a new research group from scratch to build upon the work we had started together. I must also thank my co-supervisor Dan Marsden, who played a crucial role during my masters and the beginning of my DPhil, taming my enthusiasm with his pragmatism and rigour.</p>
<p>Although the words are my own, the work presented in this thesis was of a collective nature. Thus it is in order to acknowledge my co-authors, first and foremost my academic twin Giovanni de Felice. I would never have written this thesis without the friendship we have built through more than five years of working, cooking and partying together. Our QNLP experiments would not have come to life without Konstantinos Meichanetzidis, his physicist mindset and his patience to let us explain our abstract nonsense. I would also like to thank my academic cousins Richie Yeung and Alex Koziell-Pipe, I trust them to keep the spirit of the quantum group alive.</p>
<p>I am indebted to my examiners Sam Staton and Michael Moortgat for their careful reading of my manuscript, their feedback helped much to improve this thesis. I am grateful to my college advisor Samson Abramsky for his discreet yet thought-provoking supervision. Aleks Kissinger and Mehrnoosh Sadrzadeh have also provided me with valuable feedback during my transfer of status. I want to thank Pawel Sobocinski for inviting me at TalTech where I could present many of the ideas of this thesis, but also for introducing me to string diagrams in the first place in Cali, Columbia over seven years ago.</p>
<p>I am grateful to Simon Harrisson for his generous support through the Wolfson Harrison UK Research Council Quantum Foundation Scholarship. My DPhil was also supported by the Oxford-DeepMind Graduate Scholarship. I also thank Cambridge Quantum Computing for taking me as a part-time research scientist. This brought a new industrial dimension to my research, but also made it possible for me to live with my family in Paris during troubled pandemic times.</p><p>On a more personal side, special thanks go to my friends: Tommaso Salvatori who proofread my introduction to NLP, the Wolfson Secret Santa, la Confinerie du 117 and many others who will recognise themselves. Very special thanks to my family: Astrid, Romeo, my parents Godeleine and Imad, my siblings Raphaël, Maylis and Xavier, my grandfather Etienne (RIP), my grandmothers Véronique and Habiba.</p><!-- Meanless: References-->
<!-- Media -->
<p>[Aar05] Scott Aaronson. "Quantum Computing, Postselection, and Probabilistic Polynomial-Time". In: Electron. Colloquium Comput. Complex. 003 (2005). arXiv: quant-ph/0412187.</p>
<p>[Aar15] Scott Aaronson. "Read the Fine Print". In: Nature Physics 11.4 (4 Apr. 2015), pp. 291-293. DOI: 10.1038/nphys3272.</p>
<p>[AA11] Scott Aaronson and Alex Arkhipov. "The Computational Complexity of Linear Optics". In: Proceedings of the Forty-Third Annual ACM Symposium on Theory of Computing. 2011, pp. 333-342. arXiv: 1011.3245.</p>
<p>[Abb+21] Mina Abbaszade, Vahid Salari, Seyed Shahin Mousavi, Mariam Zomorodi, and Xujuan Zhou. "Application of Quantum Natural Language Processing for Language Translation". In: IEEE Access 9 (2021), pp. 130434-130448. DOI: 10.1109/ACCESS. 2021.3108768.</p>
<p>[Abr96] L. Abrams. "Two-Dimensional Topological Quantum Field Theories and Frobenius Algebras". In: Journal of Knot Theory and Its Ramifications 05.05 (1996), pp. 569-587. DOI: 10.1142/S0218216596000333. eprint: http:</p>
<p>//<a href="http://www.worldscientific.com/doi/pdf/10.1142/S0218216596000333">www.worldscientific.com/doi/pdf/10.1142/S0218216596000333</a>.</p>
<p>[AC04] Samson Abramsky and Bob Coecke. "A Categorical Semantics of Quantum Protocols". In: 19th IEEE Symposium on Logic in Computer Science (LICS 2004), 14-17 July 2004, Turku, Finland, Proceedings. IEEE Computer Society, 2004, pp. 415-425. DOI: 10.1109/LICS. 2004.1319636.</p>
<p>[AS21] Samson Abramsky and Nihil Shah. "Relating Structure and Power: Comonadic Semantics for Computational Resources". 2021. DOI: 10.1093/logcom/exab048. arXiv: 1806.09031.</p>
<p>[AT11] Samson Abramsky and Nikos Tzevelekos. "Introduction to Categories and Categorical Logic". In: CoRR abs/1102.1313 (2011). arXiv: 1102.1313.</p>
<p>[AB08] Dorit Aharonov and Michael Ben-Or. "Fault-Tolerant Quantum Computation with Constant Error Rate". In: SIAM Journal on Computing 38.4 (Jan. 1, 2008), pp. 1207-1282. DOI: 10.1137/S0097539799359385.</p>
<!-- Meanless: 229--><!-- Meanless: 230 References-->
<p>[Ajd35] Kazimierz Ajdukiewicz. "Die Syntaktische Konnexität". In: Studia Philosophica (1935), pp. 1-27.</p>
<p>[AW21] Josh Alman and Virginia Vassilevska Williams. "A Refined Laser Method and Faster Matrix Multiplication". In: Proceedings of the 2021 ACM-SIAM Symposium on Discrete Algorithms, SODA 2021, Virtual Conference, January 10 - 13, 2021. Ed. by Dániel Marx. SIAM, 2021, pp. 522-539. DOI: 10.1137/1.9781611976465.32.</p>
<p>[AMY16] Noga Alon, Shay Moran, and Amir Yehudayoff. "Sign Rank versus VC Dimension". In: Conference on Learning Theory. 2016, pp. 47-80. arXiv: 1503.07648.</p>
<p>[Amb04] A. Ambainis. "Quantum Search Algorithms". In: ACM SIGACT News 35.2 (June 1, 2004), pp. 22-35. DOI: 10.1145/992287.992296.</p>
<p>[AL10] Itai Arad and Zeph Landau. "Quantum Computation and the Evaluation of Tensor Networks". In: SIAM J. Comput. 39.7 (2010), pp. 3089-3121. DOI: 10.1137/080739379. arXiv: 0805.0040.</p>
<p>[Aru+15] Srinivasan Arunachalam, Vlad Gheorghiu, Tomas Jochym-O'Connor, Michele Mosca, and Priyaa Varshinee Srinivasan. "On the Robustness of Bucket Brigade Quantum RAM". In: New Journal of Physics 17.12 (Dec. 7, 2015), p. 123010. DOI: 10.1088/1367-2630/17/12/123010.</p>
<p>[Aru+19] Frank Arute, Kunal Arya, Ryan Babbush, Dave Bacon, Joseph C. Bardin, Rami Barends, Rupak Biswas, Sergio Boixo, Fernando G. S. L. Brandao, David A. Buell, Brian Burkett, Yu Chen, Zijun Chen, Ben Chiaro, Roberto Collins, William Courtney, Andrew Dunsworth, Edward Farhi, Brooks Foxen, Austin Fowler, Craig Gidney, Marissa Giustina, Rob Graff, Keith Guerin, Steve Habegger, Matthew P. Harrigan,</p>
<p>Michael J. Hartmann, Alan Ho, Markus Hoffmann, Trent Huang, Travis S. Humble, Sergei V. Isakov, Evan Jeffrey, Zhang Jiang, Dvir Kafri, Kostyantyn Kechedzhi, Julian Kelly, Paul V. Klimov, Sergey Knysh, Alexander Korotkov, Fedor Kostritsa, David Landhuis, Mike Lindmark, Erik Lucero, Dmitry Lyakh, Salvatore Mandrà, Jarrod R. McClean, Matthew McEwen, Anthony Megrant, Xiao Mi, Kristel Michielsen, Masoud Mohseni, Josh Mutus, Ofer Naaman, Matthew Neeley, Charles Neill, Murphy Yuezhen Niu, Eric Ostby, Andre Petukhov, John C. Platt, Chris Quintana, Eleanor G. Rieffel, Pedram Roushan, Nicholas C. Rubin, Daniel Sank, Kevin J. Satzinger, Vadim Smelyanskiy, Kevin J. Sung, Matthew D. Trevithick, Amit Vainsencher, Benjamin Villalonga, Theodore White, Z. Jamie Yao, Ping Yeh,</p><!-- Meanless: References 231-->
<table><tbody><tr><td></td><td>Adam Zalcman, Hartmut Neven, and John M. Martinis. "Quantum Supremacy Using a Programmable Superconducting Processor". In: Nature 574.7779 (7779 Oct. 2019), pp. 505-510. DOI: 10.1038/s41586-019-1666-5.</td></tr><tr><td>[Ati88]</td><td>Michael F Atiyah. "Topological Quantum Field Theory". In: Publications Mathématiques de l'IHÉS 68 (1988), pp. 175-186.</td></tr><tr><td>[Bac+21]</td><td>Miriam Backens, Hector Miller-Bakewell, Giovanni de Felice, Leo Lobski, and John van de Wetering. "There and Back Again: A Circuit Extraction Tale". In: Quantum 5 (2021), p. 421. DOI: 10.22331/q-2021-03-25-421.</td></tr><tr><td>[Bae06]</td><td>John Baez. "Quantum Quandaries: A Category-Theoretic Perspective". In: The Structural Foundations of Quantum Gravity. Oxford: Oxford University Press, 2006. DOI: 10.1093/acprof:oso/9780199269693.003.0008.</td></tr><tr><td>[BE14]</td><td>John C. Baez and Jason Erbele. "Categories in Control". In: ArXiv e-prints (May 27, 2014). arXiv: 1405.6881.</td></tr><tr><td>[BF15]</td><td>John C. Baez and Brendan Fong. "A Compositional Framework for Passive Linear Networks". In: (2015). eprint: arXiv:1504.05625.</td></tr><tr><td>[BP17]</td><td>John C. Baez and Blake S. Pollard. "A Compositional Framework for Reaction Networks". In: Reviews in Mathematical Physics 29.09 (Oct. 2017), p. 1750028. DOI: 10.1142/S0129055X17500283. arXiv: 1704.02051.</td></tr><tr><td>[BD95]</td><td>John C Baez and James Dolan. "Higher-Dimensional Algebra and Topological Quantum Field Theory". In: Journal of mathematical physics 36.11 (1995), pp. 6073-6105.</td></tr><tr><td>[BS10]</td><td>John Baez and Mike Stay. "Physics, Topology, Logic and Computation: A Rosetta Stone". In: New Structures for Physics. Springer, 2010, pp. 95-172. arXiv: 0903.0340.</td></tr><tr><td>[BCB15]</td><td>Dzmitry Bahdanau, Kyunghyun Cho, and Yoshua Bengio. "Neural Machine Translation by Jointly Learning to Align and Translate". In: 3rd International Conference on Learning Representations, ICLR 2015, San Diego, CA, USA, May 7-9, 2015, Conference Track Proceedings. Ed. by Yoshua Bengio and Yann LeCun. 2015. URL: http://arxiv.org/abs/1409.0473.</td></tr><tr><td>[Bal]</td><td>Philip Ball. Major Quantum Computing Strategy Suffers Serious Setbacks. Quanta Magazine. URL: https://www.quantamagazine.org/major- quantum-computing-strategy-suffers-serious-setbacks-20210929/ (visited on 10/26/2021).</td></tr></tbody></table><!-- Meanless: 232 References-->
<p>[Ban+08] Jeongho Bang, James Lim, M. S. Kim, and Jinhyoung Lee. "Quantum Learning Machine". In: ArXiv e-prints (Mar. 31, 2008). arXiv: 0803.2976.</p>
<p>[Bar53] Yehoshua Bar-Hillel. "A Quasi-Arithmetical Notation for Syntactic Description". In: Language 29.1 (Jan. 1953), pp. 47-58. DOI: 10.2307/410452. JSTOR: 410452.</p>
<p>[Bar54] Yehoshua Bar-Hillel. "Logical Syntax and Semantics". In: Language 30.2 (Apr. 1954), p. 230. DOI: 10.2307/410265. JSTOR: 410265.</p>
<p>[Bar+60] Yehoshua Bar-Hillel, Gaifman (C.), Eli Shamir, and C Caifman. On Categorial and Phrase-Structure Grammars. Weizmann Science Press, 1960.</p>
<p>[BKV18] Krzysztof Bar, Aleks Kissinger, and Jamie Vicary. "Globular: An Online Proof Assistant for Higher-Dimensional Rewriting". In: Logical Methods in Computer Science 14.1 (2018). DOI: 10.23638/LMCS-14(1:8)2018.</p>
<p>[BV17] Krzysztof Bar and Jamie Vicary. "Data Structures for Quasistrict Higher Categories". In: 2017 32nd Annual ACM/IEEE Symposium on Logic in Computer Science (LICS). 2017 32nd Annual ACM/IEEE Symposium on Logic in Computer Science (LICS). June 2017, pp. 1-12. DOI: 10.1109/LICS.2017.8005147.</p>
<p>[BLS19] Marcello Benedetti, Erika Lloyd, and Stefan H. Sack. "Parameterized Quantum Circuits as Machine Learning Models". In: CoRR abs/1906.07682 (2019). arXiv: 1906.07682.</p>
<p>[Ben80] Paul Benioff. "The Computer as a Physical System: A Microscopic Quantum Mechanical Hamiltonian Model of Computers as Represented by Turing Machines". In: Journal of Statistical Physics 22.5 (May 1, 1980), pp. 563-591. DOI: 10.1007/BF01011339.</p>
<p>[Ben+97] Charles H. Bennett, Ethan Bernstein, Gilles Brassard, and Umesh Vazirani. "Strengths and Weaknesses of Quantum Computing". In: SIAM Journal on Computing 26.5 (Oct. 1, 1997), pp. 1510-1523. DOI: 10.1137/S0097539796300933.</p>
<p>[Ben70] David B. Benson. "Syntax and Semantics: A Categorical View". In: Information and Control 17.2 (Sept. 1970), pp. 145-160. DOI: 10.1016/S0019-9958(70)90517-6.</p>
<p>[BH03] Nick Benton and Martin Hyland. "Traced Premonoidal Categories". In: RAIRO - Theoretical Informatics and Applications 37.4 (Oct. 2003), pp. 273-299. DOI: 10.1051/ita: 2003020.</p><!-- Meanless: References 233-->
<p>[Ber+20] Ville Bergholm, Josh Izaac, Maria Schuld, Christian Gogolin, M. Sohaib Alam, Shahnawaz Ahmed, Juan Miguel Arrazola, Carsten Blank, Alain Delgado, Soran Jahangiri, Keri McKiernan, Johannes Jakob Meyer, Zeyue Niu, Antal Száva, and Nathan Killoran. "PennyLane: Automatic Differentiation of Hybrid Quantum-Classical Computations". In: ArXiv e-prints (Feb. 13, 2020). arXiv: 1811.04968.</p>
<p>[BBD09] Daniel J Bernstein, Johannes Buchmann, and Erik Dahmén. Post-Quantum Cryptography. Berlin: Springer, 2009.</p>
<p>[BK93] Saroja Bhate and Subhash Kak. "Pānini's Grammar and Computer Science". In: Annals of the Bhandarkar Oriental Research Institute 72 (1993), pp. 79-94.</p>
<p>[Bin+19] Eli Bingham, Jonathan P Chen, Martin Jankowiak, Fritz Obermeyer, Neeraj Pradhan, Theofanis Karaletsos, Rohit Singh, Paul Szerlip, Paul Horsfall, and Noah D Goodman. "Pyro: Deep Universal Probabilistic Programming". In: The Journal of Machine Learning Research 20.1 (2019), pp. 973-978.</p>
<p>[BKL13] William Blacoe, Elham Kashefi, and Mirella Lapata. "A Quantum-Theoretic Approach to Distributional Semantics". In: Proceedings of the 2013 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies. NAACL-HLT 2013. Atlanta, Georgia: Association for Computational Linguistics, June 2013, pp. 847-857. URL: <a href="https://aclanthology.org/N13-1105">https://aclanthology.org/N13-1105</a> (visited on 12/01/2021).</p>
<p>[BCS06] R. F. Blute, J. R. B. Cockett, and R. A. G. Seely. "Differential Categories". In: Mathematical Structures in Computer Science 16.06 (Dec. 2006), p. 1049. DOI: 10.1017/S0960129506005676.</p>
<p>[Bol+17] Joe Bolt, Bob Coecke, Fabrizio Genovese, Martha Lewis, Dan Marsden, and Robin Piedeleu. "Interacting Conceptual Spaces I : Grammatical Composition of Concepts". In: CoRR abs/1703.08314 (2017). arXiv: 1703.08314.</p>
<p>[Bon+16] Filippo Bonchi, Fabio Gadducci, Aleks Kissinger, Pawel Sobocinski, and Fabio Zanasi. "Rewriting modulo Symmetric Monoidal Structure". In: Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science - LICS '16 (2016), pp. 710-719. DOI:</p>
<p>10.1145/2933575.2935316. arXiv: 1602.06771.</p><!-- Meanless: 234 References-->
<p>[Bon+20] Filippo Bonchi, Fabio Gadducci, Aleks Kissinger, Pawel Sobocinski, and Fabio Zanasi. "String Diagram Rewrite Theory I: Rewriting with Frobenius Structure". In: ArXiv e-prints (Dec. 3, 2020). arXiv: 2012.01847.</p>
<p>[BSS18] Filippo Bonchi, Jens Seeber, and Pawel Sobocinski. "Graphical Conjunctive Queries". In: ArXiv e-prints (Apr. 20, 2018). arXiv: 1804.07626.</p>
<p>[BSZ14] Filippo Bonchi, Pawel Sobociński, and Fabio Zanasi. "A Categorical Semantics of Signal Flow Graphs". In: CONCUR 2014 - Concurrency Theory. Ed. by Paolo Baldan and Daniele Gorla. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer, 2014, pp. 435-450. DOI: 10.1007/978-3-662-44584-6_30.</p>
<p>[Boo54] George Boole. An Investigation of the Laws of Thought on Which Are Founded the Mathematical Theories of Logic and Probabilities. In collab. with University of California Libraries. London : Walton and Maberly, 1854. 450 pp. URL:</p>
<p><a href="http://archive.org/details/investigationofl00boolrich">http://archive.org/details/investigationofl00boolrich</a> (visited on \({09}/{07}/{2019})\) .</p>
<p>[Bor+19] Emanuela Boros, Alexis Toumi, Erwan Rouchet, Bastien Abadie, Dominique Stutzmann, and Christopher Kermorvant. "Automatic Page Classification in a Large Collection of Manuscripts Based on the International Image Interoperability Framework". In: International Conference on Document Analysis and Recognition. 2019. DOI: 10.1109/ICDAR.2019.00126.</p>
<p>[Bra+20] James Bradbury, Roy Frostig, Peter Hawkins, Matthew James Johnson, Chris Leary, Dougal Maclaurin, and Skye Wanderman-Milne. JAX: Composable Transformations of Python+ NumPy Programs, 2018. 2020. URL: <a href="http://github.com/google/jax">http://github.com/google/jax</a> (visited on 05/10/2022).</p>
<p>[Bra+18] Tai-Danae Bradley, Martha Lewis, Jade Master, and Brad Theilman. "Translating and Evolving: Towards a Model of Language Change in DisCoCat". In: Electronic Proceedings in Theoretical Computer Science 283 (Nov. 8, 2018), pp. 50-61. DOI: 10.4204/EPTCS. 283.4. arXiv: 1811.11041.</p>
<p>[BT00] Geraldine Brady and Todd Trimble. "A Categorical Interpretation of C.S. Peirce's Propositional Logic Alpha". In: Journal of Pure and Applied Algebra 149 (June 2000), pp. 213-239. DOI:</p>
<p>10.1016/S0022-4049(98)00179-0.</p><!-- Meanless: References 235-->
<p>[BT98] Geraldine Brady and Todd H. Trimble. "A String Diagram Calculus for Prediate Logic and C. S. Peirce's System Beta". 1998. URL: <a href="http://people.cs.uchicago.edu/~brady/beta98.ps">http://people.cs.uchicago.edu/~brady/beta98.ps</a>.</p>
<p>[BBT05] Gilles Brassard, Anne Broadbent, and Alain Tapp. "Quantum Pseudo-Telepathy". In: Foundations of Physics 35.11 (Nov. 1, 2005), pp. 1877-1907. DOI: 10.1007/s10701-005-7353-4.</p>
<p>[Bra+02] Gilles Brassard, Peter Hoyer, Michele Mosca, and Alain Tapp. "Quantum Amplitude Amplification and Estimation". In: ArXiv e-prints 305 (2002), pp. 53-74. DOI: 10.1090/conm/305/05215. arXiv: quant-ph/0005055.</p>
<p>[Bus01] Wojciech Buszkowski. "Lambek Grammars Based on Pregroups". In: Logical Aspects of Computational Linguistics LNAI.2099 (2001), pp. 95-109.</p>
<p>[CW18] Liwei Cai and William Yang Wang. "KBGAN: Adversarial Learning for Knowledge Graph Embeddings". In: ArXiv e-prints (Apr. 16, 2018). arXiv: 1711.04071.</p>
<p>[Can06] R. Ferrer i Cancho. "Why Do Syntactic Links Not Cross?" In: Europhysics Letters (EPL) 76.6 (Dec. 2006), pp. 1228-1235. DOI: 10.1209/epl/i2006-10406-0.</p>
<p>[Car37] Rudolf Carnap. Logical Syntax of Language. London: Kegan Paul and Co., Ltd, 1937.</p>
<p>[Car47] Rudolf Carnap. Meaning and Necessity: A Study in Semantics and Modal Logic. University of Chicago Press, 1947.</p>
<p>[Cha+18] Nicholas Chancellor, Aleks Kissinger, Joschka Roffe, Stefan Zohren, and Dominic Horsman. "Graphical Structures for Design and Verification of Quantum Error Correction". In: ArXiv e-prints (Jan. 12, 2018). arXiv: 1611.08012.</p>
<p>[CM77] Ashok K. Chandra and Philip M. Merlin. "Optimal Implementation of Conjunctive Queries in Relational Data Bases". In: Proceedings of the Ninth Annual ACM Symposium on Theory of Computing - STOC '77. The Ninth Annual ACM Symposium. Boulder, Colorado, United States: ACM Press, 1977, pp. 77-90. DOI: 10.1145/800105. 803397.</p>
<p>[CR00] Chandra Chekuri and Anand Rajaraman. "Conjunctive Query Containment Revisited". In: Theoretical Computer Science (2000), p. 19.</p>
<p>[Che02] Joseph CH Chen. "Quantum Computation and Natural Language Processing". Staats-und Universitätsbibliothek Hamburg Carl von Ossietzky, 2002.</p><!-- Meanless: 236 References-->
<p>[CJ19] Kenta Cho and Bart Jacobs. "Disintegration and Bayesian Inversion via String Diagrams". In: Mathematical Structures in Computer Science 29.7 (Aug. 2019), pp. 938-971. DOI: 10.1017/S0960129518000488. arXiv: 1709.00322.</p>
<p>[Cho56] Noam Chomsky. "Three Models for the Description of Language". In: IRE Transactions on Information Theory 2.3 (Sept. 1956), pp. 113-124. DOI: 10.1109/TIT. 1956.1056813.</p>
<p>[Cho57] Noam Chomsky. Syntactic Structures. The Hague: Mouton and Co., 1957.</p>
<p>[Cho63] Noam Chomsky. "Formal Properties of Grammars". In: Handbook of Math. Psychology 2 (1963), pp. 328-418.</p>
<p>[CGK98] Isaac L. Chuang, Neil Gershenfeld, and Mark Kubinec. "Experimental Implementation of Fast Quantum Searching". In: Physical Review Letters 80.15 (Apr. 13, 1998), pp. 3408-3411. DOI: 10.1103/PhysRevLett.80.3408.</p>
<p>[CP07a] Cindy Chung and James Pennebaker. "The Psychological Functions of Function Words". In: Social communication (Jan. 1, 2007).</p>
<p>[Chu36] Alonzo Church. "A Note on the Entscheidungsproblem". In: The journal of symbolic logic 1.1 (1936), pp. 40-41.</p>
<p>[CJS13] B. D. Clader, B. C. Jacobs, and C. R. Sprouse. "Preconditioned Quantum Linear System Algorithm". In: Physical Review Letters 110.25 (June 18, 2013), p. 250504. DOI: 10.1103/PhysRevLett. 110.250504.</p>
<p>[Cla+06] Alexander Clark, Christophe Costa Florêncio, Chris Watkins, and Mariette Sérayet. "Planar Languages and Learnability". In: Grammatical Inference: Algorithms and Applications, 8th International Colloquium, ICGI 2006, Tokyo, Japan, September 20-22, 2006, Proceedings. Ed. by Yasubumi Sakakibara, Satoshi Kobayashi, Kengo Sato, Tetsuro Nishino, and Etsuji Tomita. Vol. 4201. Lecture Notes in Computer Science. Springer, 2006, pp. 148-160. DOI: 10.1007/11872436_13.</p>
<p>[Cla21] Stephen Clark. "Something Old, Something New: Grammar-based CCG Parsing with Transformer Models". In: ArXiv e-prints (Sept. 28, 2021). arXiv: 2109.10044.</p>
<p>[CCS08] Stephen Clark, Bob Coecke, and Mehrnoosh Sadrzadeh. "A Compositional Distributional Model of Meaning". In: Proceedings of the Second Symposium on Quantum Interaction (QI-2008). 2008, pp. 133-140.</p><!-- Meanless: References 237-->
<table><tbody><tr><td>[CCS10]</td><td>Stephen Clark, Bob Coecke, and Mehrnoosh Sadrzadeh. "Mathematical Foundations for a Compositional Distributional Model of Meaning". In: \( A \) Festschrift for Jim Lambek. Ed. by J. van Benthem and M. Moortgat. Vol. 36. Linguistic Analysis. 2010, pp. 345-384. arXiv: 1003.4394.</td></tr><tr><td>[CP07b]</td><td>Stephen Clark and Stephen Pulman. "Combining Symbolic and Distributional Models of Meaning". In: Quantum Interaction, Papers from the 2007 AAAI Spring Symposium, Technical Report SS-07-08, Stanford, California, USA, March 26-28, 2007. AAAI, 2007, pp. 52-55. URL: http: //www.aaai.org/Library/Symposia/Spring/2007/ss07-08-008.php.</td></tr><tr><td>[Cli73]</td><td>William Kingdon Clifford. A Preliminary Sketch of Biquaternions. 1873.</td></tr><tr><td>[CS97]</td><td>J Robin B Cockett and Robert AG Seely. "Weakly Distributive Categories". In: Journal of Pure and Applied Algebra 114.2 (1997), pp. 133-173.</td></tr><tr><td>[Coc+19]</td><td>Robin Cockett, Geoffrey Cruttwell, Jonathan Gallagher, Jean-Simon Pacaud Lemay, Benjamin MacAdam, Gordon Plotkin, and Dorette Pronk. "Reverse Derivative Categories". In: ArXiv e-prints (Oct. 15, 2019). arXiv: 1910.07065.</td></tr><tr><td>[Coe13]</td><td>Bob Coecke. "An Alternative Gospel of Structure: Order, Composition, Processes". In: ArXiv e-prints (July 15, 2013). arXiv: 1307.4038.</td></tr><tr><td>[Coe21]</td><td>Bob Coecke. "The Mathematics of Text Structure". In: Joachim Lambek: The Interplay of Mathematics, Logic, and Linguistics. Ed. by Claudia Casadio and Philip J. Scott. Cham: Springer International Publishing, 2021, pp. 181-217. DOI: 10.1007/978-3-030-66545-6_6.</td></tr><tr><td>[CD08]</td><td>Bob Coecke and Ross Duncan. "Interacting Quantum Observables". In: Automata, Languages and Programming. Ed. by Luca Aceto, Ivan Damgård, Leslie Ann Goldberg, Magnús M. Halldórsson, Anna Ingólfsdóttir, and Igor Walukiewicz. Lecture Notes in Computer Science. Springer Berlin Heidelberg, 2008, pp. 298-310. DOI: 10.1016/0022-4049(80)90101-2.</td></tr><tr><td>[CD11]</td><td>Bob Coecke and Ross Duncan. "Interacting Quantum Observables: Categorical Algebra and Diagrammatics". In: New Journal of Physics 13 (2011), p. 043016. arXiv: 0906.4725.</td></tr><tr><td>[Coe +18]</td><td>Bob Coecke, Giovanni de Felice, Dan Marsden, and Alexis Toumi. "Towards Compositional Distributional Discourse Analysis". In: Proceedings CAPNS 2018. EPTCS, Nov. 8, 2018. DOI: 10.4204/EPTCS.283.1.</td></tr></tbody></table><!-- Meanless: 238 References-->
<p>[Coe+20a] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "Foundations for Near-Term Quantum Natural Language Processing". In: ArXiv e-prints (2020). arXiv: 2012.03755.</p>
<p>[Coe+20b] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. Quantum Natural Language Processing. Apr. 7, 2020. URL: <a href="https://medium.com/cambridge-quantum-computing/quantum-natural-language-processing-748d6f27b31d">https://medium.com/cambridge-quantum-computing/quantum-natural-language-processing-748d6f27b31d</a> (visited on 02/24/2022).</p>
<p>[Coe+21] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "How to Make Qubits Speak". In: CoRR abs/2107.06776 (2021). arXiv: 2107.06776.</p>
<p>[CGS13] Bob Coecke, Edward Grefenstette, and Mehrnoosh Sadrzadeh. "Lambek vs. Lambek: Functorial Vector Space Semantics and String Diagrams for Lambek Calculus". In: Ann. Pure Appl. Log. 164.11 (2013), pp. 1079-1100. DOI: 10.1016/j.apal.2013.05.009. arXiv: 1302.0393.</p>
<p>[CHK12] Bob Coecke, Chris Heunen, and Aleks Kissinger. "Categories of Quantum and Classical Channels (Extended Abstract)". In: Proceedings 9th Workshop on Quantum Physics and Logic, QPL 2012, Brussels, Belgium, 10-12 October 2012. Ed. by Ross Duncan and Prakash Panangaden. Vol. 158. EPTCS. 2012, pp. 1-14. DOI: 10.4204/EPTCS. 158.1. arXiv: 1408.0049.</p>
<p>[CK17] Bob Coecke and Aleks Kissinger. Picturing Quantum Processes: A First Course in Quantum Theory and Diagrammatic Reasoning. Cambridge: Cambridge University Press, 2017. DOI: 10.1017/9781316219317.</p>
<p>[CS12] Bob Coecke and Robert W. Spekkens. "Picturing Classical and Quantum Bayesian Inference". In: Synthese 186.3 (June 2012), pp. 651-696. DOI: 10.1007/s11229-011-9917-5. arXiv: 1102.2368.</p>
<p>[CW21] Bob Coecke and Vincent Wang. Grammar Equations. June 14, 2021. arXiv: 2106.07485 [cs, math].</p>
<p>[CDH20] Cole Comfort, Antonin Delpeuch, and Jules Hedges. "Sheet Diagrams for Bimonoidal Categories". In: ArXiv e-prints (Dec. 19, 2020). arXiv: 2010.13361.</p>
<p>[con12] HaskellWiki contributors. Hask. HaskellWiki. 2012. URL: <a href="https://wiki.haskell.org/index.php?title=Hask&#x26;oldid=52908">https://wiki.haskell.org/index.php?title=Hask&#x26;oldid=52908</a> (visited on \({07}/{26}/{2022}\) ).</p><!-- Meanless: References 239-->
<p>[CMS22] Adriana D. Correia, Michael Moortgat, and Henk T. C. Stoof. "Quantum Computations for Disambiguation and Question Answering". In: Quantum Information Processing 21.4 (2022), p. 126. DOI: 10.1007/s11128-022-03441-9.</p>
<p>[Cow+20] Alexander Cowtan, Silas Dilkes, Ross Duncan, Will Simmons, and Seyon Sivarajah. "Phase Gadget Synthesis for Shallow Circuits". In: Electronic Proceedings in Theoretical Computer Science 318 (May 1, 2020), pp. 213-228. DOI: 10.4204/EPTCS. 318.13. arXiv: 1906.01734.</p>
<p>[CSD20] Alexander Cowtan, Will Simmons, and Ross Duncan. "A Generic Compilation Strategy for the Unitary Coupled Cluster Ansatz". In: ArXiv e-prints (Aug. 27, 2020). arXiv: 2007.10515.</p>
<p>[Cro18] Andrew Cross. "The IBM Q Experience and QISKit Open-Source Quantum Computing Software". In: 2018 (Jan. 1, 2018), p. L58.003. URL: <a href="https://ui.adsabs.harvard.edu/abs/2018APS..MARL58003C">https://ui.adsabs.harvard.edu/abs/2018APS..MARL58003C</a> (visited on \({01}/{11}/{2022}\) ).</p>
<p>[Cru+21] G. S. H. Cruttwell, Bruno Gavranović, Neil Ghani, Paul Wilson, and Fabio Zanasi. "Categorical Foundations of Gradient-Based Learning". In: ArXiv e-prints (Mar. 2, 2021). arXiv: 2103.01931.</p>
<p>[Cur30] H. B. Curry. "Grundlagen Der Kombinatorischen Logik". In: American Journal of Mathematics 52.3 (1930), pp. 509-536. DOI: 10.2307/2370619. JSTOR: 2370619.</p>
<p>[Dan+06] Nils Anders Danielsson, John Hughes, Patrik Jansson, and Jeremy Gibbons. "Fast and Loose Reasoning Is Morally Correct". In: ACM SIGPLAN Notices 41.1 (Jan. 11, 2006), pp. 206-217. DOI: 10.1145/1111320.1111056.</p>
<p>[Dav10] Owen Davies. Grimoires: A History of Magic Books. Oxford University Press, 2010. 381 pp.</p>
<p>[De 01] Philippe De Groote. "Type Raising, Continuations, and Classical Logic". In: Proceedings of the Thirteenth Amsterdam Colloquium. ILLC Amsterdam, 2001, pp. 97-101.</p>
<p>[DP04] Philippe De Groote and Sylvain Pogodalla. "On the Expressive Power of Abstract Categorial Grammars: Representing Context-Free Formalisms". In: Journal of Logic, Language, and Information 13.4 (2004), pp. 421-438. JSTOR: 40180374.</p><!-- Meanless: 240 References-->
<table><tbody><tr><td>[dBBW20]</td><td>Niel de Beaudrap, Xiaoning Bian, and Quanlong Wang. "Fast and Effective Techniques for T-Count Reduction via Spider Nest Identities". In: 15th Conference on the Theory of Quantum Computation, Communication and Cryptography, TQC 2020, June 9-12, 2020, Riga, Latvia. Ed. by Steven T. Flammia. Vol. 158. LIPIcs. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2020, 11:1-11:23. DOI: 10.4230/LIPIcs.TQC. 2020.11.</td></tr><tr><td>[dGD20]</td><td>Arianne Meijer-van de Griend and Ross Duncan. "Architecture-Aware Synthesis of Phase Polynomials for NISQ Devices". In: ArXiv e-prints (Apr. 13, 2020). arXiv: 2004.06052.</td></tr><tr><td>[Del19]</td><td>Antonin Delpeuch. "Autonomization of Monoidal Categories". In: Proceedings Applied Category Theory 2019, ACT 2019, University of Oxford, UK, 15-19 July 2019. Ed. by John Baez and Bob Coecke. Vol. 323. EPTCS. 2019, pp. 24-43. DOI: 10.4204/EPTCS. 323.3.</td></tr><tr><td>[Del20a]</td><td>Antonin Delpeuch. "A Complete Language for Faceted Dataflow Programs". In: Electronic Proceedings in Theoretical Computer Science 323 (Sept. 15, 2020), pp. 1-14. DOI: 10.4204/EPTCS. 323.1. arXiv: 1906.05937.</td></tr><tr><td>[Del20b]</td><td>Antonin Delpeuch. "The Word Problem for Double Categories". In: ArXiv e-prints (Jan. 2, 2020). arXiv: 1907.09927.</td></tr><tr><td>[DV21]</td><td>Antonin Delpeuch and Jamie Vicary. "The Word Problem for Braided Monoidal Categories Is Unknot-Hard". In: ArXiv e-prints (May 10, 2021). arXiv: 2105.04237.</td></tr><tr><td>[Deu85]</td><td>David Deutsch. "Quantum Theory, the Church-Turing Principle and the Universal Quantum Computer". In: Proceedings of the Royal Society of London. A. Mathematical and Physical Sciences 400.1818 (1985), pp. 97-117.</td></tr><tr><td>[Deu91]</td><td>David Deutsch. "Quantum Mechanics near Closed Timelike Lines". In: Physical Review D 44.10 (Nov. 15, 1991), pp. 3197-3217. DOI: 10.1103/PhysRevD.44.3197.</td></tr><tr><td>[DJ92]</td><td>David Deutsch and Richard Jozsa. "Rapid Solution of Problems by Quantum Computation". In: Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences 439.1907 (Dec. 8, 1992), pp. 553-558. DOI: 10.1098/rspa. 1992.0167.</td></tr></tbody></table><!-- Meanless: References 241-->
<table><tbody><tr><td>[Dev+19]</td><td>Jacob Devlin, Ming-Wei Chang, Kenton Lee, and Kristina Toutanova. "BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding". In: Proceedings of the 2019 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, NAACL-HLT 2019, Minneapolis, MN, USA, June 2-7, 2019, Volume 1 (Long and Short Papers). Ed. by Jill Burstein, Christy Doran, and Thamar Solorio. Association for Computational Linguistics, 2019, pp. 4171-4186. DOI: 10.18653/v1/n19-1423.</td></tr><tr><td>[Dow88]</td><td>David Dowty. "Type Raising, Functional Composition, and Non-Constituent Conjunction". In: Categorial Grammars and Natural Language Structures. Ed. by Richard T. Oehrle, Emmon Bach, and Deirdre Wheeler. Studies in Linguistics and Philosophy. Dordrecht: Springer Netherlands, 1988, pp. 153-197. DOI: 10.1007/978-94-015-6878-4_7.</td></tr><tr><td>[Dun+20]</td><td>Ross Duncan, Aleks Kissinger, Simon Perdrix, and John van de Wetering. "Graph-Theoretic Simplification of Quantum Circuits with the ZX-calculus". In: Quantum 4 (June 4, 2020), p. 279. DOI: 10.22331/q-2020-06-04-279. arXiv: 1902.03178.</td></tr><tr><td>[DP10]</td><td>Ross Duncan and Simon Perdrix. "Rewriting Measurement-Based Quantum Computations with Generalised Flow". In: International Colloquium on Automata, Languages, and Programming. Springer. 2010, pp. 285-296. DOI: 10.1007/s10472-009-9141-x.</td></tr><tr><td>[DV19]</td><td>Lawrence Dunn and Jamie Vicary. "Coherence for Frobenius Pseudomonoids and the Geometry of Linear Proofs". In: ArXiv e-prints (2019). DOI: 10.23638/LMCS-15(3:5)2019. arXiv: 1601.05372.</td></tr><tr><td>[EPS73]</td><td>H. Ehrig, M. Pfender, and H. J. Schneider. "Graph-Grammars: An Algebraic Approach". In: 14th Annual Symposium on Switching and Automata Theory (Swat 1973). 14th Annual Symposium on Switching and Automata Theory (Swat 1973). Oct. 1973, pp. 167-180. DOI: 10.1109/SWAT.1973.11.</td></tr><tr><td>[EM42a]</td><td>Samuel Eilenberg and Saunders MacLane. "Group Extensions and Homology". In: Annals of Mathematics 43.4 (1942), pp. 757-831. DOI: 10.2307/1968966. JSTOR: 1968966.</td></tr><tr><td>[EM42b]</td><td>Samuel Eilenberg and Saunders MacLane. "Natural Isomorphisms in Group Theory". In: Proceedings of the National Academy of Sciences of the United States of America 28.12 (1942), p. 537.</td></tr></tbody></table><!-- Meanless: 242 References-->
<p>[EM45] Samuel Eilenberg and Saunders MacLane. "General Theory of Natural Equivalences". In: Transactions of the American Mathematical Society 58 (1945), pp. 231-294. DOI: 10.1090/S0002-9947-1945-0013131-6.</p>
<p>[FGG14] Edward Farhi, Jeffrey Goldstone, and Sam Gutmann. "A Quantum Approximate Optimization Algorithm". In: ArXiv e-prints (Nov. 14, 2014). arXiv: 1411.4028.</p>
<p>[FN18] Edward Farhi and Hartmut Neven. "Classification with Quantum Neural Networks on Near Term Processors". Version 2. In: ArXiv e-prints (Aug. 30, 2018). arXiv: 1802.06002.</p>
<p>[Fel22] Giovanni de Felice. "Categorical Tools for Natural Language Processing". University of Oxford, 2022.</p>
<p>[Fel+20] Giovanni de Felice, Elena Di Lavore, Mario Román, and Alexis Toumi. "Functorial Language Games for Question Answering". In: Proceedings of the 3rd Annual International Applied Category Theory Conference 2020, ACT 2020, Cambridge, USA, 6-10th July 2020. Ed. by David I. Spivak and Jamie Vicary. Vol. 333. EPTCS. 2020, pp. 311-321. DOI: 10.4204/EPTCS. 333.21.</p>
<p>[FMT19] Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "Functorial Question Answering". In: Proceedings Applied Category Theory 2019, ACT 2019, University of Oxford, UK. Vol. 323. EPTCS. 2019. DOI: 10.4204/EPTCS. 323.6.</p>
<p>[FTC20] Giovanni de Felice, Alexis Toumi, and Bob Coecke. "DisCoPy: Monoidal Categories in Python". In: Proceedings of the 3rd Annual International Applied Category Theory Conference, ACT. Vol. 333. EPTCS, 2020. DOI: 10.4204/EPTCS. 333.13.</p>
<p>[Fey85] Richard P Feynman. "Quantum Mechanical Computers". In: Optics news 11.2 (1985), pp. 11-20. URL:</p>
<p><a href="http://www.mathweb.zju.edu.cn:8080/wjd/notespapers/F.pdf">http://www.mathweb.zju.edu.cn:8080/wjd/notespapers/F.pdf</a>.</p>
<p>[Fey82] Richard P. Feynman. "Simulating Physics with Computers". In: International Journal of Theoretical Physics 21.6 (June 1, 1982), pp. 467-488. DOI: 10.1007/BF02650179.</p>
<p>[Fir57] John R Firth. "A Synopsis of Linguistic Theory, 1930-1955". In: Studies in linguistic analysis (1957).</p>
<p>[FLK80] François Foltz, Christian Lair, and GM Kelly. "Algebraic Categories with Few Monoidal Biclosed Structures or None". In: Journal of Pure and Applied Algebra 17.2 (1980), pp. 171-177.</p><!-- Meanless: References 243-->
<table><tbody><tr><td>[FJ19]</td><td>Brendan Fong and Michael Johnson. "Lenses and Learners". In: Proceedings of the 8th International Workshop on Bidirectional Transformations Co-Located with the Philadelphia Logic Week, Bx@PLW 2019, Philadelphia, PA, USA, June 4, 2019. Ed. by James Cheney and Hsiang-Shang Ko. Vol. 2355. CEUR Workshop Proceedings. CEUR-WS.org, 2019, pp. 16-29. arXiv: 1903.03671.</td></tr><tr><td>[FST17]</td><td>Brendan Fong, David I. Spivak, and Rémy Tuyéras. "Backprop as Functor: A Compositional Perspective on Supervised Learning". In: (2017). eprint: arXiv:1711.10455.</td></tr><tr><td>[FST19]</td><td>Brendan Fong, David I. Spivak, and Rémy Tuyéras. "Backprop as Functor: A Compositional Perspective on Supervised Learning". In: 34th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2019, Vancouver, BC, Canada, June 24-27, 2019. IEEE, 2019, pp. 1-13. DOI: 10.1109/LICS.2019.8785665.</td></tr><tr><td>[Fre+03]</td><td>Michael Freedman, Alexei Kitaev, Michael Larsen, and Zhenghan Wang. "Topological Quantum Computation". In: Bulletin of the American Mathematical Society 40.1 (2003), pp. 31-38.</td></tr><tr><td>[Fri+20]</td><td>Tobias Fritz, Tomáš Gonda, Paolo Perrone, and Eigil Fjeldgren Rischel. "Representable Markov Categories and Comparison of Statistical Experiments in Categorical Probability". In: ArXiv e-prints (Oct. 29, 2020). arXiv: 2010.07416.</td></tr><tr><td>[FMG15]</td><td>Richard Futrell, Kyle Mahowald, and Edward Gibson. "Large-Scale Evidence of Dependency Length Minimization in 37 Languages". In: Proceedings of the National Academy of Sciences 112.33 (Aug. 18, 2015), pp. 10336-10341. DOI: 10.1073/pnas. 1502134112.</td></tr><tr><td>[Fut21]</td><td>Futurati Podcast. Ep. 52: Bob Coecke and Konstantinos Meichanetzidis on Quantum Natural Language Processing. Sept. 21, 2021. URL: https://www.youtube.com/watch?v=5YZG96t8SLQ (visited on \( {02}/{24}/{2022}) \) .</td></tr><tr><td>[Gai65]</td><td>Haim Gaifman. "Dependency Systems and Phrase-Structure Systems". In: Information and Control 8.3 (June 1, 1965), pp. 304-337. DOI: 10.1016/S0019-9958(65)90232-9.</td></tr><tr><td>[Gav19a]</td><td>Bruno Gavranovic. "Learning Functors Using Gradient Descent". In: Proceedings Applied Category Theory 2019, ACT 2019, University of Oxford, UK, 15-19 July 2019. Ed. by John Baez and Bob Coecke. Vol. 323. EPTCS. 2019, pp. 230-245. DOI: 10.4204/EPTCS. 323.15.</td></tr></tbody></table><!-- Meanless: 244 References-->
<p>[Gav19b] Bruno Gavranović. "Compositional Deep Learning". July 16, 2019. arXiv: 1907.08292.</p>
<p>[GFK10] Daniel Genkin, Nissim Francez, and Michael Kaminski. "Mildly Context-Sensitive Languages via Buffer Augmented Pregroup Grammars". In: Essays in Memory of Amir Pnueli. 2010. DOI: 10.1007/978-3-642-13754-9_7.</p>
<p>[Gen35] Gerhard Gentzen. "Untersuchungen Über Das Logische Schließen. I." In: Mathematische Zeitschrift 35 (1935).</p>
<p>[Gha+18] Neil Ghani, Jules Hedges, Viktor Winschel, and Philipp Zahn. "Compositional Game Theory". In: Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2018, Oxford, UK, July 09-12, 2018. Ed. by Anuj Dawar and Erich Grädel. ACM, 2018, pp. 472-481. DOI: 10.1145/3209108.3209165.</p>
<p>[GF19] Craig Gidney and Austin G. Fowler. "Flexible Layout of Surface Code Computations Using AutoCCZ States". In: ArXiv e-prints (May 21, 2019). arXiv: 1905.08916.</p>
<p>[GLM08] Vittorio Giovannetti, Seth Lloyd, and Lorenzo Maccone. "Quantum Random Access Memory". In: Physical Review Letters 100.16 (Apr. 21, 2008), p. 160501. DOI: 10.1103/PhysRevLett. 100.160501.</p>
<p>[Gir87] Jean-Yves Girard. "Linear Logic". In: Theoretical computer science 50.1 (1987), pp. 1-101.</p>
<p>[GPT20] GPT-3. "A Robot Wrote This Entire Article. Are You Scared yet, Human?" In: The Guardian. Opinion (Sept. 8, 2020). URL: <a href="https://www.theguardian.com/commentisfree/2020/sep/08/robot-wrote-this-article-gpt-3">https://www.theguardian.com/commentisfree/2020/sep/08/robot-wrote-this-article-gpt-3</a> (visited on 11/19/2021).</p>
<p>[Grä02] Erich Grädel. "Model Checking Games". In: Electronic Notes in Theoretical Computer Science. WoLLIC'2002, 9th Workhop on Logic, Language, Information and Computation 67 (Oct. 1, 2002), pp. 15-34. DOI: 10.1016/S1571-0661(04)80538-3.</p>
<p>[Gra+19] Edward Grant, Leonard Wossnig, Mateusz Ostaszewski, and Marcello Benedetti. "An Initialization Strategy for Addressing Barren Plateaus in Parametrized Quantum Circuits". In: Quantum 3 (Dec. 9, 2019), p. 214. DOI: 10.22331/q-2019-12-09-214.</p><!-- Meanless: References 245-->
<table><tbody><tr><td>[Gra44]</td><td>Hermann Grassmann. Die Lineale Ausdehnungslehre Ein Neuer Zweig Der Mathematik: Dargestellt Und Durch Anwendungen Auf Die Übrigen Zweige Der Mathematik, Wie Auch Auf Die Statik, Mechanik, Die Lehre Vom Magnetismus Und Die Krystallonomie Erläutert. Vol. 1. O. Wigand, 1844.</td></tr><tr><td>[GMH13]</td><td>Alex Graves, Abdel-rahman Mohamed, and Geoffrey Hinton. "Speech Recognition with Deep Recurrent Neural Networks". In: 2013 IEEE International Conference on Acoustics, Speech and Signal Processing. Ieee. 2013, pp. 6645-6649.</td></tr><tr><td>[GS11]</td><td>Edward Grefenstette and Mehrnoosh Sadrzadeh. "Experimental Support for a Categorical Compositional Distributional Model of Meaning". In: Proceedings of the 2011 Conference on Empirical Methods in Natural Language Processing, EMNLP 2011, 27-31 July 2011, John McIntyre Conference Centre, Edinburgh, UK, A Meeting of SIGDAT, a Special Interest Group of the ACL. ACL, 2011, pp. 1394-1404. arXiv: 1106.4058.</td></tr><tr><td>[Gre+11]</td><td>Edward Grefenstette, Mehrnoosh Sadrzadeh, Stephen Clark, Bob Coecke, and Stephen Pulman. "Concrete Sentence Spaces for Compositional Distributional Models of Meaning". In: Proceedings of the Ninth International Conference on Computational Semantics, IWCS 2011, January 12-14, 2011, Oxford, UK. Ed. by Johan Bos and Stephen Pulman. The Association for Computer Linguistics, 2011. arXiv: 1101.0309.</td></tr><tr><td>[Gre65]</td><td>Sheila A. Greibach. "A New Normal-Form Theorem for Context-Free Phrase Structure Grammars". In: J. ACM 12.1 (Jan. 1965), pp. 42-52. DOI: 10.1145/321250.321254.</td></tr><tr><td>[Gri83]</td><td>Vyacheslav N Grishin. "On a Generalization of the Ajdukiewicz-Lambek System". In: Studies in nonclassical logics and formal systems 315 (1983), pp. 315-334.</td></tr><tr><td>[GD60]</td><td>Alexandre Grothendieck and Jean Dieudonné. "Eléments de Géométrie Algébrique". In: Publications Mathématiques de l'Institut des Hautes Etudes Scientifiques 4.1 (1960), pp. 5-214.</td></tr><tr><td>[Gro97]</td><td>Lov K. Grover. "Quantum Mechanics Helps in Searching for a Needle in a Haystack". In: Physical Review Letters 79.2 (July 14, 1997), pp. 325-328. DOI: 10.1103/PhysRevLett. 79.325. arXiv: quant-ph/9706033.</td></tr><tr><td>[Had21]</td><td>Stuart Hadfield. "On the Representation of Boolean and Real Functions as Hamiltonians for Quantum Computing". In: ACM Transactions on Quantum Computing 2.4 (Dec. 21, 2021), 18:1-18:21. DOI: 10.1145/3478519.</td></tr></tbody></table><!-- Meanless: 246 References-->
<p>[HNW18] Amar Hadzihasanovic, Kang Feng Ng, and Quanlong Wang. "Two Complete Axiomatisations of Pure-state Qubit Quantum Computing". In: Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science (Oxford, United Kingdom). LICS '18. New York, NY, USA: ACM, 2018, pp. 502-511. DOI: 10.1145/3209108.3209128.</p>
<p>[HSS08] Aric Hagberg, Pieter Swart, and Daniel S Chult. Exploring Network Structure, Dynamics, and Function Using Networkx. LA-UR-08-05495; LA-UR-08-5495. Los Alamos National Lab. (LANL), Los Alamos, NM (United States), Jan. 1, 2008. URL: <a href="https://www.osti.gov/biblio/960616">https://www.osti.gov/biblio/960616</a> (visited on 01/27/2022).</p>
<p>[Hak61] Wolfgang Haken. "Theorie Der Normalflächen". In: Acta Mathematica 105.3 (1961), pp. 245-375.</p>
<p>[Har54] Zellig S. Harris. "Distributional Structure". In: WORD 10.2-3 (Aug. 1, 1954), pp. 146-162. DOI: 10.1080/00437956.1954.11659520.</p>
<p>[HHL09] Aram W. Harrow, Avinatan Hassidim, and Seth Lloyd. "Quantum Algorithm for Linear Systems of Equations". In: Physical Review Letters 103.15 (Oct. 7, 2009), p. 150502. DOI: 10.1103/PhysRevLett. 103.150502.</p>
<p>[Hau89] John Haugeland. Artificial Intelligence: The Very Idea. MIT press, 1989.</p>
<p>[Hav+19] Vojtech Havlicek, Antonio D. Córcoles, Kristan Temme, Aram W. Harrow, Abhinav Kandala, Jerry M. Chow, and Jay M. Gambetta. "Supervised Learning with Quantum Enhanced Feature Spaces". In: Nature 567.7747 (Mar. 2019), pp. 209-212. DOI: 10.1038/s41586-019-0980-2. arXiv: 1804.11326.</p>
<p>[HS20] Nathan Haydon and Pawel Sobocinski. "Compositional Diagrammatic First-Order Logic". In: (2020), p. 16.</p>
<p>[Heb49] Donald Olding Hebb. The Organisation of Behaviour: A Neuropsychological Theory. Science Editions New York, 1949.</p>
<p>[Hed17] Jules Hedges. "Coherence for Lenses and Open Games". In: ArXiv e-prints (Apr. 7, 2017). arXiv: 1704.02230.</p>
<p>[Hed19] Jules Hedges. "From Open Learners to Open Games". In: ArXiv e-prints (Feb. 22, 2019). arXiv: 1902.08666.</p>
<p>[HL18] Jules Hedges and Martha Lewis. "Towards Functorial Language-Games". In: ArXiv e-prints (July 20, 2018). arXiv: 1807.07828.</p>
<p>[Heg12] Georg Wilhelm Friedrich Hegel. Wissenschaft Der Logik. F. Frommann, 1812.</p><!-- Meanless: References 247-->
<p>[Hen+20] Loic Henriet, Lucas Beguin, Adrien Signoles, Thierry Lahaye, Antoine Browaeys, Georges-Olivier Reymond, and Christophe Jurczak. "Quantum Computing with Neutral Atoms". In: Quantum 4 (Sept. 21, 2020), p. 327. DOI: 10.22331/q-2020-09-21-327. arXiv: 2006.12326 [quant-ph].</p>
<p>[HV19] Chris Heunen and Jamie Vicary. Categories for Quantum Theory: An Introduction. Oxford University Press, Sept. 30, 2019. 337 pp. DOI: 10.1093/oso/9780198739623.001.0001. Google Books: PdG8DwAAQBAJ.</p>
<p>[Hil97] Melanie Hilario. "An Overview of Strategies for Neurosymbolic Integration". In: Connectionist-Symbolic Integration: From Unified to Hybrid Approaches (1997), pp. 13-36.</p>
<p>[HA28] D Hilbert and W Ackerman. "Theoretische Logik". In: Julius Springer, Berlin (1928).</p>
<p>[Hoc98] Sepp Hochreiter. "The Vanishing Gradient Problem During Learning Recurrent Neural Nets and Problem Solutions". In: International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems 06.02 (Apr. 1998), pp. 107-116. DOI: 10.1142/S0218488598000094.</p>
<p>[HS97] Sepp Hochreiter and Jürgen Schmidhuber. "Long Short-term Memory". In: Neural computation 9 (Dec. 1, 1997), pp. 1735-80. DOI: 10.1162/neco.1997.9.8.1735.</p>
<p>[Hof16] Philipp H. W. Hoffmann. "A Hitchhiker's Guide to Automatic Differentiation". In: Numerical Algorithms 72.3 (July 2016), pp. 775-811. DOI: 10.1007/s11075-015-0067-6. arXiv: 1411.0583.</p>
<p>[Hof21] Thomas Hoffmann. "Quantum Models for Word- Sense Disambiguation". In: (2021). URL:</p>
<p><a href="https://odr.chalmers.se/handle/20.500.12380/302687">https://odr.chalmers.se/handle/20.500.12380/302687</a> (visited on \({12}/{02}/{2021})\) .</p>
<p>[HM17] Matthew Honnibal and Ines Montani. "spaCy 2: Natural Language Understanding with Bloom Embeddings, Convolutional Neural Networks and Incremental Parsing". In: To appear 7.1 (2017), pp. 411-420.</p>
<p>[Hot65] Günter Hotz. "Eine Algebraisierung Des Syntheseproblems von Schaltkreisen I". Trans. by Johannes Drever. In: Elektronische Informationsverarbeitung und Kybernetik 1 (1965), pp. 185-205. URL: <a href="https://github.com/drever/hotz-translation">https://github.com/drever/hotz-translation</a> (visited on \({05}/{10}/{2022})\) .</p><!-- Meanless: 248 References-->
<p>[Hot66] Günter Hotz. "Eindeutigkeit Und Mehrdeutigkeit Formaler Sprachen". In: J. Inf. Process. Cybern. (1966). DOI: 10.5604/16431243.1040101.</p>
<p>[Hun07] John D. Hunter. "Matplotlib: A 2D Graphics Environment". In: Computing in Science Engineering 9.3 (May 2007), pp. 90-95. DOI: 10.1109/MCSE.2007.55.</p>
<p>[Hut04] W John Hutchins. "The Georgetown-Ibm Experiment Demonstrated in January 1954". In: Conference of the Association for Machine Translation in the Americas. Springer. 2004, pp. 102-114.</p>
<p>[Huy84] Riny Huybregts. "The Weak Inadequacy of Context-Free Phrase Structure Grammars". In: Van Periferie Naar Kern. Ed. by G.J. de Haan, M. Trommelen, and W. Zonneveld. Foris Dordrecht, 1984, pp. 81-99.</p>
<p>[Ins20] The Quantum Insider. CQC Researchers Make Major Quantum NLP Advance in Steps Toward 'Meaning Aware' Computers. Dec. 10, 2020. URL: <a href="https://thequantuminsider.com/2020/12/10/meaning-aware-computers-cqc-researchers-make-major-nlp-advance-in-using-quantum-computers-to-understand-language-and-towards-achieving-meaningful-quantum-advantage/">https://thequantuminsider.com/2020/12/10/meaning-aware-computers-cqc-researchers-make-major-nlp-advance-in-using-quantum-computers-to-understand-language-and-towards-achieving-meaningful-quantum-advantage/</a> (visited on 02/24/2022).</p>
<p>[JPV22] Emmanuel Jeandel, Simon Perdrix, and Margarita Veshchezerova. "Addition and Differentiation of ZX-diagrams". In: ArXiv e-prints (Feb. 23, 2022). arXiv: 2202.11386.</p>
<p>[JPV18] Emmanuel Jeandel, Simon Perdrix, and Renaud Vilmart. "A Complete Axiomatisation of the ZX-Calculus for Clifford+T Quantum Mechanics". In: Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science (Oxford, United Kingdom). LICS '18. New York, NY, USA: ACM, 2018, pp. 559-568. DOI: 10.1145/3209108.3209131.</p>
<p>[Jef97] Alan Jeffrey. "Premonoidal Categories and a Graphical View of Programs". In: Preprint, Dec (1997).</p>
<p>[JL74] Neil D Jones and William T Laaser. "Complete Problems for Deterministic Polynomial Time". In: Proceedings of the Sixth Annual ACM Symposium on Theory of Computing. 1974, pp. 40-46.</p>
<p>[JS88] André Joyal and Ross Street. "Planar Diagrams and Tensor Algebra". In: Unpublished manuscript, available from Ross Street's website (1988).</p>
<p>[JS91] André Joyal and Ross Street. "The Geometry of Tensor Calculus, I". In: Advances in Mathematics 88.1 (July 1, 1991), pp. 55-112. DOI: 10.1016/0001-8708(91)90003-P.</p><!-- Meanless: References 249-->
<p>[JS95] André Joyal and Ross Street. "The Geometry of Tensor Calculus II". In: Unpublished draft, available from Ross Street's website 312 (1995), p. 313.</p>
<p>[JSV96] André Joyal, Ross Street, and Dominic Verity. "Traced Monoidal Categories". In: Mathematical Proceedings of the Cambridge Philosophical Society 119.3 (Apr. 1996), pp. 447-468. DOI: 10.1017/S0305004100074338.</p>
<p>[Kal10] Laura Kallmeyer. Parsing Beyond Context-Free Grammars. Vol. 0. Cognitive Technologies. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010. DOI: 10.1007/978-3-642-14846-0.</p>
<p>[Kan+17] Abhinav Kandala, Antonio Mezzacapo, Kristan Temme, Maika Takita, Markus Brink, Jerry M Chow, and Jay M Gambetta. "Hardware-Efficient Variational Quantum Eigensolver for Small Molecules and Quantum Magnets". In: Nature 549.7671 (2017), pp. 242-246.</p>
<p>[Kan81] Immanuel Kant. Critique of Pure Reason. Trans. by Norman Kemp Smith. Read Books Ltd. (2011), 1781.</p>
<p>[Kar16] Dimitri Kartsaklis. "Coordination in Categorical Compositional Distributional Semantics". In: Proceedings of the 2016 Workshop on Semantic Spaces at the Intersection of NLP, Physics and Cognitive Science, SLPCS@QPL 2016, Glasgow, Scotland, 11th June 2016. (2016), pp. 29-38. URL: <a href="https://drive.google.com/file/d/">https://drive.google.com/file/d/</a> OB4LXUZHM9v1gYjB5QkhhWDh6Nnc/view?usp=sharing.</p>
<p>[Kar+21] Dimitri Kartsaklis, Ian Fan, Richie Yeung, Anna Pearson, Robin Lorenz, Alexis Toumi, Giovanni de Felice, Konstantinos Meichanetzidis, Stephen Clark, and Bob Coecke. "Lambeq: An Efficient High-Level Python Library for Quantum NLP". In: CoRR abs/2110.04236 (2021). arXiv: 2110.04236.</p>
<p>[KS15] Dimitri Kartsaklis and Mehrnoosh Sadrzadeh. "A Frobenius Model of Information Structure in Categorical Compositional Distributional Semantics". In: CoRR abs/1505.06294 (2015). URL: <a href="http://arxiv.org/abs/1505.06294">http://arxiv.org/abs/1505.06294</a>.</p>
<p>[KSP12] Dimitri Kartsaklis, Mehrnoosh Sadrzadeh, and Stephen Pulman. "A Unified Sentence Space for Categorical Distributional-Compositional Semantics: Theory and Experiments". In: COLING 2012, 24th International Conference on Computational Linguistics, Proceedings of the Conference: Posters, 8-15 December 2012, Mumbai, India. Ed. by Martin Kay and Christian Boitet. Indian Institute of Technology Bombay, 2012, pp. 549-558. URL: <a href="https://aclanthology.org/C12-2054/">https://aclanthology.org/C12-2054/</a>.</p><!-- Meanless: 250 References-->
<p>[KSP13] Dimitri Kartsaklis, Mehrnoosh Sadrzadeh, and Stephen Pulman. "Separating Disambiguation from Composition in Distributional Semantics". In: Proceedings of the Seventeenth Conference on Computational Natural Language Learning, CoNLL 2013, Sofia, Bulgaria, August 8-9, 2013. Ed. by Julia Hockenmaier and Sebastian Riedel. ACL, 2013, pp. 114-123. URL: <a href="https://aclanthology.org/W13-3513/">https://aclanthology.org/W13-3513/</a>.</p>
<p>[KP16] Iordanis Kerenidis and Anupam Prakash. "Quantum Recommendation Systems". In: ArXiv e-prints (Mar. 29, 2016). arXiv: 1603.08675.</p>
<p>[KOK20] Joon-Hwi Kim, Maverick S. H. Oh, and Keun-Young Kim. "Boosting Vector Calculus with the Graphical Notation". In: ArXiv e-prints (Jan. 8, 2020). arXiv: 1911.00892.</p>
<p>[KU19] Aleks Kissinger and Sander Uijlen. "A Categorical Semantics for Causal Structure". In: ArXiv e-prints (2019). DOI:</p>
<p>10.23638/LMCS-15(3:15)2019. arXiv: 1701.04732.</p>
<p>[KvdW19] Aleks Kissinger and John van de Wetering. "PyZX: Large Scale Automated Diagrammatic Reasoning". In: ArXiv e-prints (Apr. 9, 2019). arXiv: 1904.04735.</p>
<p>[KvdW20] Aleks Kissinger and John van de Wetering. "Reducing T-count with the ZX-calculus". In: Physical Review A 102.2 (Aug. 11, 2020), p. 022406. DOI: 10.1103/PhysRevA. 102.022406. arXiv: 1903.10477.</p>
<p>[KZ15] Aleks Kissinger and Vladimir Zamdzhiev. "Quantomatic: A Proof Assistant for Diagrammatic Reasoning". In: Automated Deduction - \({CADE}\) -25. Ed. by Amy P. Felty and Aart Middeldorp. Lecture Notes in Computer Science. Springer International Publishing, 2015, pp. 326-336. arXiv: 1503.01034.</p>
<p>[Kit95] A. Yu Kitaev. "Quantum Measurements and the Abelian Stabilizer Problem". In: ArXiv e-prints (Nov. 20, 1995). arXiv: quant-ph/9511026.</p>
<p>[Kit03] A. Yu. Kitaev. "Fault-Tolerant Quantum Computation by Anyons". In: Annals of Physics 303.1 (Jan. 1, 2003), pp. 2-30. DOI: 10.1016/S0003-4916(02)00018-0.</p>
<p>[KN19] Steve Klabnik and Carol Nichols. The Rust Programming Language (Covers Rust 2018). No Starch Press, 2019.</p><!-- Meanless: References 251-->
<p>[Klu+16] Thomas Kluyver, Benjamin Ragan-Kelley, Fernando Pérez,</p>
<p>Brian E. Granger, Matthias Bussonnier, Jonathan Frederic, Kyle Kelley, Jessica B. Hamrick, Jason Grout, Sylvain Corlay, Paul Ivanov, Damián Avila, Safia Abdalla, Carol Willing, and</p>
<p>Jupyter Development Team. "Jupyter Notebooks - a Publishing Format for Reproducible Computational Workflows". In: Positioning and Power in Academic Publishing: Players, Agents and Agendas, 20th International</p>
<p>Conference on Electronic Publishing, Göttingen, Germany, June 7-9, 2016. Ed. by Fernando Loizides and Birgit Schmidt. IOS Press, 2016, pp. 87-90. DOI: 10.3233/978-1-61499-649-1-87.</p>
<p>[Knu68] Donald E. Knuth. "Semantics of Context-Free Languages". In: Mathematical Systems Theory. 1968, pp. 127-145.</p>
<p>[Kok+07] Pieter Kok, W. J. Munro, Kae Nemoto, T. C. Ralph, Jonathan P. Dowling, and G. J. Milburn. "Linear Optical Quantum Computing with Photonic Qubits". In: Reviews of Modern Physics 79.1 (Jan. 24, 2007), pp. 135-174. DOI: 10.1103/RevModPhys. 79.135.</p>
<p>[Kur64] S-Y Kuroda. "Classes of Languages and Linear-Bounded Automata". In: Information and control 7.2 (1964), pp. 207-223.</p>
<p>[Lac15] Marc Lackenby. "A Polynomial Upper Bound on Reidemeister Moves". In: Annals of Mathematics (2015), pp. 491-564.</p>
<p>[LF11] Adam Lally and Paul Fodor. "Natural Language Processing with Prolog in the IBM Watson System". In: The Association for Logic Programming (ALP) Newsletter 9 (2011).</p>
<p>[Lam88] J. Lambek. "Categorial and Categorical Grammars". In: Categorial Grammars and Natural Language Structures. Ed. by Richard T. Oehrle, Emmon Bach, and Deirdre Wheeler. Studies in Linguistics and Philosophy. Dordrecht: Springer Netherlands, 1988, pp. 297-317. DOI: 10.1007/978-94-015-6878-4_11.</p>
<p>[Lam10] J. Lambek. "Compact Monoidal Categories from Linguistics to Physics". In: New Structures for Physics. Ed. by Bob Coecke. Vol. 813. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, pp. 467-487. DOI: 10.1007/978-3-642-12821-9_8.</p>
<p>[Lam58] Joachim Lambek. "The Mathematics of Sentence Structure". In: The American Mathematical Monthly 65.3 (Mar. 1, 1958), pp. 154-170. DOI: 10.1080/00029890.1958.11989160.</p><!-- Meanless: 252 References-->
<p>[Lam59] Joachim Lambek. "Contributions to a Mathematical Analysis of the English Verb-phrase". In: Canadian Journal of Linguistics/Revue canadienne de linguistique 5.2 (1959), pp. 83-89. DOI: 10.1017/S0008413100018715.</p>
<p>[Lam61] Joachim Lambek. "On the Calculus of Syntactic Types". In: Structure of Language and Its Mathematical Aspects. Ed. by Roman Jakobson. Vol. 12. Proceedings of Symposia in Applied Mathematics. American Mathematical Society, 1961, pp. 166-178. DOI: 10.1090/psapm/012.</p>
<p>[Lam68] Joachim Lambek. "Deductive Systems and Categories". In: Mathematical Systems Theory 2.4 (1968), pp. 287-318.</p>
<p>[Lam69] Joachim Lambek. "Deductive Systems and Categories II. Standard Constructions and Closed Categories". In: Category Theory, Homology Theory and Their Applications I. Springer, 1969, pp. 76-122.</p>
<p>[Lam72] Joachim Lambek. "Deductive Systems and Categories III. Cartesian Closed Categories, Intuitionist Propositional Calculus, and Combinatory Logic". In: Toposes, Algebraic Geometry and Logic. Springer, 1972, pp. 57-82.</p>
<p>[Lam99a] Joachim Lambek. "Deductive Systems and Categories in Linguistics". In: Logic, Language and Reasoning. Ed. by Hans Jürgen Ohlbach and Uwe Reyle. Red. by Ryszard Wójcicki, Petr Hájek, David Makinson, Daniele Mundici, Krister Segerberg, and Alasdair Urquhart. Vol. 5. Trends in Logic. Dordrecht: Springer Netherlands, 1999, pp. 279-294. DOI: 10.1007/978-94-011-4574-9_12.</p>
<p>[Lam99b] Joachim Lambek. "Type Grammar Revisited". In: Logical Aspects of Computational Linguistics. Ed. by Alain Lecomte, François Lamarche, and Guy Perrier. Berlin, Heidelberg: Springer Berlin Heidelberg, 1999, pp. 1-27.</p>
<p>[Lam01] Joachim Lambek. "Type Grammars as Pregroups". In: Grammars 4 (2001), pp. 21-39. DOI: 10.1023/A: 1011444711686.</p>
<p>[Lam08] Joachim Lambek. From Word to Sentence: A Computational Algebraic Approach to Grammar. Open Access Publications. Polimetrica, 2008.</p>
<p>[Lam14] Joachim Lambek. From Rules of Grammar to Laws of Nature. Commack, NY, USA: Nova Science Publishers, Inc., 2014.</p>
<p>[Lan17] Łukasz Langa. Postponed Evaluation of Annotations. PEP 563. 2017. URL: <a href="https://peps.python.org/pep-0563/">https://peps.python.org/pep-0563/</a> (visited on 03/28/2022).</p>
<p>[Lau05] Aaron D. Lauda. "Frobenius Algebras and Planar Open String Topological Field Theories". In: ArXiv e-prints (Aug. 18, 2005). arXiv: math/0508349.</p><!-- Meanless: References 253-->
<p>[LR19] Elena Di Lavore and Mario Román. "Optic Embeds into the Int Construction". In: (2019), p. 3. URL:</p>
<p><a href="https://www.ioc.ee/~mroman/data/notes/opticembedsint.pdf">https://www.ioc.ee/~mroman/data/notes/opticembedsint.pdf</a>.</p>
<p>[Law64] F William Lawvere. "An Elementary Theory of the Category of Sets". In: Proceedings of the National academy of Sciences of the United States of America 52.6 (1964), p. 1506.</p>
<p>[Law70a] F William Lawvere. "Quantifiers and Sheaves". In: Actes Du Congres International Des Mathematiciens, Nice. Vol. 1. 1970, pp. 329-334.</p>
<p>[Law79] F William Lawvere. "Categorical Dynamics". In: Topos theoretic methods in geometry 30 (1979), pp. 1-28.</p>
<p>[Law89] F William Lawvere. "Display of Graphics and Their Applications, as Exemplified by 2-Categories and the Hegelian "Taco"". In: Proceedings of the First International Conference on Algebraic Methodology and Software Technology, University of Iowa. 1989, pp. 51-74.</p>
<p>[LS86] F William Lawvere and Stephen H Schanuel. Categories in Continuum Physics: Lectures given at a Workshop Held at SUNY, Buffalo 1982. Lecture Notes in Mathematics 1174. Springer, 1986.</p>
<p>[Law63] F. William Lawvere. "Functorial Semantics of Algebraic Theories". In: Proceedings of the National Academy of Sciences of the United States of America 50.5 (1963), pp. 869-872. JSTOR: 71935.</p>
<p>[Law66] F. William Lawvere. "The Category of Categories as a Foundation for Mathematics". In: Proceedings of the Conference on Categorical Algebra. Ed. by S. Eilenberg, D. K. Harrison, S. MacLane, and H. Röhrl. Springer Berlin Heidelberg, 1966, pp. 1-20.</p>
<p>[Law69] F. William Lawvere. "Adjointness in Foundations". In: Dialectica 23.34 (1969), pp. 281-296. DOI: 10.1111/j. 1746-8361.1969. tb01194. x.</p>
<p>[Law70b] F. William Lawvere. "Equality in Hyperdoctrines and the Comprehension Schema as an Ad-Joint Functor". In: 1970.</p>
<p>[Law91] F. William Lawvere. "Some Thoughts on the Future of Category Theory". In: Category Theory. Ed. by Aurelio Carboni, Maria Cristina Pedicchio, and Guiseppe Rosolini. Vol. 1488. Lecture Notes in Mathematics. Berlin, Heidelberg: Springer Berlin Heidelberg, 1991, pp. 1-13. URL: <a href="http://link.springer.com/10.1007/BFb0084208">http://link.springer.com/10.1007/BFb0084208</a> (visited on 12/15/2021).</p><!-- Meanless: 254 References-->
<p>[Law92] F. William Lawvere. "Categories of Space and of Quantity". In: The Space of Mathematics. Ed. by Javier Echeverria, Andoni Ibarra, and</p>
<p>Thomas Mormann. Berlin, Boston: DE GRUYTER, Jan. 31, 1992. DOI: 10.1515/9783110870299.14.</p>
<p>[Law96] F. William Lawvere. "Unity and Identity of Opposites in Calculus and Physics". In: Applied Categorical Structures 4.2-3 (1996), pp. 167-174. DOI: 10.1007/BF00122250.</p>
<p>[Lev17] Ivan Levkivskyi. Core Support for Typing Module and Generic Types. PEP 560. 2017. URL: <a href="https://peps.python.org/pep-0560/">https://peps.python.org/pep-0560/</a> (visited on \({03}/{28}/{2022})\) .</p>
<p>[Llo+11a] Seth Lloyd, Lorenzo Maccone, Raul Garcia-Patron, Vittorio Giovannetti, and Yutaka Shikano. "Quantum Mechanics of Time Travel through Post-Selected Teleportation". In: Physical Review D 84.2 (July 13, 2011), p. 025007. DOI: 10.1103/PhysRevD. 84.025007.</p>
<p>[Llo+11b] Seth Lloyd, Lorenzo Maccone, Raul Garcia-Patron, Vittorio Giovannetti, Yutaka Shikano, Stefano Pirandola, Lee A. Rozema, Ardavan Darabi, Yasaman Soudagar, Lynden K. Shalm, and Aephraim M. Steinberg. "Closed Timelike Curves via Postselection: Theory and Experimental Test of Consistency". In: Physical Review Letters 106.4 (Jan. 27, 2011), p. 040403. DOI: 10.1103/PhysRevLett. 106.040403.</p>
<p>[LMR13] Seth Lloyd, Masoud Mohseni, and Patrick Rebentrost. "Quantum Algorithms for Supervised and Unsupervised Machine Learning". In: ArXiv e-prints (Nov. 4, 2013). arXiv: 1307.0411.</p>
<p>[LMR14] Seth Lloyd, Masoud Mohseni, and Patrick Rebentrost. "Quantum Principal Component Analysis". In: Nature Physics 10.9 (Sept. 2014), pp. 631-633. DOI: 10.1038/nphys3029. arXiv: 1307.0401.</p>
<p>[LB02] Edward Loper and Steven Bird. "NLTK: The Natural Language Toolkit". In: ArXiv e-prints (May 17, 2002). arXiv: cs/0205028.</p>
<p>[Lor+21] Robin Lorenz, Anna Pearson, Konstantinos Meichanetzidis, Dimitri Kartsaklis, and Bob Coecke. "QNLP in Practice: Running Compositional Models of Meaning on a Quantum Computer". In: ArXiv e-prints (Feb. 25, 2021). arXiv: 2102.12846.</p>
<p>[Ma+19] Yunpu Ma, Volker Tresp, Liming Zhao, and Yuyi Wang. "Variational Quantum Circuit Model for Knowledge Graphs Embedding". In: ArXiv e-prints (Feb. 19, 2019). arXiv: 1903.00556.</p><!-- Meanless: References 255-->
<p>[Mac21] Machine Learning Street Talk. #53 Quantum Natural Language Processing</p>
<ul>
<li>Prof Bob Coecke. 2021. URL:</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=X9uSV1YcOy4">https://www.youtube.com/watch?v=X9uSV1YcOy4</a> (visited on \({02}/{24}/{2022})\) .</p>
<p>[Mac38] Saunders MacLane. "Carnap on Logical Syntax". In: Bulletin of the American Mathematical Society 44.3 (1938), pp. 171-176.</p>
<p>[Mac71] Saunders MacLane. Categories for the Working Mathematician. Graduate Texts in Mathematics. Springer New York, 1971. URL: <a href="https://books.google.fr/books?id=eBvhyc4z8HQC">https://books.google.fr/books?id=eBvhyc4z8HQC</a>.</p>
<p>[Man80] Yuri Manin. "Computable and Uncomputable". In: Sovetskoye Radio, Moscow 128 (1980).</p>
<p>[Man+14] Christopher D Manning, Mihai Surdeanu, John Bauer, Jenny Rose Finkel, Steven Bethard, and David McClosky. "The Stanford CoreNLP Natural Language Processing Toolkit". In: Proceedings of 52nd Annual Meeting of the Association for Computational Linguistics: System Demonstrations. 2014, pp. 55-60.</p>
<p>[Mar47] A Markov. "On Certain Insoluble Problems Concerning Matrices". In: Doklady Akad. Nauk SSSR. Vol. 57. 6. 1947, pp. 539-542.</p>
<p>[McC+18] Jarrod R. McClean, Sergio Boixo, Vadim N. Smelyanskiy, Ryan Babbush, and Hartmut Neven. "Barren Plateaus in Quantum Neural Network Training Landscapes". In: Nature Communications 9.1 (Dec. 2018), p. 4812. DOI: 10.1038/s41467-018-07090-4. arXiv: 1803.11173.</p>
<p>[McC+16] Jarrod R McClean, Jonathan Romero, Ryan Babbush, and Alán Aspuru-Guzik. "The Theory of Variational Hybrid Quantum-Classical Algorithms". In: New Journal of Physics 18.2 (Feb. 4, 2016), p. 023023. DOI: 10.1088/1367-2630/18/2/023023.</p>
<p>[MP43] Warren S McCulloch and Walter Pitts. "A Logical Calculus of the Ideas Immanent in Nervous Activity". In: The bulletin of mathematical biophysics 5.4 (1943), pp. 115-133.</p>
<p>[McP+21] Lachlan McPheat, Gijs Wijnholds, Mehrnoosh Sadrzadeh, Adriana Correia, and Alexis Toumi. "Anaphora and Ellipsis in Lambek Calculus with a Relevant Modality: Syntax and Semantics". In: CoRR abs/2110.10641 (2021). arXiv: 2110.10641.</p><!-- Meanless: 256 References-->
<p>[Mei+20a] Konstantinos Meichanetzidis, Stefano Gogioso, Giovanni de Felice, Nicolò Chiappori, Alexis Toumi, and Bob Coecke. "Quantum Natural Language Processing on Near-Term Quantum Computers". In: Proceedings 17th International Conference on Quantum Physics and Logic, QPL 2020, Paris, France, June 2 - 6, 2020. Ed. by Benoît Valiron, Shane Mansfield, Pablo Arrighi, and Prakash Panangaden. Vol. 340. EPTCS. 2020, pp. 213-229. DOI: 10.4204/EPTCS. 340.11. arXiv: 2005.04147.</p>
<p>[Mei+20b] Konstantinos Meichanetzidis, Alexis Toumi, Giovanni de Felice, and Bob Coecke. "Grammar-Aware Question-Answering on Quantum Computers". In: ArXiv e-prints (2020). arXiv: 2012.03756.</p>
<p>[Mel06] Paul-André Melliès. "Functorial Boxes in String Diagrams". In: Computer Science Logic. Ed. by Zoltán Ésik. Lecture Notes in Computer Science. Springer Berlin Heidelberg, 2006, pp. 1-30. DOI: 10.1023/A: 1024247613677.</p>
<p>[MZ16] Paul-André Melliès and Noam Zeilberger. "A Bifibrational Reconstruction of Lawvere's Presheaf Hyperdoctrine". In: ArXiv e-prints (Aug. 12, 2016). arXiv: 1601.06098.</p>
<p>[Meu+17] Aaron Meurer, Christopher P. Smith, Mateusz Paprocki, Ondřej Čertík, Sergey B. Kirpichev, Matthew Rocklin, AMiT Kumar, Sergiu Ivanov, Jason K. Moore, Sartaj Singh, Thilina Rathnayake, Sean Vig, Brian E. Granger, Richard P. Muller, Francesco Bonazzi, Harsh Gupta, Shivam Vats, Fredrik Johansson, Fabian Pedregosa, Matthew J. Curry, Andy R. Terrel, Štěpán Roučka, Ashutosh Saboo, Isuru Fernando, Sumith Kulal, Robert Cimrman, and Anthony Scopatz. "SymPy: Symbolic Computing in Python". In: PeerJ Computer Science 3 (Jan. 2017), e103. DOI: 10.7717/peerj-cs.103.</p>
<p>[MK97] Jens Michaelis and Marcus Kracht. "Semilinearity as a Syntactic Invariant". In: Logical Aspects of Computational Linguistics. Ed. by Christian Retoré. Red. by Jaime G. Carbonell, Jörg Siekmann, G. Goos, J. Hartmanis, and J. van Leeuwen. Vol. 1328. Berlin, Heidelberg: Springer Berlin Heidelberg, 1997, pp. 329-345. DOI: 10.1007/BFb0052165.</p>
<p>[Mil14] Bartosz Milewski. Functors Are Containers. Bartosz 's Programming Cafe. Jan. 14, 2014. URL: https:</p>
<p>//bartoszmilewski.com/2014/01/14/functors-are-containers/ (visited on \({03}/{28}/{2022}\) ).</p><!-- Meanless: References 257-->
<p>[Mir+21] Eduardo Reck Miranda, Richie Yeung, Anna Pearson, Konstantinos Meichanetzidis, and Bob Coecke. "A Quantum Natural Language Processing Approach to Musical Intelligence". In: ArXiv e-prints (Nov. 10, 2021). arXiv: 2111.06741.</p>
<p>[Mog91] Eugenio Moggi. "Notions of Computation and Monads". In: Information and computation 93.1 (1991), pp. 55-92.</p>
<p>[Mol21] Paula Garcia Molina. QNLP Qiskit Hackathon. Oct. 22, 2021. URL: <a href="https://github.com/PaulaGarciaMolina/QNLP_Qiskit_Hackathon">https://github.com/PaulaGarciaMolina/QNLP_Qiskit_Hackathon</a> (visited on \({02}/{24}/{2022}\) ).</p>
<p>[Mon70] Richard Montague. "Universal Grammar". In: Theoria 36.3 (1970), pp. 373-398. DOI: 10.1111/j.1755-2567.1970. tb00434. x.</p>
<p>[Mon73] Richard Montague. "The Proper Treatment of Quantification in Ordinary English". In: Approaches to Natural Language (1973). Ed. by K. J. J. Hintikka, J. Moravcsic, and P. Suppes, pp. 221-242.</p>
<p>[Mon74] Richard Montague. "English as a Formal Language". In: Formal Philosophy. Selected Papers of Richard Montague. Ed. by R.H. Thomason. Yale University Press, New Haven, 1974, pp. 188-221.</p>
<p>[Moo97] Michael Moortgat. "Categorial Type Logics". In: Handbook of Logic and Language. Ed. by Johan van Benthem and Alice ter Meulen. Elsevier/MIT Press, 1997, pp. 93-177. URL:</p>
<p><a href="https://doi.org/10.1016/B978-044481714-3/50005-9">https://doi.org/10.1016/B978-044481714-3/50005-9</a>.</p>
<p>[Moo09] Michael Moortgat. "Symmetric Categorial Grammar". In: Journal of Philosophical Logic 38.6 (Oct. 16, 2009), p. 681. DOI: 10.1007/s10992-009-9118-6.</p>
<p>[Moo14] Michael Moortgat. "Typelogical Grammar". In: The Stanford Encyclopedia of Philosophy. Ed. by Edward N. Zalta. Spring 2014. Metaphysics Research Lab, Stanford University, 2014. URL: https:</p>
<p>//plato.stanford.edu/archives/spr2014/entriesypelogical-grammar/ (visited on \({03}/{04}/{2022}\) ).</p>
<p>[MP02] Richard Moot and Quintijn Puite. "Proof Nets for the Multimodal Lambek Calculus". In: Stud Logica 71.3 (2002), pp. 415-442. DOI: 10.1023/A: 1020525032763.</p>
<p>[nLa] nLab. Concept with an Attitude in nLab. URL: <a href="https://ncatlab.org/nlab/show/concept+with+an+attitude">https://ncatlab.org/nlab/show/concept+with+an+attitude</a> (visited on \({12}/{22}/{2021})\) .</p><!-- Meanless: 258 References-->
<p>[Oeh04] R Oehrle. "A Parsing Algorithm for Pregroup Grammars". In: Proceedings of Categorial Grammars, Montpellier France (Jan. 2004), pp. 59-75.</p>
<p>[Par61] Rohit J Parikh. "Language Generating Devices". In: Quarterly Progress Report 60 (1961), pp. 199-212.</p>
<p>[Par66] Rohit J. Parikh. "On Context-Free Languages". In: Journal of the ACM 13.4 (Oct. 1, 1966), pp. 570-581. DOI: 10.1145/321356.321364.</p>
<p>[Pat17] Evan Patterson. "Knowledge Representation in Bicategories of Relations". In: ArXiv e-prints (June 1, 2017). arXiv: 1706.00526.</p>
<p>[PSV21] Evan Patterson, David I. Spivak, and Dmitry Vagner. "Wiring Diagrams as Normal Forms for Computing in Symmetric Monoidal Categories". In: ArXiv e-prints (Jan. 25, 2021). DOI: 10.4204/EPTCS. 333.4. arXiv: 2101.12046.</p>
<p>[Ped+19] Edwin Pednault, John A. Gunnels, Giacomo Nannicini, Lior Horesh, and Robert Wisnieff. "Leveraging Secondary Storage to Simulate Deep 54-Qubit Sycamore Circuits". In: ArXiv e-prints (Oct. 22, 2019). arXiv: 1910.09534.</p>
<p>[Pei06] Charles Santiago Sanders Peirce. "Prolegomena to an Apology of Pragmaticism". In: The Monist 16.4 (1906), pp. 492-546. JSTOR: 27899680.</p>
<p>[Pel01] Francis Jeffry Pelletier. "Did Frege Believe Frege's Principle?" In: Journal of Logic, Language and information 10.1 (2001), pp. 87-114.</p>
<p>[Pen71] Roger Penrose. "Applications of Negative Dimensional Tensors". In: Combinatorial mathematics and its applications 1 (1971), pp. 221-244. URL: <a href="http://www.math.uic.edu/~kauffman/Penrose.pdf">http://www.math.uic.edu/~kauffman/Penrose.pdf</a> (visited on \({05}/{10}/{2022})\) .</p>
<p>[PR84] Roger Penrose and Wolfgang Rindler. Spinors and Space-Time: Volume 1: Two-Spinor Calculus and Relativistic Fields. Vol. 1. Cambridge Monographs on Mathematical Physics. Cambridge: Cambridge University Press, 1984. DOI: 10.1017/CB09780511564048.</p>
<p>[Pen93] M. Pentus. "Lambek Grammars Are Context Free". In: Proceedings Eighth Annual IEEE Symposium on Logic in Computer Science. June 1993, pp. 429-433. DOI: 10.1109/LICS. 1993.287565.</p>
<p>[Pen06] Mati Pentus. "Lambek Calculus Is NP-complete". In: Theor. Comput. Sci. 357 (2006), pp. 186-201. DOI: 10.1016/j. tcs. 2006.03.018.</p><!-- Meanless: References 259-->
<p>[Per+14] Alberto Peruzzo, Jarrod McClean, Peter Shadbolt, Man-Hong Yung,</p>
<p>Xiao-Qi Zhou, Peter J. Love, Alán Aspuru-Guzik, and Jeremy L. O'Brien. "A Variational Eigenvalue Solver on a Photonic Quantum Processor". In: Nature Communications 5.1 (1 July 23, 2014), p. 4213. DOI: 10.1038/ncomms5213.</p>
<p>[Pes+21] Arthur Pesah, M. Cerezo, Samson Wang, Tyler Volkoff,</p>
<p>Andrew T. Sornborger, and Patrick J. Coles. "Absence of Barren Plateaus in Quantum Convolutional Neural Networks". In: Physical Review X 11.4 (Oct. 15, 2021), p. 041011. DOI: 10.1103/PhysRevX.11.041011.</p>
<p>[PGC19] Nicola Pinzani, Stefano Gogioso, and Bob Coecke. "Categorical Semantics for Time Travel". In: ArXiv e-prints (Jan. 31, 2019). arXiv: 1902.00032.</p>
<p>[Poi95] Henri Poincaré. Analysis Situs. Gauthier-Villars Paris, France, 1895.</p>
<p>[Pos47] Emil L. Post. "Recursive Unsolvability of a Problem of Thue". In: Journal of Symbolic Logic 12.1 (Mar. 1947), pp. 1-11. DOI: 10.2307/2267170.</p>
<p>[PR97] John Power and Edmund Robinson. "Premonoidal Categories and Notions of Computation". In: Mathematical Structures in Computer Science 7.5 (Oct. 1997), pp. 453-468. DOI: 10.1017/S0960129597002375.</p>
<p>[Pre07a] Anne Preller. "Linear Processing with Pregroups". In: Studia Logica: An International Journal for Symbolic Logic 87.2/3 (2007), pp. 171-197. JSTOR: 40210807.</p>
<p>[Pre07b] Anne Preller. "Toward Discourse Representation via Pregroup Grammars". In: Journal of Logic, Language and Information 16.2 (2007), pp. 173-194. DOI: 10.1007/s10849-006-9033-y.</p>
<p>[Pre10] Anne Preller. "Polynomial Pregroup Grammars Parse Context Sensitive Languages". In: 2010.</p>
<p>[Pre14a] Anne Preller. "From Logical to Distributional Models". In: Electronic Proceedings in Theoretical Computer Science 171 (Dec. 27, 2014), pp. 113-131. DOI: 10.4204/EPTCS. 171.11. arXiv: 1412.8527.</p>
<p>[Pre14b] Anne Preller. "Natural Language Semantics in Biproduct Dagger Categories". In: J. Applied Logic 12.1 (2014), pp. 88-108. DOI: 10.1016/j.jal.2013.08.001.</p>
<p>[PL07] Anne Preller and Joachim Lambek. "Free Compact 2-Categories". In: Mathematical Structures in Computer Science 17.2 (2007), pp. 309-340. DOI: 10.1017/S0960129506005901.</p>
<p>[Pre18] John Preskill. "Quantum Computing in the NISQ Era and Beyond". In: Quantum 2 (Aug. 6, 2018), p. 79. DOI: 10.22331/q-2018-08-06-79.</p><!-- Meanless: 260 References-->
<p>[RML14] Patrick Rebentrost, Masoud Mohseni, and Seth Lloyd. "Quantum Support Vector Machine for Big Data Classification". In: Physical Review Letters 113.13 (Sept. 25, 2014), p. 130503. DOI: 10.1103/PhysRevLett.113.130503.</p>
<p>[Rei13] Kurt Reidemeister. Knotentheorie. Vol. 1. Springer-Verlag, 2013.</p>
<p>[RV19] David Reutter and Jamie Vicary. "High-Level Methods for Homotopy Construction in Associative n-Categories". In: 2019 34th Annual ACM/IEEE Symposium on Logic in Computer Science (LICS). 2019, pp. 1-13. arXiv: 1902.03831.</p>
<p>[RV16] Emily Riehl and Dominic Verity. "Infinity Category Theory from Scratch". In: ArXiv e-prints (2016).</p>
<p>[Ril18] Mitchell Riley. "Categories of Optics". In: ArXiv e-prints (Sept. 3, 2018). arXiv: 1809.00738.</p>
<p>[Riz21] Irene Rizzo. "LinPP: A Python-friendly Algorithm for Linear Pregroup Parsing". In: Proceedings of the 2021 Workshop on Semantic Spaces at the Intersection of NLP, Physics, and Cognitive Science (SemSpace). IWCS-SemSpace 2021. Groningen, The Netherlands: Association for Computational Linguistics, June 2021, pp. 12-19. URL: <a href="https://aclanthology.org/2021.semspace-1.2">https://aclanthology.org/2021.semspace-1.2</a> (visited on \({03}/{05}/{2022})\) .</p>
<p>[Rob+19] Chase Roberts, Ashley Milsted, Martin Ganahl, Adam Zalcman, Bruce Fontaine, Yijian Zou, Jack Hidary, Guifre Vidal, and Stefan Leichenauer. "TensorNetwork: A Library for Physics and Machine Learning". In: ArXiv e-prints (May 3, 2019). arXiv: 1905.01330.</p>
<p>[Rom20a] Mario Román. "Coend Calculus and Open Diagrams". In: ArXiv e-prints (Apr. 9, 2020). arXiv: 2004.04526.</p>
<p>[Rom20b] Mario Román. "Comb Diagrams for Discrete-Time Feedback". In: ArXiv e-prints (Mar. 13, 2020). arXiv: 2003.06214.</p>
<p>[Rom22] Mario Román. Promonads and String Diagrams for Effectful Categories. May 16, 2022. arXiv: 2205.07664 [cs, math].</p>
<p>[Roo92] Dirk Roorda. "Proof Nets for Lambek Calculus". In: 2.2 (1992), pp. 211-231. DOI: 10.1093/logcom/2.2.211.</p>
<p>[RHW86] David E. Rumelhart, Geoffrey E. Hinton, and Ronald J. Williams. "Learning Representations by Back-Propagating Errors". In: Nature 323.6088 (6088 Oct. 1986), pp. 533-536. DOI: 10.1038/323533a0.</p><!-- Meanless: References 261-->
<table><tbody><tr><td>[RT05]</td><td>Mireille Ruppli and Sylvie Thorel. Mallarmé: la grammaire &#x26; le grimoire. Librairie Droz, 2005. 236 pp.</td></tr><tr><td>[Rus03]</td><td>Bertrand Russell. The Principles of Mathematics. Routledge, 1903.</td></tr><tr><td>[Ryl37]</td><td>G. Ryle. "Categories". In: Proceedings of the Aristotelian Society 38 (1937), pp. 189-206. JSTOR: 4544305.</td></tr><tr><td>[SCC13]</td><td>Mehrnoosh Sadrzadeh, Stephen Clark, and Bob Coecke. "The Frobenius Anatomy of Word Meanings I: Subject and Object Relative Pronouns". In: Journal of Logic and Computation 23 (2013), pp. 1293-1317. arXiv: 1404.5278.</td></tr><tr><td>[SCC14]</td><td>Mehrnoosh Sadrzadeh, Stephen Clark, and Bob Coecke. "The Frobenius Anatomy of Word Meanings II: Possessive Relative Pronouns". In: Journal of Logic and Computation abs/1406.4690 (2014), exu027. URL: http://arxiv.org/abs/1406.4690.</td></tr><tr><td>[Sal69]</td><td>Arto Salomaa. "Probabilistic and Weighted Grammars". In: Information and Control 15.6 (Dec. 1, 1969), pp. 529-544. DOI: 10.1016/S0019-9958(69)90554-3.</td></tr><tr><td>[SWY75]</td><td>G. Salton, A. Wong, and C. S. Yang. "A Vector Space Model for Automatic Indexing". In: Commun. ACM 18.11 (1975), pp. 613-620. DOI: 10.1145/361219.361220.</td></tr><tr><td>[Sav70]</td><td>Walter J Savitch. "Relationships between Nondeterministic and Deterministic Tape Complexities". In: Journal of computer and system sciences 4.2 (1970), pp. 177-192.</td></tr><tr><td>[SM21]</td><td>Lena Katharina Schiffer and Andreas Maletti. "Strong Equivalence of TAG and CCG". In: Transactions of the Association for Computational Linguistics 9 (Aug. 2, 2021), pp. 707-720. DOI: 10.1162/tacl_a_00393.</td></tr><tr><td>[Sch24]</td><td>M. Schönfinkel. "Über die Bausteine der mathematischen Logik". In: Mathematische Annalen 92.3 (Sept. 1, 1924), pp. 305-316. DOI: 10.1007/BF01448013.</td></tr><tr><td>[SCn21]</td><td>Urs Schreiber, David Corfield, and nLab. Science of Logic. 2021. URL: https://ncatlab.org/nlab/show/Science+of+Logic (visited on \( {12}/{15}/{2021}) \) .</td></tr><tr><td>[Sch21]</td><td>Maria Schuld. "Quantum Machine Learning Models Are Kernel Methods". In: ArXiv e-prints (Jan. 26, 2021). arXiv: 2101.11020.</td></tr></tbody></table><!-- Meanless: 262 References-->
<p>[Sch+19] Maria Schuld, Ville Bergholm, Christian Gogolin, Josh Izaac, and Nathan Killoran. "Evaluating Analytic Gradients on Quantum Hardware". In: Physical Review A 99.3 (Mar. 21, 2019), p. 032331. DOI: 10.1103/PhysRevA.99.032331. arXiv: 1811.11184.</p>
<p>[SK19] Maria Schuld and Nathan Killoran. "Quantum Machine Learning in Feature Hilbert Spaces". In: Physical Review Letters 122.4 (Feb. 1, 2019), p. 040504. DOI: 10.1103/PhysRevLett. 122.040504. arXiv: 1803.07128.</p>
<p>[SP97] M. Schuster and K.K. Paliwal. "Bidirectional Recurrent Neural Networks". In: IEEE Transactions on Signal Processing 45.11 (Nov. 1997), pp. 2673-2681. DOI: 10.1109/78.650093.</p>
<p>[Sco00] Phill J Scott. "Some Aspects of Categories in Computer Science". In: Handbook of Algebra. Vol. 2. Elsevier, 2000, pp. 3-77.</p>
<p>[Sel10] P. Selinger. "A Survey of Graphical Languages for Monoidal Categories". In: New Structures for Physics (2010), pp. 289-355. DOI: 10.1007/978-3-642-12821-9_4.</p>
<p>[Sel04] Peter Selinger. "Towards a Quantum Programming Language". In: Mathematical Structures in Computer Science 14.4 (2004), pp. 527-586.</p>
<p>[Sel07] Peter Selinger. "Dagger Compact Closed Categories and Completely Positive Maps: (Extended Abstract)". In: Electronic Notes in Theoretical Computer Science. Proceedings of the 3rd International Workshop on Quantum Programming Languages (QPL 2005) 170 (Mar. 6, 2007), pp. 139-163. DOI: 10.1016/j. entcs. 2006.12.018.</p>
<p>[SV06] Peter Selinger and Benoit Valiron. "A Lambda Calculus for Quantum Computation with Classical Control". In: Mathematical Structures in Computer Science 16.3 (June 2006), pp. 527-552. DOI: 10.1017/S0960129506005238.</p>
<p>[SV+09] Peter Selinger, Benoit Valiron, et al. "Quantum Lambda Calculus". In: Semantic techniques in quantum computation (2009), pp. 135-172.</p>
<p>[Sen20] Eli Sennesh. "Learning a Deep Generative Model like a Program: The Free Category Prior". In: ArXiv e-prints (Nov. 22, 2020). arXiv: 2011.11063.</p>
<p>[SB09] Dan Shepherd and Michael J. Bremner. "Temporally Unstructured Quantum Computation". In: Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences 465.2105 (May 8, 2009), pp. 1413-1439. DOI: 10.1098/rspa. 2008.0443.</p><!-- Meanless: References 263-->
<table><tbody><tr><td>[SY16]</td><td>Chihiro Shibata and Ryo Yoshinaka. "Probabilistic Learnability of Context-Free Grammars with Basic Distributional Properties from Positive Examples". In: Theoretical Computer Science. Algorithmic Learning Theory 620 (Mar. 21, 2016), pp. 46-72. DOI: 10.1016/j.tcs.2015.10.037.</td></tr><tr><td>[Shi85]</td><td>Stuart M. Shieber. "Evidence against the Context-Freeness of Natural Language". In: Linguistics and Philosophy 8.3 (Aug. 1, 1985), pp. 333-343. DOI: 10.1007/BF00630917.</td></tr><tr><td>[SGW21]</td><td>Dan Shiebler, Bruno Gavranović, and Paul Wilson. "Category Theory in Machine Learning". In: ArXiv e-prints (June 13, 2021). arXiv: 2106.07032.</td></tr><tr><td>[STS20]</td><td>Dan Shiebler, Alexis Toumi, and Mehrnoosh Sadrzadeh. "Incremental Monoidal Grammars". In: CoRR abs/2001.02296 (2020). arXiv: 2001.02296.</td></tr><tr><td>[Sho94]</td><td>P.W. Shor. "Algorithms for Quantum Computation: Discrete Logarithms and Factoring". In: Proceedings 35th Annual Symposium on Foundations of Computer Science. 35th Annual Symposium on Foundations of Computer Science. Santa Fe, NM, USA: IEEE Comput. Soc. Press, 1994, pp. 124-134. DOI: 10.1109/SFCS. 1994.365700.</td></tr><tr><td>[Sho96]</td><td>Peter W Shor. "Fault-Tolerant Quantum Computation". In: Proceedings of 37th Conference on Foundations of Computer Science. IEEE. 1996, pp. 56-65.</td></tr><tr><td>[Sim94]</td><td>D. Simon. "On the Power of Quantum Computation". In: 2013 IEEE 54th Annual Symposium on Foundations of Computer Science. Los Alamitos, CA, USA: IEEE Computer Society, Nov. 1994, pp. 116-123. DOI: 10.1109/SFCS.1994.365701.</td></tr><tr><td>[Siv+20]</td><td>Seyon Sivarajah, Silas Dilkes, Alexander Cowtan, Will Simmons, Alec Edgington, and Ross Duncan. "Tket: A Retargetable Compiler for NISQ Devices". In: Quantum Science and Technology 6.1 (2020), p. 014003. arXiv: 2003.10611.</td></tr><tr><td>[Smi21]</td><td>Paul Smith-Goodson. "Cambridge Quantum Makes Quantum Natural Language Processing A Reality". In: Forbes (Oct. 13, 2021). URL: https: //www.forbes.com/sites/moorinsights/2021/10/13/cambridge- quantum-makes-quantum-natural-language-processing-a-reality/ (visited on 02/24/2022).</td></tr></tbody></table><!-- Meanless: 264 References-->
<p>[Smo87] P. Smolensky. "Connectionist AI, Symbolic AI, and the Brain". In: Artificial Intelligence Review 1.2 (1987), pp. 95-109. DOI: 10.1007/BF00130011.</p>
<p>[Smo88] Paul Smolensky. "On the Proper Treatment of Connectionism". In: Behavioral and Brain Sciences 11.1 (Mar. 1988), pp. 1-23. DOI: 10.1017/S0140525X00052432.</p>
<p>[Smo90] Paul Smolensky. "Tensor Product Variable Binding and the Representation of Symbolic Structures in Connectionist Systems". In: Artificial Intelligence 46.1 (Nov. 1, 1990), pp. 159-216. DOI: 10.1016/0004-3702(90) 90007-M.</p>
<p>[SWZ19] Pawel Sobociński, Paul W. Wilson, and Fabio Zanasi. "CARTOGRAPHER: A Tool for String Diagrammatic Reasoning". In: CALCO 2019. Vol. 139. 2019, 20:1-20:7. DOI: 10.4230/LIPIcs.CALCO.2019.20.</p>
<p>[Soc+11] Richard Socher, Cliff Chiung-Yu Lin, Andrew Y. Ng, and Christopher D. Manning. "Parsing Natural Scenes and Natural Language with Recursive Neural Networks". In: Proceedings of the 28th International Conference on Machine Learning, ICML 2011, Bellevue, Washington, USA, June 28 - July 2, 2011. Ed. by Lise Getoor and Tobias Scheffer. Omnipress, 2011, pp. 129-136.</p>
<p>[Soc+13] Richard Socher, Alex Perelygin, Jean Wu, Jason Chuang, Christopher D. Manning, Andrew Y. Ng, and Christopher Potts. "Recursive Deep Models for Semantic Compositionality Over a Sentiment Treebank". In: Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, EMNLP 2013, 18-21 October 2013, Grand Hyatt Seattle, Seattle, Washington, USA, A Meeting of SIGDAT, a Special Interest Group of the ACL. ACL, 2013, pp. 1631-1642. URL: <a href="https://aclanthology.info/papers/D13-1170/d13-1170">https://aclanthology.info/papers/D13-1170/d13-1170</a> (visited on 11/05/2018).</p>
<p>[Spa98] James C Spall. "Implementation of the Simultaneous Perturbation Algorithm for Stochastic Optimization". In: IEEE Transactions on aerospace and electronic systems 34.3 (1998), pp. 817-823.</p>
<p>[Sta04] Edward P. Stabler. "Varieties of Crossing Dependencies: Structure Dependence and Mild Context Sensitivity". In: Cognitive Science 28.5 (2004), pp. 699-720. DOI: 10.1207/s15516709cog2805_4.</p>
<p>[Sta79] Richard Statman. "The Typed \(\lambda\) -Calculus Is Not Elementary Recursive". In: Theoretical Computer Science 9.1 (1979), pp. 73-81.</p><!-- Meanless: References 265-->
<table><tbody><tr><td>[SL13]</td><td>Sam Staton and Paul Blain Levy. "Universal Properties of Impure Programming Languages". In: Proceedings of the 40th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. POPL '13. New York, NY, USA: Association for Computing Machinery, Jan. 23, 2013, pp. 179-192. DOI: 10.1145/2429069.2429091.</td></tr><tr><td>[Ste87]</td><td>Mark Steedman. "Combinatory Grammars and Parasitic Gaps". In: Natural Language &#x26; Linguistic Theory 5.3 (1987), pp. 403-439. JSTOR: 4047583.</td></tr><tr><td>[Ste91]</td><td>Mark Steedman. "Type-Raising and Directionality in Combinatory Grammar". In: Proceedings of the 29th Annual Meeting on Association for Computational Linguistics -. The 29th Annual Meeting. Berkeley, California: Association for Computational Linguistics, 1991, pp. 71-78. DOI: 10.3115/981344.981354.</td></tr><tr><td>[Ste00]</td><td>Mark Steedman. The Syntactic Process. Vol. 24. Language, Speech, and Communication. MIT Press, 2000.</td></tr><tr><td>[Sto32]</td><td>M. H. Stone. "On One-Parameter Unitary Groups in Hilbert Space". In: Annals of Mathematics 33.3 (1932), pp. 643-648. DOI: 10.2307/1968538. JSTOR: 1968538.</td></tr><tr><td>[SMH11]</td><td>Ilya Sutskever, James Martens, and Geoffrey E Hinton. "Generating Text with Recurrent Neural Networks". In: ICML. 2011.</td></tr><tr><td>[SVL14]</td><td>Ilya Sutskever, Oriol Vinyals, and Quoc V Le. "Sequence to Sequence Learning with Neural Networks". In: Advances in Neural Information Processing Systems. Vol. 27. Curran Associates, Inc., 2014. URL: https://proceedings.neurips.cc/paper/2014/hash/ a14ac55a4f27472c5d894ec1c3c743d2-Abstract.html(visited on 11/22/2021).</td></tr><tr><td>[Tai67]</td><td>William W Tait. "Intensional Interpretations of Functionals of Finite Type I". In: The journal of symbolic logic 32.2 (1967), pp. 198-212.</td></tr><tr><td>[Tan13]</td><td>Till Tantau. "Graph Drawing in TikZ". In: Graph Drawing. Ed. by Walter Didimo and Maurizio Patrignani. Lecture Notes in Computer Science. Berlin, Heidelberg: Springer, 2013, pp. 517-528. DOI: 10.1007/978-3-642-36763-2_46.</td></tr><tr><td>[Thu14]</td><td>Axel Thue. "Probleme Über Veränderungen von Zeichenreihen Nach Gegebenen Regeln." In: Natur. KI 10 (1914).</td></tr><tr><td>[Tod91]</td><td>Seinosuke Toda. "PP Is as Hard as the Polynomial-Time Hierarchy". In: SIAM Journal on Computing 20.5 (1991), pp. 865-877.</td></tr></tbody></table><!-- Meanless: 266 References-->
<p>[Tou18] Alexis Toumi. "Categorical Compositional Distributional Questions, Answers &#x26; Discourse Analysis". PhD thesis. Master's thesis, University of Oxford, 2018.</p>
<p>[Tou20] Alexis Toumi. Language Processing on Quantum Hardware with DisCoPy. PyData Berlin. Sept. 21, 2020. URL:</p>
<p><a href="https://www.youtube.com/watch?v=5jK8qEQvR-o">https://www.youtube.com/watch?v=5jK8qEQvR-o</a> (visited on \({02}/{24}/{2022})\) .</p>
<p>[TF21a] Alexis Toumi and Giovanni de Felice. Categories for Linguistics. May 3, 2021. URL: <a href="https://github.com/oxford-quantum-group/discopy/">https://github.com/oxford-quantum-group/discopy/</a> blob/ea5b370d4853d7c0bdd1c3c4719a5f71917b1b6c/docs/slides/21- 05-03-tallcat.ipynb (visited on 04/03/2022).</p>
<p>[TF21b] Alexis Toumi and Giovanni de Felice. Categories for Quantum. May 5, 2021. URL: <a href="https://github.com/oxford-quantum-group/discopy/">https://github.com/oxford-quantum-group/discopy/</a> blob/ea5b370d4853d7c0bdd1c3c4719a5f71917b1b6c/docs/slides/21- 05-05-tallcat.ipynb (visited on 04/03/2022).</p>
<p>[TK21] Alexis Toumi and Alex Koziell-Pipe. "Functorial Language Models". In: CoRR abs/2103.14411 (2021). arXiv: 2103.14411.</p>
<p>[Tn21] Alexis Toumi and nLab. Dependency Grammar. 2021. URL: <a href="https://ncatlab.org/nlab/show/dependency+grammar">https://ncatlab.org/nlab/show/dependency+grammar</a> (visited on \({03}/{17}/{2022})\) .</p>
<p>[TYF21] Alexis Toumi, Richie Yeung, and Giovanni de Felice. "Diagrammatic Differentiation for Quantum Machine Learning". In: Proceedings 18th International Conference on Quantum Physics and Logic, QPL 2021, Gdansk, Poland, and Online, 7-11 June 2021. Ed. by Chris Heunen and Miriam Backens. Vol. 343. EPTCS. 2021, pp. 132-144. DOI: 10.4204/EPTCS. 343.7.</p>
<p>[Tro+17] Théo Trouillon, Christopher R. Dance, Johannes Welbl, Sebastian Riedel, Éric Gaussier, and Guillaume Bouchard. "Knowledge Graph Completion via Complex Tensor Factorization". In: The Journal of Machine Learning Research 18.1 (2017), pp. 4735-4772. eprint: arXiv:1702.06879.</p>
<p>[Tro+16] Théo Trouillon, Johannes Welbl, Sebastian Riedel, Éric Gaussier, and Guillaume Bouchard. "Complex Embeddings for Simple Link Prediction". In: ArXiv e-prints (June 20, 2016). arXiv: 1606.06357.</p>
<p>[Tur50] A. M. Turing. "Computing Machinery and Intelligence". In: Mind LIX.236 (Oct. 1, 1950), pp. 433-460. DOI: 10.1093/mind/LIX.236.433.</p><!-- Meanless: References 267-->
<p>[TP10] P. D. Turney and P. Pantel. "From Frequency to Meaning: Vector Space Models of Semantics". In: Journal of Artificial Intelligence Research 37 (Feb. 27, 2010), pp. 141-188. DOI: 10.1613/jair. 2934.</p>
<p>[UVZ18] Tarmo Uustalu, Niccolò Veltri, and Noam Zeilberger. "The Sequent Calculus of Skew Monoidal Categories". In: Electronic Notes in Theoretical Computer Science 341 (Dec. 2018), pp. 345-370. DOI: 10.1016/j.entcs.2018.11.017.</p>
<p>[Val79] Leslie G Valiant. "The Complexity of Computing the Permanent". In: Theoretical computer science 8.2 (1979), pp. 189-201.</p>
<p>[Val75] Leslie G. Valiant. "General Context-Free Recognition in Less than Cubic Time". In: Journal of Computer and System Sciences 10.2 (Apr. 1, 1975), pp. 308-315. DOI: 10.1016/S0022-0000(75)80046-8.</p>
<p>[vdWCV11] Stefan van der Walt, S. Chris Colbert, and Gael Varoquaux. "The NumPy Array: A Structure for Efficient Numerical Computation". In: Computing in Science Engineering 13.2 (Mar. 2011), pp. 22-30. DOI: 10.1109/MCSE.2011.37.</p>
<p>[Van04] André Van Tonder. "A Lambda Calculus for Quantum Computation". In: SIAM Journal on Computing 33.5 (2004), pp. 1109-1135.</p>
<p>[Vas+17] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. "Attention Is All You Need". In: ArXiv e-prints (Dec. 5, 2017). arXiv: 1706.03762.</p>
<p>[VD22] Jamie Vicary and Antonin Delpeuch. "Normalization for Planar String Diagrams and a Quadratic Equivalence Algorithm". In: Logical Methods in Computer Science 18 (2022). arXiv: 1804.07832.</p>
<p>[Vic21] Irene Vicente Nieto. Towards Machine Translation with Quantum Computers. 2021. URL:</p>
<p><a href="http://urn.kb.se/resolve?urn=urn:nbn:se:su:diva-196602">http://urn.kb.se/resolve?urn=urn:nbn:se:su:diva-196602</a> (visited on \({12}/{02}/{2021})\) .</p>
<p>[Vor77] Rodiani Voreadou. Coherence and Non-Commutative Diagrams in Closed Categories. Vol. 9. Memoirs of the American Mathematical Society 182. American Mathematical Society, 1977. DOI: 10.1090/memo/0182.</p>
<p>[Wal+14] Stéfan van der Walt, Johannes L. Schönberger, Juan Nunez-Iglesias, François Boulogne, Joshua D. Warner, Neil Yager, Emmanuelle Gouillart, and Tony Yu. "Scikit-Image: Image Processing in Python". In: PeerJ 2 (June 19, 2014), e453. DOI: 10.7717/peerj. 453.</p><!-- Meanless: 268 References-->
<p>[Wan20] Quanlong Wang. "Completeness of Algebraic ZX-calculus over Arbitrary Commutative Rings and Semirings". In: ArXiv e-prints (Oct. 11, 2020). arXiv: 1912.01003.</p>
<p>[WY22] Quanlong Wang and Richie Yeung. "Differentiating and Integrating ZX Diagrams". In: ArXiv e-prints (Feb. 28, 2022). arXiv: 2201.13250.</p>
<p>[Wea55] Warren Weaver. "Translation". In: Machine translation of languages 14.15-23 (1955), p. 10.</p>
<p>[Wei88] David Jeremy Weir. "Characterizing Mildly Context-Sensitive Grammar Formalisms". Philadelphia, PA, USA: University of Pennsylvania, 1988.</p>
<p>[Wie+19] Nathan Wiebe, Alex Bocharov, Paul Smolensky, Matthias Troyer, and Krysta M. Svore. "Quantum Language Processing". In: ArXiv e-prints (Feb. 13, 2019). arXiv: 1902.05162.</p>
<p>[WBL12] Nathan Wiebe, Daniel Braun, and Seth Lloyd. "Quantum Algorithm for Data Fitting". In: Physical Review Letters 109.5 (Aug. 2, 2012), p. 050505. DOI: 10.1103/PhysRevLett. 109.050505.</p>
<p>[Wij15] Gijs Wijnholds. Categorical Foundations for Extended Compositional Distributional Models of Meaning. Report. Jan. 22, 2015. URL: <a href="https://eprints.illc.uva.nl/id/eprint/940/">https://eprints.illc.uva.nl/id/eprint/940/</a> (visited on \({07}/{21}/{2022})\) .</p>
<p>[Wij17] Gijs Jasper Wijnholds. "Coherent Diagrammatic Reasoning in Compositional Distributional Semantics". In: Logic, Language, Information, and Computation - 24th International Workshop, WoLLIC 2017, London, \({UK}\) ,July 18-21,2017,Proceedings. Ed. by Juliette Kennedy and Ruy J. G. B. de Queiroz. Vol. 10388. Lecture Notes in Computer Science. Springer, 2017, pp. 371-386. DOI: 10.1007/978-3-662-55386-2\_27.</p>
<p>[WGZ22] Paul Wilson, Dan Ghica, and Fabio Zanasi. "String Diagrams for Non-Strict Monoidal Categories". In: ArXiv e-prints (Jan. 29, 2022). arXiv: 2201.11738.</p>
<p>[WZ20] Paul Wilson and Fabio Zanasi. "Reverse Derivative Ascent: A Categorical Approach to Learning Boolean Circuits". In: (2020), p. 14.</p>
<p>[wir21] HPC wire. Cambridge Quantum Releases World's First Quantum Natural Language Processing Toolkit and Library. Oct. 13, 2021. URL: https: //<a href="http://www.hpcwire.com/off-the-wire/cambridge-quantum-releases-worlds-first-quantum-natural-language-processing-toolkit/">www.hpcwire.com/off-the-wire/cambridge-quantum-releases-worlds-first-quantum-natural-language-processing-toolkit/</a> (visited on \({02}/{24}/{2022}\) ).</p><!-- Meanless: References 269-->
<table><tbody><tr><td>[Wit53]</td><td>Ludwig Wittgenstein. Philosophical Investigations. Oxford: Basil Blackwell, 1953.</td></tr><tr><td>[Wu+21]</td><td>Yulin Wu, Wan-Su Bao, Sirui Cao, Fusheng Chen, Ming-Cheng Chen, Xiawei Chen, Tung-Hsun Chung, Hui Deng, Yajie Du, Daojin Fan, Ming Gong, Cheng Guo, Chu Guo, Shaojun Guo, Lianchen Han, Linyin Hong, He-Liang Huang, Yong-Heng Huo, Liping Li, Na Li, Shaowei Li, Yuan Li, Futian Liang, Chun Lin, Jin Lin, Haoran Qian, Dan Qiao, Hao Rong, Hong Su, Lihua Sun, Liangyuan Wang, Shiyu Wang, Dachao Wu, Yu Xu, Kai Yan, Weifeng Yang, Yang Yang, Yangsen Ye, Jianghan Yin, Chong Ying, Jiale Yu, Chen Zha, Cha Zhang, Haibin Zhang, Kaili Zhang, Yiming Zhang, Han Zhao, Youwei Zhao, Liang Zhou, Qingling Zhu, Chao-Yang Lu, Cheng-Zhi Peng, Xiaobo Zhu, and Jian-Wei Pan. "Strong Quantum Computational Advantage Using a Superconducting Quantum Processor". In: Physical Review Letters 127.18 (Oct. 25, 2021), p. 180501. DOI: 10.1103/PhysRevLett. 127.180501.</td></tr><tr><td>[Yeu20]</td><td>Richie Yeung. "Diagrammatic Design and Study of Ansatze for Quantum Machine Learning". In: ArXiv e-prints (Nov. 22, 2020). arXiv: 2011.11073.</td></tr><tr><td>[YK21]</td><td>Richie Yeung and Dimitri Kartsaklis. "A CCG-Based Version of the DisCoCat Framework". In: ArXiv e-prints (May 24, 2021). arXiv: 2105.07720.</td></tr><tr><td>[Yon+21]</td><td>Yong, Liu, Xin, Liu, Fang, Li, Haohuan Fu, Yuling Yang, Jiawei Song, Pengpeng Zhao, Zhen Wang, Dajia Peng, Huarong Chen, Chu Guo, Heliang Huang, Wenzhao Wu, and Dexun Chen. "Closing the "Quantum Supremacy" Gap: Achieving Real-Time Simulation of a Random Quantum Circuit Using a New Sunway Supercomputer". In: Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (Nov. 14, 2021), pp. 1-12. DOI: 10.1145/3458817.3487399. arXiv: 2110.14502.</td></tr><tr><td>[ZC16]</td><td>William Zeng and Bob Coecke. "Quantum Algorithms for Compositional Natural Language Processing". In: Electronic Proceedings in Theoretical Computer Science 221 (Aug. 2, 2016), pp. 67-75. DOI: 10.4204/EPTCS. 221.8. arXiv: 1608.01406.</td></tr><tr><td>[Zho+20]</td><td>Han-Sen Zhong, Hui Wang, Yu-Hao Deng, Ming-Cheng Chen, Li-Chao Peng, Yi-Han Luo, Jian Qin, Dian Wu, Xing Ding, Yi Hu, Peng Hu, Xiao-Yan Yang, Wei-Jun Zhang, Hao Li, Yuxuan Li, Xiao Jiang, Lin Gan, Guangwen Yang, Lixing You, Zhen Wang, Li Li, Nai-Le Liu,</td></tr></tbody></table>
<!-- Media --><!-- Meanless: 270 References-->
<p>Chao-Yang Lu, and Jian-Wei Pan. "Quantum Computational Advantage</p>
<p>Using Photons". In: Science 370.6523 (Dec. 18, 2020), pp. 1460-1463. DOI: 10.1126/science.abe8770.arXiv: 2012.01625.</p>
<p>[Zhu+20] Jun-Yan Zhu, Taesung Park, Phillip Isola, and Alexei A. Efros. "Unpaired</p>
<p>Image-to-Image Translation Using Cycle-Consistent Adversarial Networks". In: ArXiv e-prints (Aug. 24, 2020). arXiv: 1703.10593.</p>
<p>[Zhu+21] Qingling Zhu, Sirui Cao, Fusheng Chen, Ming-Cheng Chen, Xiawei Chen, Tung-Hsun Chung, Hui Deng, Yajie Du, Daojin Fan, Ming Gong, Cheng Guo, Chu Guo, Shaojun Guo, Lianchen Han, Linyin Hong, He-Liang Huang, Yong-Heng Huo, Liping Li, Na Li, Shaowei Li, Yuan Li, Futian Liang, Chun Lin, Jin Lin, Haoran Qian, Dan Qiao, Hao Rong, Hong Su, Lihua Sun, Liangyuan Wang, Shiyu Wang, Dachao Wu, Yulin Wu, Yu Xu, Kai Yan, Weifeng Yang, Yang Yang, Yangsen Ye, Jianghan Yin, Chong Ying, Jiale Yu, Chen Zha, Cha Zhang, Haibin Zhang, Kaili Zhang, Yiming Zhang, Han Zhao, Youwei Zhao, Liang Zhou, Chao-Yang Lu, Cheng-Zhi Peng, Xiaobo Zhu, and Jian-Wei Pan. "Quantum Computational Advantage via 60-Qubit 24-Cycle Random Circuit Sampling". In: Science Bulletin (Oct. 25, 2021). DOI: 10.1016/j.scib.2021.10.017.</p>
      </body>
    </html>
  